<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="es">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/*******************************************************************************<a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2016 Pablo Pavon Mari√±o.<a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved. This program and the accompanying materials<a name="line.3"></a>
<span class="sourceLineNo">004</span> * are made available under the terms of the GNU Lesser Public License v2.1<a name="line.4"></a>
<span class="sourceLineNo">005</span> * which accompanies this distribution, and is available at<a name="line.5"></a>
<span class="sourceLineNo">006</span> * http://www.gnu.org/licenses/lgpl.html<a name="line.6"></a>
<span class="sourceLineNo">007</span> ******************************************************************************/<a name="line.7"></a>
<span class="sourceLineNo">008</span><a name="line.8"></a>
<span class="sourceLineNo">009</span><a name="line.9"></a>
<span class="sourceLineNo">010</span><a name="line.10"></a>
<span class="sourceLineNo">011</span><a name="line.11"></a>
<span class="sourceLineNo">012</span>package com.net2plan.examples.ocnbook.reports;<a name="line.12"></a>
<span class="sourceLineNo">013</span><a name="line.13"></a>
<span class="sourceLineNo">014</span>import java.io.Closeable;<a name="line.14"></a>
<span class="sourceLineNo">015</span>import java.io.File;<a name="line.15"></a>
<span class="sourceLineNo">016</span>import java.text.DecimalFormat;<a name="line.16"></a>
<span class="sourceLineNo">017</span>import java.util.ArrayList;<a name="line.17"></a>
<span class="sourceLineNo">018</span>import java.util.HashSet;<a name="line.18"></a>
<span class="sourceLineNo">019</span>import java.util.List;<a name="line.19"></a>
<span class="sourceLineNo">020</span>import java.util.Map;<a name="line.20"></a>
<span class="sourceLineNo">021</span>import java.util.Set;<a name="line.21"></a>
<span class="sourceLineNo">022</span><a name="line.22"></a>
<span class="sourceLineNo">023</span>import cern.colt.function.tdouble.DoubleDoubleFunction;<a name="line.23"></a>
<span class="sourceLineNo">024</span>import cern.colt.function.tdouble.DoubleFunction;<a name="line.24"></a>
<span class="sourceLineNo">025</span>import cern.colt.list.tdouble.DoubleArrayList;<a name="line.25"></a>
<span class="sourceLineNo">026</span>import cern.colt.list.tint.IntArrayList;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import cern.colt.matrix.tdouble.DoubleFactory1D;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import cern.colt.matrix.tdouble.DoubleMatrix1D;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import cern.colt.matrix.tdouble.DoubleMatrix2D;<a name="line.29"></a>
<span class="sourceLineNo">030</span><a name="line.30"></a>
<span class="sourceLineNo">031</span>import com.net2plan.interfaces.networkDesign.Demand;<a name="line.31"></a>
<span class="sourceLineNo">032</span>import com.net2plan.interfaces.networkDesign.IReport;<a name="line.32"></a>
<span class="sourceLineNo">033</span>import com.net2plan.interfaces.networkDesign.Link;<a name="line.33"></a>
<span class="sourceLineNo">034</span>import com.net2plan.interfaces.networkDesign.MulticastDemand;<a name="line.34"></a>
<span class="sourceLineNo">035</span>import com.net2plan.interfaces.networkDesign.Net2PlanException;<a name="line.35"></a>
<span class="sourceLineNo">036</span>import com.net2plan.interfaces.networkDesign.NetPlan;<a name="line.36"></a>
<span class="sourceLineNo">037</span>import com.net2plan.interfaces.networkDesign.NetworkLayer;<a name="line.37"></a>
<span class="sourceLineNo">038</span>import com.net2plan.interfaces.networkDesign.Node;<a name="line.38"></a>
<span class="sourceLineNo">039</span>import com.net2plan.interfaces.networkDesign.SharedRiskGroup;<a name="line.39"></a>
<span class="sourceLineNo">040</span>import com.net2plan.interfaces.simulation.IEventProcessor;<a name="line.40"></a>
<span class="sourceLineNo">041</span>import com.net2plan.interfaces.simulation.SimEvent;<a name="line.41"></a>
<span class="sourceLineNo">042</span>import com.net2plan.libraries.SRGUtils;<a name="line.42"></a>
<span class="sourceLineNo">043</span>import com.net2plan.utils.ClassLoaderUtils;<a name="line.43"></a>
<span class="sourceLineNo">044</span>import com.net2plan.utils.InputParameter;<a name="line.44"></a>
<span class="sourceLineNo">045</span>import com.net2plan.utils.StringUtils;<a name="line.45"></a>
<span class="sourceLineNo">046</span>import com.net2plan.utils.Triple;<a name="line.46"></a>
<span class="sourceLineNo">047</span><a name="line.47"></a>
<span class="sourceLineNo">048</span>/**<a name="line.48"></a>
<span class="sourceLineNo">049</span> * This report receives as an input a network design, the network recovery scheme algorithm, and the network risks (SRGs), and estimates the availability of the <a name="line.49"></a>
<span class="sourceLineNo">050</span> * network (including individual availabilities for each demand), using an enumerative process that also provides an estimation of the estimation error. <a name="line.50"></a>
<span class="sourceLineNo">051</span> * <a name="line.51"></a>
<span class="sourceLineNo">052</span> * @net2plan.keywords Network recovery: protection , Network recovery: restoration<a name="line.52"></a>
<span class="sourceLineNo">053</span> * @net2plan.ocnbooksections Section 3.7.3<a name="line.53"></a>
<span class="sourceLineNo">054</span> * @net2plan.inputParameters <a name="line.54"></a>
<span class="sourceLineNo">055</span> * @author Pablo Pavon-Marino<a name="line.55"></a>
<span class="sourceLineNo">056</span> */<a name="line.56"></a>
<span class="sourceLineNo">057</span>public class Report_availability implements IReport<a name="line.57"></a>
<span class="sourceLineNo">058</span>{<a name="line.58"></a>
<span class="sourceLineNo">059</span>        private InputParameter provisioningAlgorithm = new InputParameter ("provisioningAlgorithm" , "#eventProcessor#" , "Algorithm to process failure events");<a name="line.59"></a>
<span class="sourceLineNo">060</span>        private InputParameter analyzeDoubleFailures = new InputParameter ("analyzeDoubleFailures" , true , "Indicates whether double failures are studied");<a name="line.60"></a>
<span class="sourceLineNo">061</span>        private InputParameter defaultMTTFInHours = new InputParameter ("defaultMTTFInHours" , (double) 8748 , "Default value for Mean Time To Fail (hours)" , 0 , false , Double.MAX_VALUE , true);<a name="line.61"></a>
<span class="sourceLineNo">062</span>        private InputParameter defaultMTTRInHours = new InputParameter ("defaultMTTRInHours" , (double) 12 , "Default value for Mean Time To Repair (hours)" , 0 , false , Double.MAX_VALUE , true);<a name="line.62"></a>
<span class="sourceLineNo">063</span>        private InputParameter failureModel = new InputParameter ("failureModel" , "#select# perBidirectionalLinkBundle SRGfromNetPlan perNode perLink perDirectionalLinkBundle" , "Failure model selection: SRGfromNetPlan, perNode, perLink, perDirectionalLinkBundle, perBidirectionalLinkBundle");<a name="line.63"></a>
<span class="sourceLineNo">064</span>        private InputParameter considerTrafficInOversubscribedLinksAsLost = new InputParameter ("considerTrafficInOversubscribedLinksAsLost" , true , "If true, all the demands whose traffic (even only a fraction of it) traverses an oversubscribed link, are considered that all its treaffic is blocked, as they are supposed to fail to satisfy QoS agreements");<a name="line.64"></a>
<span class="sourceLineNo">065</span>        private InputParameter maximumE2ELatencyMs = new InputParameter ("maximumE2ELatencyMs", (double) -1 , "Maximum end-to-end latency of the traffic of any demand (a non-positive value means no limit). All the traffic of demands where a fraction of its traffic can exceed this value, are considered as lost, as they are supposed to fail to satisfy QoS agreements");<a name="line.65"></a>
<span class="sourceLineNo">066</span>        <a name="line.66"></a>
<span class="sourceLineNo">067</span>        private ArrayList&lt;DoubleMatrix1D&gt; availabilityClassicNoFailure_ld, availabilityWeightedNoFailure_ld, availabilityClassicNoFailure_lmd, availabilityWeightedNoFailure_lmd;<a name="line.67"></a>
<span class="sourceLineNo">068</span>        private ArrayList&lt;DoubleMatrix1D&gt; availabilityClassicTotal_ld, availabilityWeightedTotal_ld, availabilityClassicTotal_lmd, availabilityWeightedTotal_lmd;<a name="line.68"></a>
<span class="sourceLineNo">069</span>        private double pi_excess;<a name="line.69"></a>
<span class="sourceLineNo">070</span><a name="line.70"></a>
<span class="sourceLineNo">071</span>        private IEventProcessor algorithm;<a name="line.71"></a>
<span class="sourceLineNo">072</span>        <a name="line.72"></a>
<span class="sourceLineNo">073</span>        @Override<a name="line.73"></a>
<span class="sourceLineNo">074</span>        public String executeReport(NetPlan netPlan, Map&lt;String, String&gt; reportParameters, Map&lt;String, String&gt; net2planParameters)<a name="line.74"></a>
<span class="sourceLineNo">075</span>        {<a name="line.75"></a>
<span class="sourceLineNo">076</span>                /* Initialize all InputParameter objects defined in this object (this uses Java reflection) */<a name="line.76"></a>
<span class="sourceLineNo">077</span>                InputParameter.initializeAllInputParameterFieldsOfObject(this, reportParameters);<a name="line.77"></a>
<span class="sourceLineNo">078</span><a name="line.78"></a>
<span class="sourceLineNo">079</span>                String algorithmFile = reportParameters.get("provisioningAlgorithm_file");<a name="line.79"></a>
<span class="sourceLineNo">080</span>                String algorithmName = reportParameters.get("provisioningAlgorithm_classname");<a name="line.80"></a>
<span class="sourceLineNo">081</span>                String algorithmParam = reportParameters.get("provisioningAlgorithm_parameters");<a name="line.81"></a>
<span class="sourceLineNo">082</span>                if (algorithmFile.isEmpty() || algorithmName.isEmpty()) throw new Net2PlanException("A provisioning algorithm must be defined");<a name="line.82"></a>
<span class="sourceLineNo">083</span>                final double PRECISION_FACTOR_hd = Double.parseDouble(net2planParameters.get("precisionFactor"));<a name="line.83"></a>
<span class="sourceLineNo">084</span>                final double PRECISION_FACTOR_blocking = PRECISION_FACTOR_hd * PRECISION_FACTOR_hd;<a name="line.84"></a>
<span class="sourceLineNo">085</span>                <a name="line.85"></a>
<span class="sourceLineNo">086</span>                <a name="line.86"></a>
<span class="sourceLineNo">087</span>                Map&lt;String, String&gt; algorithmParameters = StringUtils.stringToMap(algorithmParam);<a name="line.87"></a>
<span class="sourceLineNo">088</span>                switch (failureModel.getString ())<a name="line.88"></a>
<span class="sourceLineNo">089</span>                {<a name="line.89"></a>
<span class="sourceLineNo">090</span>                        case "SRGfromNetPlan":<a name="line.90"></a>
<span class="sourceLineNo">091</span>                                break;<a name="line.91"></a>
<span class="sourceLineNo">092</span><a name="line.92"></a>
<span class="sourceLineNo">093</span>                        case "perNode":<a name="line.93"></a>
<span class="sourceLineNo">094</span>                                SRGUtils.configureSRGs(netPlan, defaultMTTFInHours.getDouble(), defaultMTTRInHours.getDouble(), SRGUtils.SharedRiskModel.PER_NODE, true);<a name="line.94"></a>
<span class="sourceLineNo">095</span>                                break;<a name="line.95"></a>
<span class="sourceLineNo">096</span><a name="line.96"></a>
<span class="sourceLineNo">097</span>                        case "perLink":<a name="line.97"></a>
<span class="sourceLineNo">098</span>                                SRGUtils.configureSRGs(netPlan, defaultMTTFInHours.getDouble(), defaultMTTRInHours.getDouble(), SRGUtils.SharedRiskModel.PER_LINK, true);<a name="line.98"></a>
<span class="sourceLineNo">099</span>                                break;<a name="line.99"></a>
<span class="sourceLineNo">100</span><a name="line.100"></a>
<span class="sourceLineNo">101</span>                        case "perDirectionalLinkBundle":<a name="line.101"></a>
<span class="sourceLineNo">102</span>                                SRGUtils.configureSRGs(netPlan, defaultMTTFInHours.getDouble(), defaultMTTRInHours.getDouble(), SRGUtils.SharedRiskModel.PER_DIRECTIONAL_LINK_BUNDLE, true);<a name="line.102"></a>
<span class="sourceLineNo">103</span>                                break;<a name="line.103"></a>
<span class="sourceLineNo">104</span><a name="line.104"></a>
<span class="sourceLineNo">105</span>                        case "perBidirectionalLinkBundle":<a name="line.105"></a>
<span class="sourceLineNo">106</span>                                SRGUtils.configureSRGs(netPlan, defaultMTTFInHours.getDouble(), defaultMTTRInHours.getDouble(), SRGUtils.SharedRiskModel.PER_BIDIRECTIONAL_LINK_BUNDLE, true);<a name="line.106"></a>
<span class="sourceLineNo">107</span>                                break;<a name="line.107"></a>
<span class="sourceLineNo">108</span><a name="line.108"></a>
<span class="sourceLineNo">109</span>                        default:<a name="line.109"></a>
<span class="sourceLineNo">110</span>                                throw new Net2PlanException("Failure model not valid. Please, check algorithm parameters description");<a name="line.110"></a>
<span class="sourceLineNo">111</span>                }<a name="line.111"></a>
<span class="sourceLineNo">112</span><a name="line.112"></a>
<span class="sourceLineNo">113</span>                netPlan.setAllNodesFailureState(true);<a name="line.113"></a>
<span class="sourceLineNo">114</span>                for (NetworkLayer layer : netPlan.getNetworkLayers ())<a name="line.114"></a>
<span class="sourceLineNo">115</span>                        netPlan.setAllLinksFailureState(true , layer);<a name="line.115"></a>
<span class="sourceLineNo">116</span>                DoubleMatrix1D A_f = netPlan.getVectorSRGAvailability();<a name="line.116"></a>
<span class="sourceLineNo">117</span>                List&lt;SharedRiskGroup&gt; srgs = netPlan.getSRGs();<a name="line.117"></a>
<span class="sourceLineNo">118</span>                DoubleMatrix2D F_s = SRGUtils.getMatrixFailureState2SRG(srgs, true, analyzeDoubleFailures.getBoolean());<a name="line.118"></a>
<span class="sourceLineNo">119</span>                <a name="line.119"></a>
<span class="sourceLineNo">120</span>                /* Compute state probabilities (pi_s) */<a name="line.120"></a>
<span class="sourceLineNo">121</span>                DoubleMatrix1D pi_s = SRGUtils.computeStateProbabilities(F_s , A_f);<a name="line.121"></a>
<span class="sourceLineNo">122</span>                final double sum_pi_s = pi_s.zSum();<a name="line.122"></a>
<span class="sourceLineNo">123</span>                <a name="line.123"></a>
<span class="sourceLineNo">124</span>                final double pi_s0 = pi_s.get(0); System.out.println ("Probability no failure state: " + pi_s0);<a name="line.124"></a>
<span class="sourceLineNo">125</span>                <a name="line.125"></a>
<span class="sourceLineNo">126</span>                pi_excess = 1 - sum_pi_s;<a name="line.126"></a>
<span class="sourceLineNo">127</span><a name="line.127"></a>
<span class="sourceLineNo">128</span>                /* Initialize statistics variables */<a name="line.128"></a>
<span class="sourceLineNo">129</span>                availabilityClassicNoFailure_ld = new ArrayList&lt;DoubleMatrix1D&gt; ();<a name="line.129"></a>
<span class="sourceLineNo">130</span>                availabilityWeightedNoFailure_ld = new ArrayList&lt;DoubleMatrix1D&gt; ();<a name="line.130"></a>
<span class="sourceLineNo">131</span>                availabilityClassicNoFailure_lmd = new ArrayList&lt;DoubleMatrix1D&gt; ();<a name="line.131"></a>
<span class="sourceLineNo">132</span>                availabilityWeightedNoFailure_lmd = new ArrayList&lt;DoubleMatrix1D&gt; ();<a name="line.132"></a>
<span class="sourceLineNo">133</span>                availabilityClassicTotal_ld = new ArrayList&lt;DoubleMatrix1D&gt; (); <a name="line.133"></a>
<span class="sourceLineNo">134</span>                availabilityWeightedTotal_ld = new ArrayList&lt;DoubleMatrix1D&gt; ();<a name="line.134"></a>
<span class="sourceLineNo">135</span>                availabilityClassicTotal_lmd = new ArrayList&lt;DoubleMatrix1D&gt; ();<a name="line.135"></a>
<span class="sourceLineNo">136</span>                availabilityWeightedTotal_lmd = new ArrayList&lt;DoubleMatrix1D&gt; ();<a name="line.136"></a>
<span class="sourceLineNo">137</span>                for(int indexLayer = 0 ; indexLayer &lt; netPlan.getNumberOfLayers() ; indexLayer ++)<a name="line.137"></a>
<span class="sourceLineNo">138</span>                {<a name="line.138"></a>
<span class="sourceLineNo">139</span>                        final NetworkLayer layer = netPlan.getNetworkLayer (indexLayer);<a name="line.139"></a>
<span class="sourceLineNo">140</span>                        final int D = netPlan.getNumberOfDemands(layer);<a name="line.140"></a>
<span class="sourceLineNo">141</span>                        final int MD = netPlan.getNumberOfMulticastDemands(layer);<a name="line.141"></a>
<span class="sourceLineNo">142</span>                        availabilityClassicTotal_ld.add (DoubleFactory1D.dense.make (D,0.0));<a name="line.142"></a>
<span class="sourceLineNo">143</span>                        availabilityWeightedTotal_ld.add (DoubleFactory1D.dense.make (D,0.0));<a name="line.143"></a>
<span class="sourceLineNo">144</span>                        availabilityClassicTotal_lmd.add (DoubleFactory1D.dense.make (MD,0.0));<a name="line.144"></a>
<span class="sourceLineNo">145</span>                        availabilityWeightedTotal_lmd.add (DoubleFactory1D.dense.make (MD,0.0));<a name="line.145"></a>
<span class="sourceLineNo">146</span>                }<a name="line.146"></a>
<span class="sourceLineNo">147</span><a name="line.147"></a>
<span class="sourceLineNo">148</span>//              List&lt;Link&gt; upAndOversubscribedLinksSetToDown = new LinkedList&lt;Link&gt; ();<a name="line.148"></a>
<span class="sourceLineNo">149</span>//              if (considerTrafficInOversubscribedLinksAsLost.getBoolean())<a name="line.149"></a>
<span class="sourceLineNo">150</span>//              {<a name="line.150"></a>
<span class="sourceLineNo">151</span>//                      for (NetworkLayer layer : netPlan.getNetworkLayers ())<a name="line.151"></a>
<span class="sourceLineNo">152</span>//                      {<a name="line.152"></a>
<span class="sourceLineNo">153</span>////                            System.out.println ("Layer " + layer + ", initial link capacity traffic: " + netPlan.getVectorLinkCapacity(layer));<a name="line.153"></a>
<span class="sourceLineNo">154</span>////                            System.out.println ("Layer " + layer + ", initial demand carried traffic: " + netPlan.getVectorDemandCarriedTraffic(layer));<a name="line.154"></a>
<span class="sourceLineNo">155</span>//                              for (Link e : netPlan.getLinks (layer)) if (e.isUp() &amp;&amp; e.isOversubscribed()) { upAndOversubscribedLinksSetToDown.add (e); }<a name="line.155"></a>
<span class="sourceLineNo">156</span>////                            System.out.println ("Layer: " + layer + ", upAndOversubscribedLinksSetToDown: " + upAndOversubscribedLinksSetToDown);<a name="line.156"></a>
<span class="sourceLineNo">157</span>//                      }<a name="line.157"></a>
<span class="sourceLineNo">158</span>//                      netPlan.setLinksAndNodesFailureState(null , upAndOversubscribedLinksSetToDown , null , null);<a name="line.158"></a>
<span class="sourceLineNo">159</span>//              }<a name="line.159"></a>
<span class="sourceLineNo">160</span>//<a name="line.160"></a>
<span class="sourceLineNo">161</span>//              System.out.println ("Links set to down all layers: " + netPlan.getLinksDownAllLayers());<a name="line.161"></a>
<span class="sourceLineNo">162</span><a name="line.162"></a>
<span class="sourceLineNo">163</span>                /* Statistics for the no-failure state */<a name="line.163"></a>
<span class="sourceLineNo">164</span>                for(int indexLayer = 0 ; indexLayer &lt; netPlan.getNumberOfLayers() ; indexLayer ++)<a name="line.164"></a>
<span class="sourceLineNo">165</span>                {<a name="line.165"></a>
<span class="sourceLineNo">166</span>                        final NetworkLayer layer = netPlan.getNetworkLayer (indexLayer);<a name="line.166"></a>
<span class="sourceLineNo">167</span><a name="line.167"></a>
<span class="sourceLineNo">168</span>                        final DoubleMatrix1D h_d = netPlan.getVectorDemandOfferedTraffic(layer);<a name="line.168"></a>
<span class="sourceLineNo">169</span>                        final DoubleMatrix1D blocked_d = netPlan.getVectorDemandBlockedTraffic(layer);<a name="line.169"></a>
<span class="sourceLineNo">170</span>                        if (considerTrafficInOversubscribedLinksAsLost.getBoolean()) for (Demand d : netPlan.getDemands (layer)) if (d.isTraversingOversubscribedLinks()) blocked_d.set (d.getIndex () , d.getOfferedTraffic());<a name="line.170"></a>
<span class="sourceLineNo">171</span>                        if (maximumE2ELatencyMs.getDouble () &gt; 0) for (Demand d : netPlan.getDemands (layer)) if (d.getWorseCasePropagationTimeInMs() &gt; maximumE2ELatencyMs.getDouble ()) blocked_d.set (d.getIndex () , d.getOfferedTraffic());<a name="line.171"></a>
<span class="sourceLineNo">172</span>                        <a name="line.172"></a>
<span class="sourceLineNo">173</span>                        final DoubleMatrix1D h_md = netPlan.getVectorMulticastDemandOfferedTraffic(layer);<a name="line.173"></a>
<span class="sourceLineNo">174</span>                        final DoubleMatrix1D blocked_md = netPlan.getVectorMulticastDemandBlockedTraffic(layer);<a name="line.174"></a>
<span class="sourceLineNo">175</span>                        if (considerTrafficInOversubscribedLinksAsLost.getBoolean()) for (MulticastDemand d : netPlan.getMulticastDemands (layer)) if (d.isTraversingOversubscribedLinks()) blocked_md.set (d.getIndex () , d.getOfferedTraffic());<a name="line.175"></a>
<span class="sourceLineNo">176</span>                        if (maximumE2ELatencyMs.getDouble () &gt; 0) for (MulticastDemand d : netPlan.getMulticastDemands(layer)) if (d.getWorseCasePropagationTimeInMs() &gt; maximumE2ELatencyMs.getDouble ()) blocked_md.set (d.getIndex () , d.getOfferedTraffic());<a name="line.176"></a>
<span class="sourceLineNo">177</span><a name="line.177"></a>
<span class="sourceLineNo">178</span>                        //                      System.out.println ("****** No failure Layer  " + layer + ", blocked_d: " + blocked_d);<a name="line.178"></a>
<span class="sourceLineNo">179</span>                        final DoubleMatrix1D availabilityClassic_d = blocked_d.copy ().assign (new DoubleFunction () { public double apply (double x) { return x &gt; PRECISION_FACTOR_blocking? 0 : 1;  }  } );<a name="line.179"></a>
<span class="sourceLineNo">180</span>                        final DoubleMatrix1D availabilityWeighted_d = blocked_d.copy ().assign (h_d , new DoubleDoubleFunction () { public double apply (double x , double y) { return y &lt; PRECISION_FACTOR_hd? 1 : 1 - x/y; }  } );<a name="line.180"></a>
<span class="sourceLineNo">181</span>                        final DoubleMatrix1D availabilityClassic_md = blocked_md.copy ().assign (new DoubleFunction () { public double apply (double x) { return x &gt; PRECISION_FACTOR_blocking ? 0 : 1;  }  } );<a name="line.181"></a>
<span class="sourceLineNo">182</span>                        final DoubleMatrix1D availabilityWeighted_md = blocked_md.copy ().assign (h_md , new DoubleDoubleFunction () { public double apply (double x , double y) { return y &lt; PRECISION_FACTOR_hd ? 1 : 1 - x/y; }  } );<a name="line.182"></a>
<span class="sourceLineNo">183</span><a name="line.183"></a>
<span class="sourceLineNo">184</span>                        availabilityClassicTotal_ld.get(layer.getIndex ()).assign (availabilityClassic_d , new DoubleDoubleFunction () { public double apply (double x , double y) { return x + pi_s0 * y; } } );<a name="line.184"></a>
<span class="sourceLineNo">185</span>                        availabilityWeightedTotal_ld.get(layer.getIndex ()).assign (availabilityWeighted_d , new DoubleDoubleFunction () { public double apply (double x , double y) { return x + pi_s0 * y; } } );<a name="line.185"></a>
<span class="sourceLineNo">186</span>                        availabilityClassicTotal_lmd.get(layer.getIndex ()).assign (availabilityClassic_md , new DoubleDoubleFunction () { public double apply (double x , double y) { return x + pi_s0 * y; } } );<a name="line.186"></a>
<span class="sourceLineNo">187</span>                        availabilityWeightedTotal_lmd.get(layer.getIndex ()).assign (availabilityWeighted_md , new DoubleDoubleFunction () { public double apply (double x , double y) { return x + pi_s0 * y; } } );<a name="line.187"></a>
<span class="sourceLineNo">188</span><a name="line.188"></a>
<span class="sourceLineNo">189</span>                        availabilityClassicNoFailure_ld.add(availabilityClassic_d);<a name="line.189"></a>
<span class="sourceLineNo">190</span>                        availabilityWeightedNoFailure_ld.add(availabilityWeighted_d);<a name="line.190"></a>
<span class="sourceLineNo">191</span>                        availabilityClassicNoFailure_lmd.add(availabilityClassic_md);<a name="line.191"></a>
<span class="sourceLineNo">192</span>                        availabilityWeightedNoFailure_lmd.add(availabilityWeighted_md);<a name="line.192"></a>
<span class="sourceLineNo">193</span>                }<a name="line.193"></a>
<span class="sourceLineNo">194</span>//              System.out.println ("Before any failure state: availabilityClassicTotal_ld: " + availabilityClassicTotal_ld);<a name="line.194"></a>
<span class="sourceLineNo">195</span>//              System.out.println ("Before any failure state: availabilityClassicNoFailure_ld: " + availabilityClassicNoFailure_ld);<a name="line.195"></a>
<span class="sourceLineNo">196</span><a name="line.196"></a>
<span class="sourceLineNo">197</span>                <a name="line.197"></a>
<span class="sourceLineNo">198</span>                /* the up and oversubscribed links that were set as down, are set to up again */<a name="line.198"></a>
<span class="sourceLineNo">199</span>//              if (considerTrafficInOversubscribedLinksAsLost.getBoolean())<a name="line.199"></a>
<span class="sourceLineNo">200</span>//                      netPlan.setLinksAndNodesFailureState(upAndOversubscribedLinksSetToDown , null , null , null);<a name="line.200"></a>
<span class="sourceLineNo">201</span><a name="line.201"></a>
<span class="sourceLineNo">202</span>                if (!netPlan.getLinksDownAllLayers().isEmpty() || !netPlan.getNodesDown().isEmpty()) throw new RuntimeException ("Bad");<a name="line.202"></a>
<span class="sourceLineNo">203</span><a name="line.203"></a>
<span class="sourceLineNo">204</span>                NetPlan auxNetPlan = netPlan.copy ();<a name="line.204"></a>
<span class="sourceLineNo">205</span>                this.algorithm = ClassLoaderUtils.getInstance(new File(algorithmFile), algorithmName, IEventProcessor.class);<a name="line.205"></a>
<span class="sourceLineNo">206</span>                this.algorithm.initialize(auxNetPlan , algorithmParameters , reportParameters , net2planParameters);<a name="line.206"></a>
<span class="sourceLineNo">207</span>                Set&lt;Link&gt; initialLinksDownAllLayers = auxNetPlan.getLinksDownAllLayers();<a name="line.207"></a>
<span class="sourceLineNo">208</span>                Set&lt;Node&gt; initialNodesDown = auxNetPlan.getNodesDown();<a name="line.208"></a>
<span class="sourceLineNo">209</span>                Set&lt;Link&gt; linksAllLayers = new HashSet&lt;Link&gt; (); for (NetworkLayer layer : auxNetPlan.getNetworkLayers()) linksAllLayers.addAll (auxNetPlan.getLinks (layer));<a name="line.209"></a>
<span class="sourceLineNo">210</span><a name="line.210"></a>
<span class="sourceLineNo">211</span>                for (int failureState = 1 ; failureState &lt; F_s.rows () ; failureState ++) // first failure state (no failure) was already considered<a name="line.211"></a>
<span class="sourceLineNo">212</span>                {<a name="line.212"></a>
<span class="sourceLineNo">213</span>                        if (!auxNetPlan.getLinksDownAllLayers().equals (initialLinksDownAllLayers) || !auxNetPlan.getNodesDown().equals(initialNodesDown)) throw new RuntimeException ("Bad");<a name="line.213"></a>
<span class="sourceLineNo">214</span><a name="line.214"></a>
<span class="sourceLineNo">215</span>                        IntArrayList srgs_thisState = new IntArrayList (); F_s.viewRow (failureState).getNonZeros (srgs_thisState , new DoubleArrayList ());<a name="line.215"></a>
<span class="sourceLineNo">216</span>                        final double pi_s_thisState = pi_s.get (failureState);<a name="line.216"></a>
<span class="sourceLineNo">217</span><a name="line.217"></a>
<span class="sourceLineNo">218</span>                        Set&lt;Link&gt; linksToSetAsDown = new HashSet&lt;Link&gt; ();<a name="line.218"></a>
<span class="sourceLineNo">219</span>                        Set&lt;Node&gt; nodesToSetAsDown = new HashSet&lt;Node&gt; ();<a name="line.219"></a>
<span class="sourceLineNo">220</span>                        for (SharedRiskGroup srg : auxNetPlan.getSRGs())<a name="line.220"></a>
<span class="sourceLineNo">221</span>                        {<a name="line.221"></a>
<span class="sourceLineNo">222</span>                                if (F_s.get(failureState , srg.getIndex ()) != 1) continue;<a name="line.222"></a>
<span class="sourceLineNo">223</span>                                nodesToSetAsDown.addAll (srg.getNodes ());<a name="line.223"></a>
<span class="sourceLineNo">224</span>                                linksToSetAsDown.addAll (srg.getLinks ());<a name="line.224"></a>
<span class="sourceLineNo">225</span>                        }<a name="line.225"></a>
<span class="sourceLineNo">226</span><a name="line.226"></a>
<span class="sourceLineNo">227</span>                        /* Make the algorithm process the event of nodes and links down */<a name="line.227"></a>
<span class="sourceLineNo">228</span>                        SimEvent.NodesAndLinksChangeFailureState failureInfo = new SimEvent.NodesAndLinksChangeFailureState(null , nodesToSetAsDown , null , linksToSetAsDown);<a name="line.228"></a>
<span class="sourceLineNo">229</span>                        try<a name="line.229"></a>
<span class="sourceLineNo">230</span>                        {<a name="line.230"></a>
<span class="sourceLineNo">231</span>                                /* Apply the reaction algorithm */<a name="line.231"></a>
<span class="sourceLineNo">232</span>                                algorithm.processEvent(auxNetPlan, new SimEvent(0, SimEvent.DestinationModule.EVENT_PROCESSOR , -1 , failureInfo));<a name="line.232"></a>
<span class="sourceLineNo">233</span>                        }<a name="line.233"></a>
<span class="sourceLineNo">234</span>                        catch (Throwable e)<a name="line.234"></a>
<span class="sourceLineNo">235</span>                        {<a name="line.235"></a>
<span class="sourceLineNo">236</span>                                try { ((Closeable) algorithm.getClass().getClassLoader()).close(); }<a name="line.236"></a>
<span class="sourceLineNo">237</span>                                catch (Throwable e1) { }                                        <a name="line.237"></a>
<span class="sourceLineNo">238</span><a name="line.238"></a>
<span class="sourceLineNo">239</span>                                throw (e);<a name="line.239"></a>
<span class="sourceLineNo">240</span>                        }<a name="line.240"></a>
<span class="sourceLineNo">241</span>                        <a name="line.241"></a>
<span class="sourceLineNo">242</span>                        try { ((Closeable) algorithm.getClass().getClassLoader()).close(); }<a name="line.242"></a>
<span class="sourceLineNo">243</span>                        catch (Throwable e1) { }                                        <a name="line.243"></a>
<span class="sourceLineNo">244</span><a name="line.244"></a>
<span class="sourceLineNo">245</span>                        for(NetworkLayer layer : auxNetPlan.getNetworkLayers ())<a name="line.245"></a>
<span class="sourceLineNo">246</span>                        {<a name="line.246"></a>
<span class="sourceLineNo">247</span>                                final DoubleMatrix1D h_d = auxNetPlan.getVectorDemandOfferedTraffic(layer);<a name="line.247"></a>
<span class="sourceLineNo">248</span>                                final DoubleMatrix1D blocked_d = auxNetPlan.getVectorDemandBlockedTraffic(layer);<a name="line.248"></a>
<span class="sourceLineNo">249</span>                                if (considerTrafficInOversubscribedLinksAsLost.getBoolean()) for (Demand d : auxNetPlan.getDemands (layer)) if (d.isTraversingOversubscribedLinks()) blocked_d.set (d.getIndex () , d.getOfferedTraffic());<a name="line.249"></a>
<span class="sourceLineNo">250</span>                                if (maximumE2ELatencyMs.getDouble () &gt; 0) for (Demand d : auxNetPlan.getDemands (layer)) if (d.getWorseCasePropagationTimeInMs() &gt; maximumE2ELatencyMs.getDouble ()) blocked_d.set (d.getIndex () , d.getOfferedTraffic());<a name="line.250"></a>
<span class="sourceLineNo">251</span>                                final DoubleMatrix1D h_md = auxNetPlan.getVectorMulticastDemandOfferedTraffic(layer);<a name="line.251"></a>
<span class="sourceLineNo">252</span>                                final DoubleMatrix1D blocked_md = auxNetPlan.getVectorMulticastDemandBlockedTraffic(layer);<a name="line.252"></a>
<span class="sourceLineNo">253</span>                                if (considerTrafficInOversubscribedLinksAsLost.getBoolean()) for (MulticastDemand d : auxNetPlan.getMulticastDemands (layer)) if (d.isTraversingOversubscribedLinks()) blocked_md.set (d.getIndex () , d.getOfferedTraffic());<a name="line.253"></a>
<span class="sourceLineNo">254</span>                                if (maximumE2ELatencyMs.getDouble () &gt; 0) for (MulticastDemand d : auxNetPlan.getMulticastDemands(layer)) if (d.getWorseCasePropagationTimeInMs() &gt; maximumE2ELatencyMs.getDouble ()) blocked_md.set (d.getIndex () , d.getOfferedTraffic());<a name="line.254"></a>
<span class="sourceLineNo">255</span>                                final DoubleMatrix1D availabilityClassic_d = blocked_d.copy ().assign (new DoubleFunction () { public double apply (double x) { return x &gt; PRECISION_FACTOR_blocking? 0 : 1;  }  } );<a name="line.255"></a>
<span class="sourceLineNo">256</span>                                final DoubleMatrix1D availabilityWeighted_d = blocked_d.copy ().assign (h_d , new DoubleDoubleFunction () { public double apply (double x , double y) { return y &lt; PRECISION_FACTOR_hd? 1 : 1 - x/y; }  } );<a name="line.256"></a>
<span class="sourceLineNo">257</span>                                final DoubleMatrix1D availabilityClassic_md = blocked_md.copy ().assign (new DoubleFunction () { public double apply (double x) { return x &gt; PRECISION_FACTOR_blocking? 0 : 1;  }  } );<a name="line.257"></a>
<span class="sourceLineNo">258</span>                                final DoubleMatrix1D availabilityWeighted_md = blocked_md.copy ().assign (h_md , new DoubleDoubleFunction () { public double apply (double x , double y) { return y &lt; PRECISION_FACTOR_hd? 1 : 1 - x/y; }  } );<a name="line.258"></a>
<span class="sourceLineNo">259</span><a name="line.259"></a>
<span class="sourceLineNo">260</span>//                              System.out.println ("****** Failure: " + failureState + ", Layer  " + layer + ", blocked_d: " + blocked_d);<a name="line.260"></a>
<span class="sourceLineNo">261</span>                                <a name="line.261"></a>
<span class="sourceLineNo">262</span>                                availabilityClassicTotal_ld.get(layer.getIndex ()).assign (availabilityClassic_d , new DoubleDoubleFunction () { public double apply (double x , double y) { return x + pi_s_thisState * y; } } );<a name="line.262"></a>
<span class="sourceLineNo">263</span>                                availabilityWeightedTotal_ld.get(layer.getIndex ()).assign (availabilityWeighted_d , new DoubleDoubleFunction () { public double apply (double x , double y) { return x + pi_s_thisState * y; } } );<a name="line.263"></a>
<span class="sourceLineNo">264</span>                                availabilityClassicTotal_lmd.get(layer.getIndex ()).assign (availabilityClassic_md , new DoubleDoubleFunction () { public double apply (double x , double y) { return x + pi_s_thisState * y; } } );<a name="line.264"></a>
<span class="sourceLineNo">265</span>                                availabilityWeightedTotal_lmd.get(layer.getIndex ()).assign (availabilityWeighted_md , new DoubleDoubleFunction () { public double apply (double x , double y) { return x + pi_s_thisState * y; } } );<a name="line.265"></a>
<span class="sourceLineNo">266</span>                                <a name="line.266"></a>
<span class="sourceLineNo">267</span>//                              System.out.println ("Failure " + failureState + ", availabilityClassicTotal_ld: " + availabilityClassicTotal_ld);<a name="line.267"></a>
<span class="sourceLineNo">268</span>                        }<a name="line.268"></a>
<span class="sourceLineNo">269</span>                        <a name="line.269"></a>
<span class="sourceLineNo">270</span>//                      System.out.println ("4. failure state: " + failureState + ", auxNetPlan.getLinksDownAllLayers(): " + auxNetPlan.getLinksDownAllLayers() + ", auxNetPlan.getNodesDown(): " + auxNetPlan.getNodesDown() + ", linksToSetDown: " + linksToSetAsDown);<a name="line.270"></a>
<span class="sourceLineNo">271</span>                        <a name="line.271"></a>
<span class="sourceLineNo">272</span>                        failureInfo = new SimEvent.NodesAndLinksChangeFailureState(auxNetPlan.getNodes() , null , linksAllLayers , null);<a name="line.272"></a>
<span class="sourceLineNo">273</span>                        algorithm.processEvent(auxNetPlan, new SimEvent(0, SimEvent.DestinationModule.EVENT_PROCESSOR , -1 , failureInfo));<a name="line.273"></a>
<span class="sourceLineNo">274</span><a name="line.274"></a>
<span class="sourceLineNo">275</span>//                      System.out.println ("5. failure state: " + failureState + ", auxNetPlan.getLinksDownAllLayers(): " + auxNetPlan.getLinksDownAllLayers() + ", auxNetPlan.getNodesDown(): " + auxNetPlan.getNodesDown() + ", linksToSetDown: " + linksToSetAsDown);<a name="line.275"></a>
<span class="sourceLineNo">276</span>                }<a name="line.276"></a>
<span class="sourceLineNo">277</span><a name="line.277"></a>
<span class="sourceLineNo">278</span>                return printReport(netPlan , reportParameters);<a name="line.278"></a>
<span class="sourceLineNo">279</span>        }<a name="line.279"></a>
<span class="sourceLineNo">280</span><a name="line.280"></a>
<span class="sourceLineNo">281</span>        @Override<a name="line.281"></a>
<span class="sourceLineNo">282</span>        public String getDescription()<a name="line.282"></a>
<span class="sourceLineNo">283</span>        {<a name="line.283"></a>
<span class="sourceLineNo">284</span>                return "This report receives as an input a network design, the network recovery scheme algorithm, and the network risks (SRGs), and estimates the availability of the network (including individual availabilities for each demand), using an enumerative process that also provides an estimation of the estimation error. ";<a name="line.284"></a>
<span class="sourceLineNo">285</span>        }<a name="line.285"></a>
<span class="sourceLineNo">286</span><a name="line.286"></a>
<span class="sourceLineNo">287</span>        @Override<a name="line.287"></a>
<span class="sourceLineNo">288</span>        public List&lt;Triple&lt;String, String, String&gt;&gt; getParameters()<a name="line.288"></a>
<span class="sourceLineNo">289</span>        {<a name="line.289"></a>
<span class="sourceLineNo">290</span>                /* Returns the parameter information for all the InputParameter objects defined in this object (uses Java reflection) */<a name="line.290"></a>
<span class="sourceLineNo">291</span>                return InputParameter.getInformationAllInputParameterFieldsOfObject(this);<a name="line.291"></a>
<span class="sourceLineNo">292</span>        }<a name="line.292"></a>
<span class="sourceLineNo">293</span><a name="line.293"></a>
<span class="sourceLineNo">294</span>        @Override<a name="line.294"></a>
<span class="sourceLineNo">295</span>        public String getTitle()<a name="line.295"></a>
<span class="sourceLineNo">296</span>        {<a name="line.296"></a>
<span class="sourceLineNo">297</span>                return "Availability report";<a name="line.297"></a>
<span class="sourceLineNo">298</span>        }<a name="line.298"></a>
<span class="sourceLineNo">299</span><a name="line.299"></a>
<span class="sourceLineNo">300</span>        <a name="line.300"></a>
<span class="sourceLineNo">301</span>        private String printReport(NetPlan np , Map&lt;String,String&gt; reportParameters)<a name="line.301"></a>
<span class="sourceLineNo">302</span>        {<a name="line.302"></a>
<span class="sourceLineNo">303</span>                StringBuilder out = new StringBuilder();<a name="line.303"></a>
<span class="sourceLineNo">304</span>                DecimalFormat df_6 = new DecimalFormat("#.######");<a name="line.304"></a>
<span class="sourceLineNo">305</span>                out.append("&lt;html&gt;&lt;body&gt;");<a name="line.305"></a>
<span class="sourceLineNo">306</span>                out.append("&lt;head&gt;&lt;title&gt;Availability report&lt;/title&gt;&lt;/head&gt;");<a name="line.306"></a>
<span class="sourceLineNo">307</span>                out.append("&lt;h1&gt;Introduction&lt;/h1&gt;");<a name="line.307"></a>
<span class="sourceLineNo">308</span>                out.append("&lt;p&gt;This report computes several availability measures for the different unicast and multicast demands in the different layers of the network." +<a name="line.308"></a>
<span class="sourceLineNo">309</span>                                "The network is supposed to be subject to the failures defined by the SRGs, and the possible network states considered are: &lt;/p&gt;");<a name="line.309"></a>
<span class="sourceLineNo">310</span>                out.append ("&lt;ul&gt;");<a name="line.310"></a>
<span class="sourceLineNo">311</span>                out.append ("&lt;li&gt;No failure occurs in the network&lt;/li&gt;");<a name="line.311"></a>
<span class="sourceLineNo">312</span>                out.append ("&lt;li&gt;Single SRG failure: A single SRG fails, while the rest of failures associated to the other SRGs do not occur&lt;/li&gt;");<a name="line.312"></a>
<span class="sourceLineNo">313</span>                out.append ("&lt;li&gt;Double SRG failure (optional): Two SRGs simultaneously fail, while the rest of failures associated to the other SRGs do not occur&lt;/li&gt;");<a name="line.313"></a>
<span class="sourceLineNo">314</span>                out.append ("&lt;/ul&gt;");<a name="line.314"></a>
<span class="sourceLineNo">315</span>                out.append("&lt;p&gt;A numerical method is used that (i) enumerates the possible failure states considered and the probability of occurrence, (ii) computes the network reaction" +<a name="line.315"></a>
<span class="sourceLineNo">316</span>                                "to that failure state using a used-defined algorithm, (iii) builds up the availability results for each demand from that.&lt;/p&gt;");<a name="line.316"></a>
<span class="sourceLineNo">317</span>                out.append("&lt;p&gt;Then, the method is able to produce an estimation of the availability of each unicast and multicast demand (and from them network-wide availability measures) under the given failures, and" +<a name="line.317"></a>
<span class="sourceLineNo">318</span>                                " assuming that the network reacts according to an arbitrary protection/restoration provided algorithm.&lt;/p&gt;");<a name="line.318"></a>
<span class="sourceLineNo">319</span>                out.append("&lt;p&gt;Two types of availability metrics are provided:&lt;/p&gt;");<a name="line.319"></a>
<span class="sourceLineNo">320</span>                out.append ("&lt;ul&gt;");<a name="line.320"></a>
<span class="sourceLineNo">321</span>                out.append ("&lt;li&gt;Availability of a demand/network: Fraction of time in which the demand/network is carrying the 100% of the offered traffic&lt;/li&gt;");<a name="line.321"></a>
<span class="sourceLineNo">322</span>                out.append ("&lt;li&gt;Traffic survivability of a demand/network: Fraction of the offered traffic that the network carries&lt;/li&gt;");<a name="line.322"></a>
<span class="sourceLineNo">323</span>                out.append ("&lt;/ul&gt;");<a name="line.323"></a>
<span class="sourceLineNo">324</span>                out.append("&lt;p&gt;Traffic survivability is always equals or higher than analogous availability value. For instance, if during some failure states that mean a 1% of the time, a demad is " +<a name="line.324"></a>
<span class="sourceLineNo">325</span>                                "carrying just a 50% of the traffic, the network availability is 99% (99% of the time everythign works perfectly well), but traffic survivability is " +<a name="line.325"></a>
<span class="sourceLineNo">326</span>                                "0.99*1 + 0.01*0.5 = 99.5%&lt;/p&gt;");<a name="line.326"></a>
<span class="sourceLineNo">327</span>                out.append("&lt;p&gt;In each metric, we provide a pessimistic and optimistic estimation. The pessimistic estimation, considers that in the triple, quadruple etc. " +<a name="line.327"></a>
<span class="sourceLineNo">328</span>                                "failure states, all the traffic is lost. In the optimistic case, we assume that in such cases, all the traffic is carried. &lt;/p&gt;");<a name="line.328"></a>
<span class="sourceLineNo">329</span>                <a name="line.329"></a>
<span class="sourceLineNo">330</span>                out.append("&lt;p&gt;For more information of this method:&lt;/p&gt;");<a name="line.330"></a>
<span class="sourceLineNo">331</span>                out.append("&lt;p&gt;P. PavÔøΩn Mari√±o, \"Optimization of computer networks. Modeling and algorithms. A hands-on approach\", Wiley 2016&lt;/p&gt;");<a name="line.331"></a>
<span class="sourceLineNo">332</span>                out.append("&lt;h1&gt;Global information&lt;/h1&gt;");<a name="line.332"></a>
<span class="sourceLineNo">333</span>                out.append("&lt;h2&gt;Input Parameters&lt;/h2&gt;");<a name="line.333"></a>
<span class="sourceLineNo">334</span>                out.append("&lt;table border='1'&gt;");<a name="line.334"></a>
<span class="sourceLineNo">335</span>                out.append("&lt;tr&gt;&lt;th&gt;&lt;b&gt;Name&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Value&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Description&lt;/b&gt;&lt;/th&gt;");<a name="line.335"></a>
<span class="sourceLineNo">336</span>                for (Triple&lt;String, String, String&gt; paramDef : getParameters())<a name="line.336"></a>
<span class="sourceLineNo">337</span>                {<a name="line.337"></a>
<span class="sourceLineNo">338</span>                        String name = paramDef.getFirst();<a name="line.338"></a>
<span class="sourceLineNo">339</span>                        String description = paramDef.getThird();<a name="line.339"></a>
<span class="sourceLineNo">340</span>                        String value = reportParameters.get(name);<a name="line.340"></a>
<span class="sourceLineNo">341</span>                        out.append("&lt;tr&gt;&lt;td&gt;").append(name).append("&lt;/td&gt;&lt;td&gt;").append(value).append("&lt;/td&gt;&lt;td&gt;").append(description).append("&lt;/td&gt;&lt;/tr&gt;");<a name="line.341"></a>
<span class="sourceLineNo">342</span>                }<a name="line.342"></a>
<span class="sourceLineNo">343</span>                out.append("&lt;tr&gt;&lt;td&gt;--Estimated error in availability calculations: &lt;/td&gt;&lt;td&gt;" + pi_excess + "&lt;/td&gt;&lt;td&gt;Probabilities of triple failure, quadruple etc. of non enumerated network states&lt;/td&gt;&lt;/tr&gt;");<a name="line.343"></a>
<span class="sourceLineNo">344</span>                out.append("&lt;/table&gt;");<a name="line.344"></a>
<span class="sourceLineNo">345</span><a name="line.345"></a>
<span class="sourceLineNo">346</span>                out.append("&lt;h1&gt;PER LAYER INFORMATION SUMMARY&lt;/h1&gt;");<a name="line.346"></a>
<span class="sourceLineNo">347</span>                for (NetworkLayer layer : np.getNetworkLayers ())<a name="line.347"></a>
<span class="sourceLineNo">348</span>                {<a name="line.348"></a>
<span class="sourceLineNo">349</span>                        double val;<a name="line.349"></a>
<span class="sourceLineNo">350</span><a name="line.350"></a>
<span class="sourceLineNo">351</span>                        out.append("&lt;h2&gt;Layer " + layer.getName () + ", index = " + layer.getIndex () + ", id = " + layer.getId () + "&lt;/h2&gt;");<a name="line.351"></a>
<span class="sourceLineNo">352</span>                        final DoubleMatrix1D h_d = np.getVectorDemandOfferedTraffic(layer);<a name="line.352"></a>
<span class="sourceLineNo">353</span>                        final DoubleMatrix1D h_md = np.getVectorMulticastDemandOfferedTraffic(layer);<a name="line.353"></a>
<span class="sourceLineNo">354</span>                        final DoubleMatrix1D avNoFailure_d = this.availabilityClassicNoFailure_ld.get(layer.getIndex ());<a name="line.354"></a>
<span class="sourceLineNo">355</span>                        final DoubleMatrix1D survNoFailure_d = this.availabilityWeightedNoFailure_ld.get(layer.getIndex ());<a name="line.355"></a>
<span class="sourceLineNo">356</span>                        final DoubleMatrix1D avNoFailure_md = this.availabilityClassicNoFailure_lmd.get(layer.getIndex ());<a name="line.356"></a>
<span class="sourceLineNo">357</span>                        final DoubleMatrix1D survNoFailure_md = this.availabilityWeightedNoFailure_lmd.get(layer.getIndex ());<a name="line.357"></a>
<span class="sourceLineNo">358</span>                        final DoubleMatrix1D avTotal_d = this.availabilityClassicTotal_ld.get(layer.getIndex ());<a name="line.358"></a>
<span class="sourceLineNo">359</span>                        final DoubleMatrix1D survTotal_d = this.availabilityWeightedTotal_ld.get(layer.getIndex ());<a name="line.359"></a>
<span class="sourceLineNo">360</span>                        final DoubleMatrix1D avTotal_md = this.availabilityClassicTotal_lmd.get(layer.getIndex ());<a name="line.360"></a>
<span class="sourceLineNo">361</span>                        final DoubleMatrix1D survTotal_md = this.availabilityWeightedTotal_lmd.get(layer.getIndex ());<a name="line.361"></a>
<span class="sourceLineNo">362</span><a name="line.362"></a>
<span class="sourceLineNo">363</span>                        out.append ("&lt;ul&gt;");<a name="line.363"></a>
<span class="sourceLineNo">364</span>                        final double H = h_d.zSum();<a name="line.364"></a>
<span class="sourceLineNo">365</span>                        val = h_d.size () == 0? 0 : H; out.append ("&lt;li&gt;UNICAST TRAFFIC: (Deterministic) Total offered traffic: " + df_6.format (val) + "&lt;/li&gt;");<a name="line.365"></a>
<span class="sourceLineNo">366</span>                        if (np.getNumberOfDemands (layer) != 0)<a name="line.366"></a>
<span class="sourceLineNo">367</span>                        {<a name="line.367"></a>
<span class="sourceLineNo">368</span>                                val = survNoFailure_d.size () == 0? 0 : 1 - (survNoFailure_d.zDotProduct(h_d) / H); out.append ("&lt;li&gt;UNICAST TRAFFIC: (Deterministic) Blocked traffic when no failure occurs: " + df_6.format (val) + "&lt;/li&gt;");<a name="line.368"></a>
<span class="sourceLineNo">369</span>                                val = avTotal_d.size () == 0? 0 : avTotal_d.zDotProduct(h_d) / H; out.append ("&lt;li&gt;UNICAST TRAFFIC: (Estimated) Network availability: " + df_6.format(val) + " - " + df_6.format(val + pi_excess)  + "&lt;/li&gt;");<a name="line.369"></a>
<span class="sourceLineNo">370</span>                                val = survTotal_d.size () == 0? 0 : survTotal_d.zDotProduct(h_d) / H; out.append ("&lt;li&gt;UNICAST TRAFFIC: (Estimated) Network traffic survivability: " + df_6.format(val) + " - " + df_6.format(val + pi_excess) + "&lt;/li&gt;");<a name="line.370"></a>
<span class="sourceLineNo">371</span>                                val = avTotal_d.size () == 0? 0 : avTotal_d.getMinLocation() [0]; out.append ("&lt;li&gt;UNICAST TRAFFIC: (Estimated) Worse availability among demands: " + df_6.format(val) + " - " + df_6.format(val + pi_excess)  + "&lt;/li&gt;");<a name="line.371"></a>
<span class="sourceLineNo">372</span>                                val = survTotal_d.size () == 0? 0 : survTotal_d.getMinLocation() [0]; out.append ("&lt;li&gt;UNICAST TRAFFIC: (Estimated) Worse traffic survivability among demands: " + df_6.format(val) + " - " + df_6.format(val + pi_excess)  + "&lt;/li&gt;");<a name="line.372"></a>
<span class="sourceLineNo">373</span>                        }                       <a name="line.373"></a>
<span class="sourceLineNo">374</span>                        final double MH = h_md.zSum();<a name="line.374"></a>
<span class="sourceLineNo">375</span>                        val = h_md.size () == 0? 0 : MH; out.append ("&lt;li&gt;MULTICAST TRAFFIC: (Deterministic) Total offered traffic: " + df_6.format (val) + "&lt;/li&gt;");<a name="line.375"></a>
<span class="sourceLineNo">376</span>                        if (np.getNumberOfMulticastDemands(layer) != 0)<a name="line.376"></a>
<span class="sourceLineNo">377</span>                        {<a name="line.377"></a>
<span class="sourceLineNo">378</span>                                val = survNoFailure_md.size () == 0? 0 : 1-(survNoFailure_md.zDotProduct(h_md) / MH); out.append ("&lt;li&gt;MULTICAST TRAFFIC: (Deterministic) Blocked traffic when no failure occurs: " + df_6.format (val) + "&lt;/li&gt;");<a name="line.378"></a>
<span class="sourceLineNo">379</span>                                val = avTotal_md.size () == 0? 0 : avTotal_md.zDotProduct(h_md) / MH; out.append ("&lt;li&gt;MULTICAST TRAFFIC: (Estimated) Network availability: " + df_6.format(val) + " - " + df_6.format(val + pi_excess)  + "&lt;/li&gt;");<a name="line.379"></a>
<span class="sourceLineNo">380</span>                                val = survTotal_md.size () == 0? 0 : survTotal_md.zDotProduct(h_md) /MH; out.append ("&lt;li&gt;MULTICAST TRAFFIC: (Estimated) Network traffic survivability: " + df_6.format(val) + " - " + df_6.format(val + pi_excess) + "&lt;/li&gt;");<a name="line.380"></a>
<span class="sourceLineNo">381</span>                                val = avTotal_md.size () == 0? 0 : avTotal_md.getMinLocation() [0]; out.append ("&lt;li&gt;MULTICAST TRAFFIC: (Estimated) Worse availability among demands: " + df_6.format(val) + " - " + df_6.format(val + pi_excess)  + "&lt;/li&gt;");<a name="line.381"></a>
<span class="sourceLineNo">382</span>                                val = survTotal_md.size () == 0? 0 : survTotal_md.getMinLocation() [0]; out.append ("&lt;li&gt;MULTICAST TRAFFIC: (Estimated) Worse traffic survivability among demands: " + df_6.format(val) + " - " + df_6.format(val + pi_excess)  + "&lt;/li&gt;");<a name="line.382"></a>
<span class="sourceLineNo">383</span>                        }<a name="line.383"></a>
<span class="sourceLineNo">384</span>                }<a name="line.384"></a>
<span class="sourceLineNo">385</span><a name="line.385"></a>
<span class="sourceLineNo">386</span>                <a name="line.386"></a>
<span class="sourceLineNo">387</span>                out.append("&lt;h1&gt;PER LAYER INFORMATION DETAILED INFORMATION&lt;/h1&gt;");<a name="line.387"></a>
<span class="sourceLineNo">388</span>                for (NetworkLayer layer : np.getNetworkLayers ())<a name="line.388"></a>
<span class="sourceLineNo">389</span>                {<a name="line.389"></a>
<span class="sourceLineNo">390</span>                        out.append("&lt;h2&gt;Layer " + layer.getName () + ", index = " + layer.getIndex () + ", id = " + layer.getId () + "&lt;/h2&gt;");<a name="line.390"></a>
<span class="sourceLineNo">391</span>                        final DoubleMatrix1D avTotal_d = this.availabilityClassicTotal_ld.get(layer.getIndex ());<a name="line.391"></a>
<span class="sourceLineNo">392</span>                        final DoubleMatrix1D survTotal_d = this.availabilityWeightedTotal_ld.get(layer.getIndex ());<a name="line.392"></a>
<span class="sourceLineNo">393</span>                        final DoubleMatrix1D avTotal_md = this.availabilityClassicTotal_lmd.get(layer.getIndex ());<a name="line.393"></a>
<span class="sourceLineNo">394</span>                        final DoubleMatrix1D survTotal_md = this.availabilityWeightedTotal_lmd.get(layer.getIndex ());<a name="line.394"></a>
<span class="sourceLineNo">395</span><a name="line.395"></a>
<span class="sourceLineNo">396</span>                        if (np.getNumberOfDemands(layer) != 0)<a name="line.396"></a>
<span class="sourceLineNo">397</span>                        {<a name="line.397"></a>
<span class="sourceLineNo">398</span>                                out.append("&lt;table border='1'&gt;");<a name="line.398"></a>
<span class="sourceLineNo">399</span>                                out.append("&lt;tr&gt;&lt;th&gt;&lt;b&gt;Demand&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Origin node&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Destination node&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Availability&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Traffic survivability&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;");<a name="line.399"></a>
<span class="sourceLineNo">400</span>                                for (Demand d : np.getDemands (layer))<a name="line.400"></a>
<span class="sourceLineNo">401</span>                                        out.append("&lt;tr&gt;&lt;td&gt; " + d.getIndex () + " id (" + d.getId () + ")" + "&lt;/td&gt;&lt;td&gt;" + d.getIngressNode ().getIndex () + " (" + d.getIngressNode ().getName () + ") &lt;/td&gt;&lt;td&gt; " + d.getEgressNode().getIndex () + " (" + d.getEgressNode().getName () + ")&lt;/td&gt;&lt;td&gt;" + avTotal_d.get(d.getIndex()) +" ... " + (avTotal_d.get(d.getIndex()) + pi_excess) + "&lt;/td&gt;&lt;td&gt;" +  survTotal_d.get(d.getIndex()) + " ... " + (survTotal_d.get(d.getIndex()) + pi_excess) + "&lt;/td&gt;&lt;/tr&gt;");<a name="line.401"></a>
<span class="sourceLineNo">402</span>                                out.append("&lt;/table&gt;");<a name="line.402"></a>
<span class="sourceLineNo">403</span>        <a name="line.403"></a>
<span class="sourceLineNo">404</span>                                out.append("&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;");<a name="line.404"></a>
<span class="sourceLineNo">405</span>                        }<a name="line.405"></a>
<span class="sourceLineNo">406</span>                        if (np.getNumberOfMulticastDemands(layer) != 0)<a name="line.406"></a>
<span class="sourceLineNo">407</span>                        {<a name="line.407"></a>
<span class="sourceLineNo">408</span>                                out.append("&lt;table border='1'&gt;");<a name="line.408"></a>
<span class="sourceLineNo">409</span>                                out.append("&lt;tr&gt;&lt;th&gt;&lt;b&gt;Multicast demand&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Origin node&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Destination nodes&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Availability&lt;/b&gt;&lt;/th&gt;&lt;th&gt;&lt;b&gt;Traffic survivability&lt;/b&gt;&lt;/th&gt;&lt;/tr&gt;");<a name="line.409"></a>
<span class="sourceLineNo">410</span>                                for (MulticastDemand d : np.getMulticastDemands (layer))<a name="line.410"></a>
<span class="sourceLineNo">411</span>                                {<a name="line.411"></a>
<span class="sourceLineNo">412</span>                                        String egressNodesInfo = ""; for (Node n : d.getEgressNodes()) egressNodesInfo += n.getIndex () + "(" + n.getName () + ") ";<a name="line.412"></a>
<span class="sourceLineNo">413</span>                                        out.append("&lt;tr&gt;&lt;td&gt; " + d.getIndex () + " id (" + d.getId () + ")" + "&lt;/td&gt;&lt;td&gt;" + d.getIngressNode ().getIndex () + " (" + d.getIngressNode ().getName () + ") &lt;/td&gt;&lt;td&gt; " + egressNodesInfo + "&lt;/td&gt;&lt;td&gt;" + avTotal_md.get(d.getIndex())  + " ... " + (avTotal_md.get(d.getIndex()) + pi_excess) + "&lt;/td&gt;&lt;td&gt;" +  survTotal_md.get(d.getIndex())  + " ... " + (survTotal_md.get(d.getIndex()) + pi_excess) + "&lt;/td&gt;&lt;/tr&gt;");<a name="line.413"></a>
<span class="sourceLineNo">414</span>                                }<a name="line.414"></a>
<span class="sourceLineNo">415</span>                                out.append("&lt;/table&gt;");<a name="line.415"></a>
<span class="sourceLineNo">416</span>                        }                       <a name="line.416"></a>
<span class="sourceLineNo">417</span>                }<a name="line.417"></a>
<span class="sourceLineNo">418</span>                <a name="line.418"></a>
<span class="sourceLineNo">419</span>                return out.toString();<a name="line.419"></a>
<span class="sourceLineNo">420</span>        }<a name="line.420"></a>
<span class="sourceLineNo">421</span><a name="line.421"></a>
<span class="sourceLineNo">422</span>        <a name="line.422"></a>
<span class="sourceLineNo">423</span>        <a name="line.423"></a>
<span class="sourceLineNo">424</span>}<a name="line.424"></a>




























































</pre>
</div>
</body>
</html>
