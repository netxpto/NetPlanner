<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="es">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/*******************************************************************************<a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2016 Pablo Pavon Mari√±o.<a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved. This program and the accompanying materials<a name="line.3"></a>
<span class="sourceLineNo">004</span> * are made available under the terms of the GNU Lesser Public License v2.1<a name="line.4"></a>
<span class="sourceLineNo">005</span> * which accompanies this distribution, and is available at<a name="line.5"></a>
<span class="sourceLineNo">006</span> * http://www.gnu.org/licenses/lgpl.html<a name="line.6"></a>
<span class="sourceLineNo">007</span> ******************************************************************************/<a name="line.7"></a>
<span class="sourceLineNo">008</span>package com.net2plan.examples.ocnbook.onlineSim;<a name="line.8"></a>
<span class="sourceLineNo">009</span><a name="line.9"></a>
<span class="sourceLineNo">010</span><a name="line.10"></a>
<span class="sourceLineNo">011</span><a name="line.11"></a>
<span class="sourceLineNo">012</span><a name="line.12"></a>
<span class="sourceLineNo">013</span>import java.io.File;<a name="line.13"></a>
<span class="sourceLineNo">014</span>import java.util.HashMap;<a name="line.14"></a>
<span class="sourceLineNo">015</span>import java.util.List;<a name="line.15"></a>
<span class="sourceLineNo">016</span>import java.util.Map;<a name="line.16"></a>
<span class="sourceLineNo">017</span>import java.util.Random;<a name="line.17"></a>
<span class="sourceLineNo">018</span><a name="line.18"></a>
<span class="sourceLineNo">019</span>import cern.colt.matrix.tdouble.DoubleFactory1D;<a name="line.19"></a>
<span class="sourceLineNo">020</span>import cern.colt.matrix.tdouble.DoubleFactory2D;<a name="line.20"></a>
<span class="sourceLineNo">021</span>import cern.colt.matrix.tdouble.DoubleMatrix1D;<a name="line.21"></a>
<span class="sourceLineNo">022</span>import cern.colt.matrix.tdouble.DoubleMatrix2D;<a name="line.22"></a>
<span class="sourceLineNo">023</span>import cern.jet.math.tdouble.DoubleFunctions;<a name="line.23"></a>
<span class="sourceLineNo">024</span><a name="line.24"></a>
<span class="sourceLineNo">025</span>import com.net2plan.examples.ocnbook.offline.Offline_cba_congControLinkBwSplitTwolQoS;<a name="line.25"></a>
<span class="sourceLineNo">026</span>import com.net2plan.interfaces.networkDesign.Demand;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import com.net2plan.interfaces.networkDesign.Link;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import com.net2plan.interfaces.networkDesign.Net2PlanException;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import com.net2plan.interfaces.networkDesign.NetPlan;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import com.net2plan.interfaces.networkDesign.Node;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import com.net2plan.interfaces.networkDesign.Route;<a name="line.31"></a>
<span class="sourceLineNo">032</span>import com.net2plan.interfaces.simulation.IEventProcessor;<a name="line.32"></a>
<span class="sourceLineNo">033</span>import com.net2plan.interfaces.simulation.SimEvent;<a name="line.33"></a>
<span class="sourceLineNo">034</span>import com.net2plan.utils.Constants.RoutingType;<a name="line.34"></a>
<span class="sourceLineNo">035</span>import com.net2plan.utils.GradientProjectionUtils;<a name="line.35"></a>
<span class="sourceLineNo">036</span>import com.net2plan.utils.InputParameter;<a name="line.36"></a>
<span class="sourceLineNo">037</span>import com.net2plan.utils.Pair;<a name="line.37"></a>
<span class="sourceLineNo">038</span>import com.net2plan.utils.TimeTrace;<a name="line.38"></a>
<span class="sourceLineNo">039</span>import com.net2plan.utils.Triple;<a name="line.39"></a>
<span class="sourceLineNo">040</span><a name="line.40"></a>
<span class="sourceLineNo">041</span>/** <a name="line.41"></a>
<span class="sourceLineNo">042</span> * This module implements a distributed primal-decomposition-based gradient algorithm, for a coordinated adjustment of the congestion control of two types of demands (with different utility functions), and the fraction of each link capacity to grant to the traffic of each type, to maximize the network utility enforcing a fair allocation of the resources.<a name="line.42"></a>
<span class="sourceLineNo">043</span> *<a name="line.43"></a>
<span class="sourceLineNo">044</span> * Ths event processor is adapted to permit observing the algorithm performances under user-defined conditions, <a name="line.44"></a>
<span class="sourceLineNo">045</span> * including asynchronous distributed executions, where signaling can be affected by losses and/or delays, and/or measurement errors. <a name="line.45"></a>
<span class="sourceLineNo">046</span> * The time evolution of different metrics can be stored in output files, for later processing. <a name="line.46"></a>
<span class="sourceLineNo">047</span> * As an example, see the &lt;a href="../../../../../../graphGeneratorFiles/fig_sec11_3_congControlAndQoSLinkCap_primalDecomp.m"&gt;{@code fig_sec11_3_congControlAndQoSLinkCap_primalDecomp.m}&lt;/a&gt; MATLAB file used for generating the graph/s of the case study in the <a name="line.47"></a>
<span class="sourceLineNo">048</span> * &lt;a href="http://eu.wiley.com/WileyCDA/WileyTitle/productCd-1119013356.html"&gt;book&lt;/a&gt; using this algorithm.<a name="line.48"></a>
<span class="sourceLineNo">049</span> * <a name="line.49"></a>
<span class="sourceLineNo">050</span> * To simulate a network with this module, use the {@code Online_evGen_doNothing} generator.<a name="line.50"></a>
<span class="sourceLineNo">051</span> * <a name="line.51"></a>
<span class="sourceLineNo">052</span> * @net2plan.keywords Bandwidth assignment (BA), Capacity assignment (CA), Distributed algorithm, Primal decomposition <a name="line.52"></a>
<span class="sourceLineNo">053</span> * @net2plan.ocnbooksections Section 11.3<a name="line.53"></a>
<span class="sourceLineNo">054</span> * @net2plan.inputParameters <a name="line.54"></a>
<span class="sourceLineNo">055</span> * @author Pablo Pavon-Marino<a name="line.55"></a>
<span class="sourceLineNo">056</span> */<a name="line.56"></a>
<span class="sourceLineNo">057</span>public class Online_evProc_congControlAndQoSTwoClassesPrimalDecomp extends IEventProcessor <a name="line.57"></a>
<span class="sourceLineNo">058</span>{<a name="line.58"></a>
<span class="sourceLineNo">059</span>        private double PRECISIONFACTOR;<a name="line.59"></a>
<span class="sourceLineNo">060</span>        private Random rng;<a name="line.60"></a>
<span class="sourceLineNo">061</span><a name="line.61"></a>
<span class="sourceLineNo">062</span>        private int N,E,D1,D2,D;<a name="line.62"></a>
<span class="sourceLineNo">063</span>        private Map&lt;String,String&gt; algorithmParameters , net2PlanParameters;<a name="line.63"></a>
<span class="sourceLineNo">064</span>        <a name="line.64"></a>
<span class="sourceLineNo">065</span>        private static final int MAC_UPDATE_WAKEUPTOUPDATE = 202;<a name="line.65"></a>
<span class="sourceLineNo">066</span>        private static final int CC_SIGNALING_WAKEUPTOSENDMESSAGE = 400;<a name="line.66"></a>
<span class="sourceLineNo">067</span>        private static final int CC_SIGNALING_RECEIVEDMESSAGE = 401;<a name="line.67"></a>
<span class="sourceLineNo">068</span>        private static final int CC_UPDATE_WAKEUPTOUPDATE = 402;<a name="line.68"></a>
<span class="sourceLineNo">069</span><a name="line.69"></a>
<span class="sourceLineNo">070</span>        private InputParameter mac_update_isSynchronous = new InputParameter ("mac_update_isSynchronous", false , "true if all the distributed agents involved wake up synchronousely to update its state");<a name="line.70"></a>
<span class="sourceLineNo">071</span>        private InputParameter mac_update_averageInterUpdateTime = new InputParameter ("mac_update_averageInterUpdateTime", 50.0 , "Average time between two updates of an agent" , 0 , false , Double.MAX_VALUE , true);<a name="line.71"></a>
<span class="sourceLineNo">072</span>        private InputParameter mac_update_maxFluctuationInterUpdateTime = new InputParameter ("mac_update_maxFluctuationInterUpdateTime", 10.0 , "Max fluctuation in time in the update interval of an agent, in absolute time values. The update intervals are sampled from a uniform distribution within the given interval" , 0 , true , Double.MAX_VALUE , true);<a name="line.72"></a>
<span class="sourceLineNo">073</span>        private InputParameter mac_gradient_gammaStep = new InputParameter ("mac_gradient_gammaStep", 5.0 , "Gamma step in the gradient algorithm" , 0 , false , Double.MAX_VALUE , true);<a name="line.73"></a>
<span class="sourceLineNo">074</span>        private InputParameter mac_gradient_maxGradientCoordinateChange = new InputParameter ("mac_gradient_maxGradientCoordinateChange", 1000.0 , "Maximum change in an iteration of a gradient coordinate" , 0 , false , Double.MAX_VALUE , true);<a name="line.74"></a>
<span class="sourceLineNo">075</span><a name="line.75"></a>
<span class="sourceLineNo">076</span>        private InputParameter mac_simulation_maxNumberOfUpdateIntervals = new InputParameter ("mac_simulation_maxNumberOfUpdateIntervals", 600.0 , "Maximum number of update intervals in average per agent" , 0 , false , Double.MAX_VALUE , true);<a name="line.76"></a>
<span class="sourceLineNo">077</span>        private InputParameter simulation_randomSeed = new InputParameter ("simulation_randomSeed", (long) 1 , "Seed of the random number generator");<a name="line.77"></a>
<span class="sourceLineNo">078</span>        private InputParameter simulation_outFileNameRoot = new InputParameter ("simulation_outFileNameRoot", "crossLayerCongControlTwoQoSPrimalDecomp" , "Root of the file name to be used in the output files. If blank, no output");<a name="line.78"></a>
<span class="sourceLineNo">079</span>        <a name="line.79"></a>
<span class="sourceLineNo">080</span>        private InputParameter cc_signaling_isSynchronous = new InputParameter ("cc_signaling_isSynchronous", false , "true if all the distributed agents involved wake up synchronously to send the signaling messages");<a name="line.80"></a>
<span class="sourceLineNo">081</span>        private InputParameter cc_signaling_averageInterMessageTime = new InputParameter ("cc_signaling_averageInterMessageTime", 1.0 , "Average time between two signaling messages sent by an agent" , 0 , false , Double.MAX_VALUE , true);<a name="line.81"></a>
<span class="sourceLineNo">082</span>        private InputParameter cc_signaling_maxFluctuationInterMessageTime = new InputParameter ("cc_signaling_maxFluctuationInterMessageTime", 0.5 , "Max fluctuation in time between two signaling messages sent by an agent" , 0 , true , Double.MAX_VALUE , true);<a name="line.82"></a>
<span class="sourceLineNo">083</span>        private InputParameter cc_signaling_averageDelay = new InputParameter ("cc_signaling_averageDelay", 3.0 , "Average time between signaling message transmission by an agent and its reception by other or others" , 0 , true , Double.MAX_VALUE , true);<a name="line.83"></a>
<span class="sourceLineNo">084</span>        private InputParameter cc_signaling_maxFluctuationInDelay = new InputParameter ("cc_signaling_maxFluctuationInDelay", 0.5 , "Max fluctuation in time in the signaling delay, in absolute time values. The signaling delays are sampled from a uniform distribution within the given interval" , 0 , true , Double.MAX_VALUE , true);<a name="line.84"></a>
<span class="sourceLineNo">085</span>        private InputParameter cc_signaling_signalingLossProbability = new InputParameter ("cc_signaling_signalingLossProbability", 0.05 , "Probability that a signaling message transmitted is lost (not received by other or others involved agents)" , 0 , true , Double.MAX_VALUE , true);<a name="line.85"></a>
<span class="sourceLineNo">086</span><a name="line.86"></a>
<span class="sourceLineNo">087</span>        private InputParameter cc_update_isSynchronous = new InputParameter ("cc_update_isSynchronous", false , "true if all the distributed agents involved wake up synchronousely to update its state");<a name="line.87"></a>
<span class="sourceLineNo">088</span>        private InputParameter cc_update_averageInterUpdateTime = new InputParameter ("cc_update_averageInterUpdateTime", 1.0 , "Average time between two updates of an agent" , 0 , false , Double.MAX_VALUE , true);<a name="line.88"></a>
<span class="sourceLineNo">089</span>        private InputParameter cc_update_maxFluctuationInterUpdateTime = new InputParameter ("cc_update_maxFluctuationInterUpdateTime", 0.5 , "Max fluctuation in time in the update interval of an agent, in absolute time values. The update intervals are sampled from a uniform distribution within the given interval" , 0 , true , Double.MAX_VALUE , true);<a name="line.89"></a>
<span class="sourceLineNo">090</span><a name="line.90"></a>
<span class="sourceLineNo">091</span>        private InputParameter cc_gradient_gammaStep = new InputParameter ("cc_gradient_gammaStep", 0.001 , "Gamma step in the gradient algorithm" , 0 , false , Double.MAX_VALUE , true);<a name="line.91"></a>
<span class="sourceLineNo">092</span>        private InputParameter cc_gradient_maxGradientAbsoluteNoise = new InputParameter ("cc_gradient_maxGradientAbsoluteNoise", 0.0 , "Max value of the added noise to the gradient coordinate in absolute values" , 0 , true , Double.MAX_VALUE , true);<a name="line.92"></a>
<span class="sourceLineNo">093</span><a name="line.93"></a>
<span class="sourceLineNo">094</span>        private InputParameter cc_simulation_maxNumberOfUpdateIntervals = new InputParameter ("cc_simulation_maxNumberOfUpdateIntervals", 600.0 , "Maximum number of update intervals in average per agent" , 0 , false , Double.MAX_VALUE , true);<a name="line.94"></a>
<span class="sourceLineNo">095</span>        private InputParameter cc_control_minHd = new InputParameter ("cc_control_minHd", 0.1 , "Minimum traffic assigned to each demand" , 0 , true , Double.MAX_VALUE , true);<a name="line.95"></a>
<span class="sourceLineNo">096</span>        private InputParameter cc_control_maxHd = new InputParameter ("cc_control_maxHd", 1e6 , "Maximum traffic assigned to each demand" , 0 , true , Double.MAX_VALUE , true);<a name="line.96"></a>
<span class="sourceLineNo">097</span>        private InputParameter cc_control_initialiLinkPrices = new InputParameter ("cc_control_initialiLinkPrices", 1.0 , "Link prices in the algorithm initialization" , 0 , true , Double.MAX_VALUE , true);<a name="line.97"></a>
<span class="sourceLineNo">098</span><a name="line.98"></a>
<span class="sourceLineNo">099</span>        private InputParameter cc_control_fairnessFactor_1 = new InputParameter ("cc_control_fairnessFactor_1", 1.0 , "Fairness factor in utility function of congestion control for demands of class 1" , 0 , true , Double.MAX_VALUE , true);<a name="line.99"></a>
<span class="sourceLineNo">100</span>        private InputParameter cc_control_fairnessFactor_2 = new InputParameter ("cc_control_fairnessFactor_2", 1.0 , "Fairness factor in utility function of congestion control for demands of class 2" , 0 , true , Double.MAX_VALUE , true);<a name="line.100"></a>
<span class="sourceLineNo">101</span>        private InputParameter cc_control_weightFairness_1 = new InputParameter ("cc_control_weightFairness_1", 1.0 , "Weight factor in utility function demands type 1" , 0 , true , Double.MAX_VALUE , true);<a name="line.101"></a>
<span class="sourceLineNo">102</span>        private InputParameter cc_control_weightFairness_2 = new InputParameter ("cc_control_weightFairness_2", 2.0 , "Weight factor in utility function demands type 2" , 0 , true , Double.MAX_VALUE , true);<a name="line.102"></a>
<span class="sourceLineNo">103</span>        private InputParameter mac_minCapacity_1 = new InputParameter ("mac_minCapacity_1", 0.1 , "Minimum capacity in each link, allocated to traffic of type 1" , 0 , true , Double.MAX_VALUE , true);<a name="line.103"></a>
<span class="sourceLineNo">104</span>        private InputParameter mac_minCapacity_2 = new InputParameter ("mac_minCapacity_2", 0.1 , "Minimum capacity in each link, allocated to traffic of type 2" , 0 , true , Double.MAX_VALUE , true);<a name="line.104"></a>
<span class="sourceLineNo">105</span><a name="line.105"></a>
<span class="sourceLineNo">106</span>        private DoubleMatrix1D demandType;<a name="line.106"></a>
<span class="sourceLineNo">107</span>        private DoubleMatrix1D congControl_price1_e;<a name="line.107"></a>
<span class="sourceLineNo">108</span>        private DoubleMatrix1D congControl_price2_e;<a name="line.108"></a>
<span class="sourceLineNo">109</span>        private DoubleMatrix2D control_mostUpdatedLinkPriceKnownDemand_de;<a name="line.109"></a>
<span class="sourceLineNo">110</span>        private DoubleMatrix1D mac_u1; <a name="line.110"></a>
<span class="sourceLineNo">111</span>        private DoubleMatrix1D mac_u2; <a name="line.111"></a>
<span class="sourceLineNo">112</span>        <a name="line.112"></a>
<span class="sourceLineNo">113</span>        private TimeTrace traceOf_pi1_e;<a name="line.113"></a>
<span class="sourceLineNo">114</span>        private TimeTrace traceOf_pi2_e;<a name="line.114"></a>
<span class="sourceLineNo">115</span>        private TimeTrace traceOf_u1_e;<a name="line.115"></a>
<span class="sourceLineNo">116</span>        private TimeTrace traceOf_u2_e;<a name="line.116"></a>
<span class="sourceLineNo">117</span>        private TimeTrace traceOf_y1_e;<a name="line.117"></a>
<span class="sourceLineNo">118</span>        private TimeTrace traceOf_y2_e;<a name="line.118"></a>
<span class="sourceLineNo">119</span>        private TimeTrace traceOf_h_d1;<a name="line.119"></a>
<span class="sourceLineNo">120</span>        private TimeTrace traceOf_h_d2;<a name="line.120"></a>
<span class="sourceLineNo">121</span>        private TimeTrace traceOf_objFunction;<a name="line.121"></a>
<span class="sourceLineNo">122</span><a name="line.122"></a>
<span class="sourceLineNo">123</span>        private NetPlan currentNetPlan , copyInitialNetPlan;<a name="line.123"></a>
<span class="sourceLineNo">124</span>        <a name="line.124"></a>
<span class="sourceLineNo">125</span>        <a name="line.125"></a>
<span class="sourceLineNo">126</span>        @Override<a name="line.126"></a>
<span class="sourceLineNo">127</span>        public String getDescription()<a name="line.127"></a>
<span class="sourceLineNo">128</span>        {<a name="line.128"></a>
<span class="sourceLineNo">129</span>                return "This module implements a distributed primal-decomposition-based gradient algorithm, for a coordinated adjustment of the congestion control of two types of demands (with different utility functions), and the fraction of each link capacity to grant to the traffic of each type, to maximize the network utility enforcing a fair allocation of the resources.";<a name="line.129"></a>
<span class="sourceLineNo">130</span>        }<a name="line.130"></a>
<span class="sourceLineNo">131</span><a name="line.131"></a>
<span class="sourceLineNo">132</span>        @Override<a name="line.132"></a>
<span class="sourceLineNo">133</span>        public List&lt;Triple&lt;String, String, String&gt;&gt; getParameters()<a name="line.133"></a>
<span class="sourceLineNo">134</span>        {<a name="line.134"></a>
<span class="sourceLineNo">135</span>                /* Returns the parameter information for all the InputParameter objects defined in this object (uses Java reflection) */<a name="line.135"></a>
<span class="sourceLineNo">136</span>                return InputParameter.getInformationAllInputParameterFieldsOfObject(this);<a name="line.136"></a>
<span class="sourceLineNo">137</span>        }<a name="line.137"></a>
<span class="sourceLineNo">138</span><a name="line.138"></a>
<span class="sourceLineNo">139</span>        @Override<a name="line.139"></a>
<span class="sourceLineNo">140</span>        public void initialize(NetPlan currentNp, Map&lt;String, String&gt; algorithmParameters, Map&lt;String, String&gt; simulationParameters, Map&lt;String, String&gt; net2planParameters)<a name="line.140"></a>
<span class="sourceLineNo">141</span>        {<a name="line.141"></a>
<span class="sourceLineNo">142</span>                /* Initialize all InputParameter objects defined in this object (this uses Java reflection) */<a name="line.142"></a>
<span class="sourceLineNo">143</span>                InputParameter.initializeAllInputParameterFieldsOfObject(this, algorithmParameters);<a name="line.143"></a>
<span class="sourceLineNo">144</span><a name="line.144"></a>
<span class="sourceLineNo">145</span>                this.currentNetPlan = currentNp;<a name="line.145"></a>
<span class="sourceLineNo">146</span>                this.algorithmParameters = algorithmParameters;<a name="line.146"></a>
<span class="sourceLineNo">147</span>                this.net2PlanParameters = net2planParameters;<a name="line.147"></a>
<span class="sourceLineNo">148</span>                if (currentNetPlan.getNumberOfLayers() != 1) throw new Net2PlanException ("This algorithm works in single layer networks");<a name="line.148"></a>
<span class="sourceLineNo">149</span><a name="line.149"></a>
<span class="sourceLineNo">150</span>                /* INITIALIZE VARIABLES COMMON FOR BOTH LAYERS */<a name="line.150"></a>
<span class="sourceLineNo">151</span>                this.copyInitialNetPlan = currentNp.copy();<a name="line.151"></a>
<span class="sourceLineNo">152</span>                if (currentNetPlan.getVectorLinkCapacity().getMaxLocation() [0]&lt; mac_minCapacity_1.getDouble() + mac_minCapacity_2.getDouble()) throw new Net2PlanException ("Minimum link capacities for each class are too high for the available link capacities");<a name="line.152"></a>
<span class="sourceLineNo">153</span>                <a name="line.153"></a>
<span class="sourceLineNo">154</span>                this.PRECISIONFACTOR = Double.parseDouble(net2planParameters.get("precisionFactor"));<a name="line.154"></a>
<span class="sourceLineNo">155</span>                <a name="line.155"></a>
<span class="sourceLineNo">156</span>                /* READ INPUT PARAMETERS BOTH LAYERS */<a name="line.156"></a>
<span class="sourceLineNo">157</span>                this.rng = new Random (simulation_randomSeed.getLong());<a name="line.157"></a>
<span class="sourceLineNo">158</span>                this.N = this.currentNetPlan.getNumberOfNodes();<a name="line.158"></a>
<span class="sourceLineNo">159</span>                this.E = this.currentNetPlan.getNumberOfLinks();<a name="line.159"></a>
<span class="sourceLineNo">160</span>                if (E == 0) throw new Net2PlanException ("The input design should have links");<a name="line.160"></a>
<span class="sourceLineNo">161</span>                this.D1 = N*(N-1);<a name="line.161"></a>
<span class="sourceLineNo">162</span>                this.D2 = N*(N-1);<a name="line.162"></a>
<span class="sourceLineNo">163</span>                this.D = D1+D2;<a name="line.163"></a>
<span class="sourceLineNo">164</span>                <a name="line.164"></a>
<span class="sourceLineNo">165</span>                /* Initialize the demands and routers per demand */<a name="line.165"></a>
<span class="sourceLineNo">166</span>                this.currentNetPlan.removeAllDemands();<a name="line.166"></a>
<span class="sourceLineNo">167</span>                this.currentNetPlan.setRoutingType(RoutingType.SOURCE_ROUTING);<a name="line.167"></a>
<span class="sourceLineNo">168</span>                this.demandType = DoubleFactory1D.dense.make (D1+D2);<a name="line.168"></a>
<span class="sourceLineNo">169</span>                for (Node n1 : this.currentNetPlan.getNodes())<a name="line.169"></a>
<span class="sourceLineNo">170</span>                        for (Node n2 : this.currentNetPlan.getNodes())<a name="line.170"></a>
<span class="sourceLineNo">171</span>                                if (n1 != n2) <a name="line.171"></a>
<span class="sourceLineNo">172</span>                                { <a name="line.172"></a>
<span class="sourceLineNo">173</span>                                        final Demand d1 = this.currentNetPlan.addDemand(n1, n2, 0.0, null); d1.setAttribute("type" , "1"); demandType.set(d1.getIndex (), 1); <a name="line.173"></a>
<span class="sourceLineNo">174</span>                                        final Demand d2 = this.currentNetPlan.addDemand(n1, n2, 0.0, null); d1.setAttribute("type" , "2"); demandType.set(d2.getIndex (), 2); <a name="line.174"></a>
<span class="sourceLineNo">175</span>                                }<a name="line.175"></a>
<span class="sourceLineNo">176</span>                <a name="line.176"></a>
<span class="sourceLineNo">177</span>                /* Remove all routes, and create one with the shortest path in km for each demand */<a name="line.177"></a>
<span class="sourceLineNo">178</span>                currentNetPlan.removeAllUnicastRoutingInformation();<a name="line.178"></a>
<span class="sourceLineNo">179</span>                currentNetPlan.setRoutingType(RoutingType.SOURCE_ROUTING);<a name="line.179"></a>
<span class="sourceLineNo">180</span>                currentNetPlan.addRoutesFromCandidatePathList(currentNetPlan.getVectorLinkLengthInKm().toArray()  , "K" , "1");<a name="line.180"></a>
<span class="sourceLineNo">181</span>                for (Route r : currentNp.getRoutes ()) r.setCarriedTraffic(cc_control_minHd.getDouble() , cc_control_minHd.getDouble());<a name="line.181"></a>
<span class="sourceLineNo">182</span>                <a name="line.182"></a>
<span class="sourceLineNo">183</span>                /* INITIALIZE control information  */<a name="line.183"></a>
<span class="sourceLineNo">184</span>                this.congControl_price1_e = DoubleFactory1D.dense.make (E , cc_control_initialiLinkPrices.getDouble());<a name="line.184"></a>
<span class="sourceLineNo">185</span>                this.congControl_price2_e = DoubleFactory1D.dense.make (E , cc_control_initialiLinkPrices.getDouble());<a name="line.185"></a>
<span class="sourceLineNo">186</span>                <a name="line.186"></a>
<span class="sourceLineNo">187</span>                /* Initialize the information each demand knows of the prices of all the links */<a name="line.187"></a>
<span class="sourceLineNo">188</span>                this.control_mostUpdatedLinkPriceKnownDemand_de = DoubleFactory2D.dense.make (D,E,cc_control_initialiLinkPrices.getDouble());<a name="line.188"></a>
<span class="sourceLineNo">189</span><a name="line.189"></a>
<span class="sourceLineNo">190</span>                this.mac_u1 = DoubleFactory1D.dense.make (E , mac_minCapacity_1.getDouble());<a name="line.190"></a>
<span class="sourceLineNo">191</span>                this.mac_u2 = currentNetPlan.getVectorLinkCapacity().copy ().assign(DoubleFunctions.minus (mac_minCapacity_1.getDouble()));<a name="line.191"></a>
<span class="sourceLineNo">192</span>                <a name="line.192"></a>
<span class="sourceLineNo">193</span>                /* Each demand adjusts its rate to the pi_e */<a name="line.193"></a>
<span class="sourceLineNo">194</span>                /* Compute the traffic each demand injects, set it in net2plan, and tell routing layer there was an update in this */<a name="line.194"></a>
<span class="sourceLineNo">195</span>                for (Demand d : currentNetPlan.getDemands())<a name="line.195"></a>
<span class="sourceLineNo">196</span>                {<a name="line.196"></a>
<span class="sourceLineNo">197</span>                        final double h_d = this.computeHdFromPrices(d);<a name="line.197"></a>
<span class="sourceLineNo">198</span>                        d.setOfferedTraffic(h_d);<a name="line.198"></a>
<span class="sourceLineNo">199</span>                        d.getRoutes().iterator().next ().setCarriedTraffic(h_d , h_d);<a name="line.199"></a>
<span class="sourceLineNo">200</span>                }<a name="line.200"></a>
<span class="sourceLineNo">201</span>                <a name="line.201"></a>
<span class="sourceLineNo">202</span>                /* Initially all nodes receive a "wake up to transmit" event, aligned at time zero or y asynchr =&gt; randomly chosen */<a name="line.202"></a>
<span class="sourceLineNo">203</span>                for (Link e : currentNp.getLinks())<a name="line.203"></a>
<span class="sourceLineNo">204</span>                {<a name="line.204"></a>
<span class="sourceLineNo">205</span>                        final double updateTime = (mac_update_isSynchronous.getBoolean())? mac_update_averageInterUpdateTime.getDouble() : Math.max(0 , mac_update_averageInterUpdateTime.getDouble() + mac_update_maxFluctuationInterUpdateTime.getDouble() * (rng.nextDouble() - 0.5));<a name="line.205"></a>
<span class="sourceLineNo">206</span>                        this.scheduleEvent(new SimEvent (updateTime , SimEvent.DestinationModule.EVENT_PROCESSOR , MAC_UPDATE_WAKEUPTOUPDATE , e));<a name="line.206"></a>
<span class="sourceLineNo">207</span>                }<a name="line.207"></a>
<span class="sourceLineNo">208</span>                <a name="line.208"></a>
<span class="sourceLineNo">209</span>                /* INITIALIZATION CONGESTION CONTROL LAYER */<a name="line.209"></a>
<span class="sourceLineNo">210</span>                /* Initially all nodes receive a "wake up to transmit" event, aligned at time zero or y asynchr =&gt; randomly chosen */<a name="line.210"></a>
<span class="sourceLineNo">211</span>                for (Link e : currentNp.getLinks())<a name="line.211"></a>
<span class="sourceLineNo">212</span>                {<a name="line.212"></a>
<span class="sourceLineNo">213</span>                        final double signalingTime = (cc_signaling_isSynchronous.getBoolean())? cc_signaling_averageInterMessageTime.getDouble() : Math.max(0 , cc_signaling_averageInterMessageTime.getDouble() + cc_signaling_maxFluctuationInterMessageTime.getDouble() * (rng.nextDouble() - 0.5));<a name="line.213"></a>
<span class="sourceLineNo">214</span>                        this.scheduleEvent(new SimEvent (signalingTime , SimEvent.DestinationModule.EVENT_PROCESSOR , CC_SIGNALING_WAKEUPTOSENDMESSAGE , e));<a name="line.214"></a>
<span class="sourceLineNo">215</span>                }<a name="line.215"></a>
<span class="sourceLineNo">216</span>                for (Demand d : currentNetPlan.getDemands())<a name="line.216"></a>
<span class="sourceLineNo">217</span>                {<a name="line.217"></a>
<span class="sourceLineNo">218</span>                        final double updateTime = (cc_update_isSynchronous.getBoolean())? cc_update_averageInterUpdateTime.getDouble() : Math.max(0 , cc_update_averageInterUpdateTime.getDouble() + cc_update_maxFluctuationInterUpdateTime.getDouble() * (rng.nextDouble() - 0.5));<a name="line.218"></a>
<span class="sourceLineNo">219</span>                        this.scheduleEvent(new SimEvent (updateTime , SimEvent.DestinationModule.EVENT_PROCESSOR , CC_UPDATE_WAKEUPTOUPDATE , d));<a name="line.219"></a>
<span class="sourceLineNo">220</span>                }<a name="line.220"></a>
<span class="sourceLineNo">221</span>                <a name="line.221"></a>
<span class="sourceLineNo">222</span>                /* INITIALIZE STATISTIC VARIABLES FOR BOTH LAYERS */<a name="line.222"></a>
<span class="sourceLineNo">223</span>                this.traceOf_pi1_e = new TimeTrace  ();<a name="line.223"></a>
<span class="sourceLineNo">224</span>                this.traceOf_pi2_e = new TimeTrace  ();<a name="line.224"></a>
<span class="sourceLineNo">225</span>                this.traceOf_u1_e = new TimeTrace ();<a name="line.225"></a>
<span class="sourceLineNo">226</span>                this.traceOf_u2_e = new TimeTrace ();<a name="line.226"></a>
<span class="sourceLineNo">227</span>                this.traceOf_y1_e = new TimeTrace (); <a name="line.227"></a>
<span class="sourceLineNo">228</span>                this.traceOf_y2_e = new TimeTrace (); <a name="line.228"></a>
<span class="sourceLineNo">229</span>                this.traceOf_h_d1 = new TimeTrace (); <a name="line.229"></a>
<span class="sourceLineNo">230</span>                this.traceOf_h_d2 = new TimeTrace (); <a name="line.230"></a>
<span class="sourceLineNo">231</span>                this.traceOf_objFunction = new TimeTrace ();<a name="line.231"></a>
<span class="sourceLineNo">232</span><a name="line.232"></a>
<span class="sourceLineNo">233</span>                <a name="line.233"></a>
<span class="sourceLineNo">234</span>                this.traceOf_pi1_e.add(0.0, this.congControl_price1_e.copy ());<a name="line.234"></a>
<span class="sourceLineNo">235</span>                this.traceOf_pi2_e.add(0.0, this.congControl_price2_e.copy ());<a name="line.235"></a>
<span class="sourceLineNo">236</span>                this.traceOf_u1_e.add(0.0, this.mac_u1.copy ());<a name="line.236"></a>
<span class="sourceLineNo">237</span>                this.traceOf_u2_e.add(0.0, this.mac_u2.copy ());<a name="line.237"></a>
<span class="sourceLineNo">238</span>                final Triple&lt;Double,Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt;,Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt;&gt; objFunctionInfo = computeObjectiveFunctionFromNetPlan(this.currentNetPlan);<a name="line.238"></a>
<span class="sourceLineNo">239</span>                this.traceOf_objFunction.add(0.0 , objFunctionInfo.getFirst());<a name="line.239"></a>
<span class="sourceLineNo">240</span>                this.traceOf_h_d1.add(0.0, objFunctionInfo.getSecond().getFirst().copy ());<a name="line.240"></a>
<span class="sourceLineNo">241</span>                this.traceOf_h_d2.add(0.0, objFunctionInfo.getSecond().getSecond().copy ());<a name="line.241"></a>
<span class="sourceLineNo">242</span>                this.traceOf_y1_e.add(0.0, objFunctionInfo.getThird().getFirst().copy ());<a name="line.242"></a>
<span class="sourceLineNo">243</span>                this.traceOf_y2_e.add(0.0, objFunctionInfo.getThird().getSecond().copy ());<a name="line.243"></a>
<span class="sourceLineNo">244</span>        }<a name="line.244"></a>
<span class="sourceLineNo">245</span><a name="line.245"></a>
<span class="sourceLineNo">246</span>        @Override<a name="line.246"></a>
<span class="sourceLineNo">247</span>        public void processEvent(NetPlan currentNetPlan, SimEvent event)<a name="line.247"></a>
<span class="sourceLineNo">248</span>        {<a name="line.248"></a>
<span class="sourceLineNo">249</span>                final double t = event.getEventTime();<a name="line.249"></a>
<span class="sourceLineNo">250</span>                switch (event.getEventType())<a name="line.250"></a>
<span class="sourceLineNo">251</span>                {<a name="line.251"></a>
<span class="sourceLineNo">252</span>                case MAC_UPDATE_WAKEUPTOUPDATE: <a name="line.252"></a>
<span class="sourceLineNo">253</span>                {<a name="line.253"></a>
<span class="sourceLineNo">254</span>                        final Link eMe = (Link) event.getEventObject();<a name="line.254"></a>
<span class="sourceLineNo">255</span>                        final double current_u1 = mac_u1.get(eMe.getIndex ());<a name="line.255"></a>
<span class="sourceLineNo">256</span>                        final double current_u2 = mac_u2.get(eMe.getIndex ());<a name="line.256"></a>
<span class="sourceLineNo">257</span>                        final double gradient_1 = congControl_price1_e.get(eMe.getIndex ());<a name="line.257"></a>
<span class="sourceLineNo">258</span>                        final double gradient_2 = congControl_price2_e.get(eMe.getIndex ());<a name="line.258"></a>
<span class="sourceLineNo">259</span>                        final double nextBeforeProjection_u1 = current_u1 + this.mac_gradient_gammaStep.getDouble() * gradient_1;<a name="line.259"></a>
<span class="sourceLineNo">260</span>                        final double nextBeforeProjection_u2 = current_u2 + this.mac_gradient_gammaStep.getDouble() * gradient_2;<a name="line.260"></a>
<span class="sourceLineNo">261</span>                        DoubleMatrix1D initialSolution = DoubleFactory1D.dense.make (new double [] { current_u1 , current_u2 });<a name="line.261"></a>
<span class="sourceLineNo">262</span>                        DoubleMatrix1D inOut = DoubleFactory1D.dense.make (new double [] { nextBeforeProjection_u1 , nextBeforeProjection_u2 });<a name="line.262"></a>
<span class="sourceLineNo">263</span>                        DoubleMatrix1D uMin = DoubleFactory1D.dense.make (new double [] { mac_minCapacity_1.getDouble() , mac_minCapacity_2.getDouble() });<a name="line.263"></a>
<span class="sourceLineNo">264</span>                        GradientProjectionUtils.euclideanProjection_sumInequality (inOut , null , uMin , eMe.getCapacity());<a name="line.264"></a>
<span class="sourceLineNo">265</span>                        if (mac_gradient_maxGradientCoordinateChange.getDouble() &gt; 0)<a name="line.265"></a>
<span class="sourceLineNo">266</span>                                GradientProjectionUtils.scaleDown_maxAbsoluteCoordinateChange (initialSolution , inOut , null , mac_gradient_maxGradientCoordinateChange.getDouble());<a name="line.266"></a>
<span class="sourceLineNo">267</span><a name="line.267"></a>
<span class="sourceLineNo">268</span>                        this.mac_u1.set(eMe.getIndex (), inOut.get(0));<a name="line.268"></a>
<span class="sourceLineNo">269</span>                        this.mac_u2.set(eMe.getIndex (), inOut.get(1));<a name="line.269"></a>
<span class="sourceLineNo">270</span>                        if (mac_u1.get(eMe.getIndex ()) + mac_u2.get(eMe.getIndex ()) &gt; eMe.getCapacity() + PRECISIONFACTOR) throw new RuntimeException ("Bad");<a name="line.270"></a>
<span class="sourceLineNo">271</span>                        <a name="line.271"></a>
<span class="sourceLineNo">272</span>                        final double updateTime = mac_update_isSynchronous.getBoolean()? t + mac_update_averageInterUpdateTime.getDouble() : Math.max(t , t + mac_update_averageInterUpdateTime.getDouble() + mac_update_maxFluctuationInterUpdateTime.getDouble() * (rng.nextDouble() - 0.5));<a name="line.272"></a>
<span class="sourceLineNo">273</span>                        this.scheduleEvent(new SimEvent (updateTime , SimEvent.DestinationModule.EVENT_PROCESSOR , MAC_UPDATE_WAKEUPTOUPDATE,  eMe));<a name="line.273"></a>
<span class="sourceLineNo">274</span><a name="line.274"></a>
<span class="sourceLineNo">275</span>                        this.traceOf_u1_e.add(t, this.mac_u1.copy ());<a name="line.275"></a>
<span class="sourceLineNo">276</span>                        this.traceOf_u2_e.add(t, this.mac_u2.copy ());<a name="line.276"></a>
<span class="sourceLineNo">277</span><a name="line.277"></a>
<span class="sourceLineNo">278</span>                        if (t &gt; this.mac_simulation_maxNumberOfUpdateIntervals.getDouble() * this.mac_update_averageInterUpdateTime.getDouble()) { this.endSimulation (); }<a name="line.278"></a>
<span class="sourceLineNo">279</span><a name="line.279"></a>
<span class="sourceLineNo">280</span>                        break;<a name="line.280"></a>
<span class="sourceLineNo">281</span>                }<a name="line.281"></a>
<span class="sourceLineNo">282</span><a name="line.282"></a>
<span class="sourceLineNo">283</span>                case CC_SIGNALING_RECEIVEDMESSAGE: // A node receives from an out neighbor the q_nt for any destination<a name="line.283"></a>
<span class="sourceLineNo">284</span>                {<a name="line.284"></a>
<span class="sourceLineNo">285</span>                        final Pair&lt;Demand,Triple&lt;Link,Double,Double&gt;&gt; signalInfo = (Pair&lt;Demand,Triple&lt;Link,Double,Double&gt;&gt;) event.getEventObject();<a name="line.285"></a>
<span class="sourceLineNo">286</span>                        final Demand d = signalInfo.getFirst();<a name="line.286"></a>
<span class="sourceLineNo">287</span>                        final int type = (int) demandType.get(d.getIndex ());<a name="line.287"></a>
<span class="sourceLineNo">288</span>                        final Link e = signalInfo.getSecond().getFirst();<a name="line.288"></a>
<span class="sourceLineNo">289</span>                        final double pi1 = signalInfo.getSecond().getSecond();<a name="line.289"></a>
<span class="sourceLineNo">290</span>                        final double pi2 = signalInfo.getSecond().getThird();<a name="line.290"></a>
<span class="sourceLineNo">291</span>                        this.control_mostUpdatedLinkPriceKnownDemand_de.set(d.getIndex () , e.getIndex () , (type == 1)? pi1 : pi2);  <a name="line.291"></a>
<span class="sourceLineNo">292</span>                        break;<a name="line.292"></a>
<span class="sourceLineNo">293</span>                }<a name="line.293"></a>
<span class="sourceLineNo">294</span>                <a name="line.294"></a>
<span class="sourceLineNo">295</span>                case CC_SIGNALING_WAKEUPTOSENDMESSAGE: // A node broadcasts signaling info to its 1 hop neighbors<a name="line.295"></a>
<span class="sourceLineNo">296</span>                {<a name="line.296"></a>
<span class="sourceLineNo">297</span>                        final Link eMe = (Link) event.getEventObject();<a name="line.297"></a>
<span class="sourceLineNo">298</span><a name="line.298"></a>
<span class="sourceLineNo">299</span>                        /* Update the new price with the gradient approach */<a name="line.299"></a>
<span class="sourceLineNo">300</span>                        Triple&lt;Double,Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt;,Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt;&gt;  triple = computeObjectiveFunctionFromNetPlan (this.currentNetPlan);<a name="line.300"></a>
<span class="sourceLineNo">301</span>                        final double u1 = this.mac_u1.get(eMe.getIndex ());<a name="line.301"></a>
<span class="sourceLineNo">302</span>                        final double u2 = this.mac_u2.get(eMe.getIndex ());<a name="line.302"></a>
<span class="sourceLineNo">303</span>                        final double y1 = triple.getThird().getFirst().get(eMe.getIndex ());<a name="line.303"></a>
<span class="sourceLineNo">304</span>                        final double y2 = triple.getThird().getSecond().get(eMe.getIndex ());<a name="line.304"></a>
<span class="sourceLineNo">305</span>                        final double old_pie_1 = this.congControl_price1_e.get(eMe.getIndex ());<a name="line.305"></a>
<span class="sourceLineNo">306</span>                        final double old_pie_2 = this.congControl_price2_e.get(eMe.getIndex ());<a name="line.306"></a>
<span class="sourceLineNo">307</span>                        final double new_pie_1 = Math.max(0, old_pie_1 - this.cc_gradient_gammaStep.getDouble() * (u1 - y1) + 2*cc_gradient_maxGradientAbsoluteNoise.getDouble()*(rng.nextDouble()-0.5));<a name="line.307"></a>
<span class="sourceLineNo">308</span>                        final double new_pie_2 = Math.max(0, old_pie_2 - this.cc_gradient_gammaStep.getDouble() * (u2 - y2) + 2*cc_gradient_maxGradientAbsoluteNoise.getDouble()*(rng.nextDouble()-0.5));<a name="line.308"></a>
<span class="sourceLineNo">309</span>                        this.congControl_price1_e.set(eMe.getIndex (), new_pie_1);<a name="line.309"></a>
<span class="sourceLineNo">310</span>                        this.congControl_price2_e.set(eMe.getIndex (), new_pie_2);<a name="line.310"></a>
<span class="sourceLineNo">311</span>                        <a name="line.311"></a>
<span class="sourceLineNo">312</span>                        this.traceOf_pi1_e.add(t, this.congControl_price1_e.copy ());<a name="line.312"></a>
<span class="sourceLineNo">313</span>                        this.traceOf_pi2_e.add(t, this.congControl_price2_e.copy ());<a name="line.313"></a>
<span class="sourceLineNo">314</span><a name="line.314"></a>
<span class="sourceLineNo">315</span>                        /* Create the info I will signal */<a name="line.315"></a>
<span class="sourceLineNo">316</span>                        Triple&lt;Link,Double,Double&gt; infoToSignal = Triple.of(eMe ,  new_pie_1 , new_pie_2);<a name="line.316"></a>
<span class="sourceLineNo">317</span><a name="line.317"></a>
<span class="sourceLineNo">318</span>                        /* Send the events of the signaling information messages to all the nodes */<a name="line.318"></a>
<span class="sourceLineNo">319</span>                        for (Route route : eMe.getTraversingRoutes())<a name="line.319"></a>
<span class="sourceLineNo">320</span>                        {<a name="line.320"></a>
<span class="sourceLineNo">321</span>                                if (rng.nextDouble() &lt; this.cc_signaling_signalingLossProbability.getDouble()) continue; // the signaling may be lost =&gt; lost to all demands<a name="line.321"></a>
<span class="sourceLineNo">322</span>                                final Demand d = route.getDemand ();<a name="line.322"></a>
<span class="sourceLineNo">323</span>                                final double signalingReceptionTime = t + Math.max(0 , cc_signaling_averageDelay.getDouble() + cc_signaling_maxFluctuationInDelay.getDouble() * (rng.nextDouble() - 0.5));<a name="line.323"></a>
<span class="sourceLineNo">324</span>                                this.scheduleEvent(new SimEvent (signalingReceptionTime , SimEvent.DestinationModule.EVENT_PROCESSOR , CC_SIGNALING_RECEIVEDMESSAGE , Pair.of(d , infoToSignal)));<a name="line.324"></a>
<span class="sourceLineNo">325</span>                        }<a name="line.325"></a>
<span class="sourceLineNo">326</span>                        <a name="line.326"></a>
<span class="sourceLineNo">327</span>                        /* Re-schedule when to wake up again */<a name="line.327"></a>
<span class="sourceLineNo">328</span>                        final double signalingTime = cc_signaling_isSynchronous.getBoolean()? t + cc_signaling_averageInterMessageTime.getDouble() : Math.max(t , t + cc_signaling_averageInterMessageTime.getDouble() + cc_signaling_maxFluctuationInterMessageTime.getDouble() * (rng.nextDouble() - 0.5));<a name="line.328"></a>
<span class="sourceLineNo">329</span>                        this.scheduleEvent(new SimEvent (signalingTime , SimEvent.DestinationModule.EVENT_PROCESSOR , CC_SIGNALING_WAKEUPTOSENDMESSAGE , eMe));<a name="line.329"></a>
<span class="sourceLineNo">330</span>                        break;<a name="line.330"></a>
<span class="sourceLineNo">331</span>                }<a name="line.331"></a>
<span class="sourceLineNo">332</span><a name="line.332"></a>
<span class="sourceLineNo">333</span>                case CC_UPDATE_WAKEUPTOUPDATE: <a name="line.333"></a>
<span class="sourceLineNo">334</span>                {<a name="line.334"></a>
<span class="sourceLineNo">335</span>                        final Demand dMe = (Demand) event.getEventObject();<a name="line.335"></a>
<span class="sourceLineNo">336</span>                        final double new_hd = computeHdFromPrices (dMe);<a name="line.336"></a>
<span class="sourceLineNo">337</span>                        <a name="line.337"></a>
<span class="sourceLineNo">338</span>                        dMe.setOfferedTraffic(new_hd);<a name="line.338"></a>
<span class="sourceLineNo">339</span>                        dMe.getRoutes ().iterator().next().setCarriedTraffic(new_hd , new_hd);<a name="line.339"></a>
<span class="sourceLineNo">340</span>                        <a name="line.340"></a>
<span class="sourceLineNo">341</span>                        final Triple&lt;Double,Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt;,Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt;&gt; objFunctionInfo = computeObjectiveFunctionFromNetPlan(this.currentNetPlan);<a name="line.341"></a>
<span class="sourceLineNo">342</span>                        this.traceOf_objFunction.add(t , objFunctionInfo.getFirst());<a name="line.342"></a>
<span class="sourceLineNo">343</span>                        this.traceOf_h_d1.add(t, objFunctionInfo.getSecond().getFirst().copy ());<a name="line.343"></a>
<span class="sourceLineNo">344</span>                        this.traceOf_h_d2.add(t, objFunctionInfo.getSecond().getSecond().copy ());<a name="line.344"></a>
<span class="sourceLineNo">345</span>                        this.traceOf_y1_e.add(t, objFunctionInfo.getThird().getFirst().copy ());<a name="line.345"></a>
<span class="sourceLineNo">346</span>                        this.traceOf_y2_e.add(t, objFunctionInfo.getThird().getSecond().copy ());<a name="line.346"></a>
<span class="sourceLineNo">347</span><a name="line.347"></a>
<span class="sourceLineNo">348</span>                        final double updateTime = cc_update_isSynchronous.getBoolean()? t + cc_update_averageInterUpdateTime.getDouble() : Math.max(t , t + cc_update_averageInterUpdateTime.getDouble() + cc_update_maxFluctuationInterUpdateTime.getDouble() * (rng.nextDouble() - 0.5));<a name="line.348"></a>
<span class="sourceLineNo">349</span>                        this.scheduleEvent(new SimEvent (updateTime , SimEvent.DestinationModule.EVENT_PROCESSOR , CC_UPDATE_WAKEUPTOUPDATE,  dMe));<a name="line.349"></a>
<span class="sourceLineNo">350</span><a name="line.350"></a>
<span class="sourceLineNo">351</span>                        if (t &gt; this.cc_simulation_maxNumberOfUpdateIntervals.getDouble() * this.cc_update_averageInterUpdateTime.getDouble()) { this.endSimulation (); }<a name="line.351"></a>
<span class="sourceLineNo">352</span><a name="line.352"></a>
<span class="sourceLineNo">353</span>                        break;<a name="line.353"></a>
<span class="sourceLineNo">354</span>                }<a name="line.354"></a>
<span class="sourceLineNo">355</span>                <a name="line.355"></a>
<span class="sourceLineNo">356</span>                <a name="line.356"></a>
<span class="sourceLineNo">357</span>                default: throw new RuntimeException ("Unexpected received event");<a name="line.357"></a>
<span class="sourceLineNo">358</span>                }<a name="line.358"></a>
<span class="sourceLineNo">359</span>                <a name="line.359"></a>
<span class="sourceLineNo">360</span>                <a name="line.360"></a>
<span class="sourceLineNo">361</span>        }<a name="line.361"></a>
<span class="sourceLineNo">362</span><a name="line.362"></a>
<span class="sourceLineNo">363</span>        public String finish (StringBuilder st , double simTime)<a name="line.363"></a>
<span class="sourceLineNo">364</span>        {<a name="line.364"></a>
<span class="sourceLineNo">365</span>                if (simulation_outFileNameRoot.getString().equals("")) return null;<a name="line.365"></a>
<span class="sourceLineNo">366</span>                traceOf_h_d1.printToFile(new File (simulation_outFileNameRoot.getString() + "_hd1.txt"));<a name="line.366"></a>
<span class="sourceLineNo">367</span>                traceOf_h_d2.printToFile(new File (simulation_outFileNameRoot.getString() + "_hd2.txt"));<a name="line.367"></a>
<span class="sourceLineNo">368</span>                traceOf_u1_e.printToFile(new File (simulation_outFileNameRoot.getString() + "_ue1.txt"));<a name="line.368"></a>
<span class="sourceLineNo">369</span>                traceOf_u2_e.printToFile(new File (simulation_outFileNameRoot.getString() + "_ue2.txt"));<a name="line.369"></a>
<span class="sourceLineNo">370</span>                traceOf_objFunction.printToFile(new File (simulation_outFileNameRoot.getString() + "_objFunc.txt"));<a name="line.370"></a>
<span class="sourceLineNo">371</span><a name="line.371"></a>
<span class="sourceLineNo">372</span>                Map&lt;String,String&gt; param = new HashMap&lt;String,String&gt; (algorithmParameters);<a name="line.372"></a>
<span class="sourceLineNo">373</span>                param.put("solverName", "ipopt");<a name="line.373"></a>
<span class="sourceLineNo">374</span>                param.put("solverLibraryName", "");<a name="line.374"></a>
<span class="sourceLineNo">375</span>                param.put("maxSolverTimeInSeconds", "-1");<a name="line.375"></a>
<span class="sourceLineNo">376</span>                new Offline_cba_congControLinkBwSplitTwolQoS().executeAlgorithm(copyInitialNetPlan , param , this.net2PlanParameters);<a name="line.376"></a>
<span class="sourceLineNo">377</span>                DoubleMatrix1D jom_hd1 = DoubleFactory1D.dense.make (D1);<a name="line.377"></a>
<span class="sourceLineNo">378</span>                DoubleMatrix1D jom_hd2 = DoubleFactory1D.dense.make (D2);<a name="line.378"></a>
<span class="sourceLineNo">379</span>                DoubleMatrix1D jom_ue1 = DoubleFactory1D.dense.make (E);<a name="line.379"></a>
<span class="sourceLineNo">380</span>                DoubleMatrix1D jom_ue2 = DoubleFactory1D.dense.make (E);<a name="line.380"></a>
<span class="sourceLineNo">381</span>                int counter_1 = 0; int counter_2 = 0;<a name="line.381"></a>
<span class="sourceLineNo">382</span>                for (Demand d : copyInitialNetPlan.getDemands ())<a name="line.382"></a>
<span class="sourceLineNo">383</span>                        if (d.getAttribute("type").equals ("1")) jom_hd1.set (counter_1 ++ , d.getOfferedTraffic()); else jom_hd2.set (counter_2 ++ , d.getOfferedTraffic());<a name="line.383"></a>
<span class="sourceLineNo">384</span>                for (Link e : copyInitialNetPlan.getLinks ()) { jom_ue1.set (e.getIndex () , Double.parseDouble (e.getAttribute("u_1"))); jom_ue2.set (e.getIndex () , Double.parseDouble (e.getAttribute("u_2"))); }<a name="line.384"></a>
<span class="sourceLineNo">385</span>                final double jomObjcFunc = Double.parseDouble (copyInitialNetPlan.getAttribute("netUtility"));<a name="line.385"></a>
<span class="sourceLineNo">386</span>                TimeTrace.printToFile(new File (simulation_outFileNameRoot.getString() + "_jom_hd1.txt"), jom_hd1);<a name="line.386"></a>
<span class="sourceLineNo">387</span>                TimeTrace.printToFile(new File (simulation_outFileNameRoot.getString() + "_jom_hd2.txt"), jom_hd2);<a name="line.387"></a>
<span class="sourceLineNo">388</span>                TimeTrace.printToFile(new File (simulation_outFileNameRoot.getString() + "_jom_ue1.txt"), jom_ue1);<a name="line.388"></a>
<span class="sourceLineNo">389</span>                TimeTrace.printToFile(new File (simulation_outFileNameRoot.getString() + "_jom_ue2.txt"), jom_ue2);<a name="line.389"></a>
<span class="sourceLineNo">390</span>                TimeTrace.printToFile(new File (simulation_outFileNameRoot.getString() + "_jom_objFunc.txt"), jomObjcFunc);<a name="line.390"></a>
<span class="sourceLineNo">391</span>                return null;<a name="line.391"></a>
<span class="sourceLineNo">392</span>        }<a name="line.392"></a>
<span class="sourceLineNo">393</span>        <a name="line.393"></a>
<span class="sourceLineNo">394</span><a name="line.394"></a>
<span class="sourceLineNo">395</span>        private Triple&lt;Double,Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt;,Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt;&gt;  computeObjectiveFunctionFromNetPlan (NetPlan np)<a name="line.395"></a>
<span class="sourceLineNo">396</span>        {<a name="line.396"></a>
<span class="sourceLineNo">397</span>                DoubleMatrix1D y1 = DoubleFactory1D.dense.make (E);<a name="line.397"></a>
<span class="sourceLineNo">398</span>                DoubleMatrix1D y2 = DoubleFactory1D.dense.make (E);<a name="line.398"></a>
<span class="sourceLineNo">399</span>                DoubleMatrix1D h1 = DoubleFactory1D.dense.make (D1);<a name="line.399"></a>
<span class="sourceLineNo">400</span>                DoubleMatrix1D h2 = DoubleFactory1D.dense.make (D2);<a name="line.400"></a>
<span class="sourceLineNo">401</span>                double obj = 0;<a name="line.401"></a>
<span class="sourceLineNo">402</span>                int counter_d1 = 0; int counter_d2 = 0;<a name="line.402"></a>
<span class="sourceLineNo">403</span>                for (Demand d : np.getDemands())<a name="line.403"></a>
<span class="sourceLineNo">404</span>                {<a name="line.404"></a>
<span class="sourceLineNo">405</span>                        final double h_d = d.getCarriedTraffic();<a name="line.405"></a>
<span class="sourceLineNo">406</span>                        final int type = (int) this.demandType.get(d.getIndex());<a name="line.406"></a>
<span class="sourceLineNo">407</span>                        final List&lt;Link&gt; seqLinks = d.getRoutes ().iterator().next().getSeqLinksRealPath();<a name="line.407"></a>
<span class="sourceLineNo">408</span>                        for (Link e : seqLinks)<a name="line.408"></a>
<span class="sourceLineNo">409</span>                        {<a name="line.409"></a>
<span class="sourceLineNo">410</span>                                final int index_e = e.getIndex ();<a name="line.410"></a>
<span class="sourceLineNo">411</span>                                if (type == 1) y1.set(index_e , y1.get(index_e) + h_d); else y2.set(index_e , y2.get(index_e) + h_d); <a name="line.411"></a>
<span class="sourceLineNo">412</span>                        }<a name="line.412"></a>
<span class="sourceLineNo">413</span>                        if (type == 1) <a name="line.413"></a>
<span class="sourceLineNo">414</span>                        { <a name="line.414"></a>
<span class="sourceLineNo">415</span>                                h1.set (counter_d1 , h_d);<a name="line.415"></a>
<span class="sourceLineNo">416</span>                                obj += (this.cc_control_fairnessFactor_1.getDouble() == 1)? this.cc_control_weightFairness_1.getDouble() * Math.log(h_d) : this.cc_control_weightFairness_1.getDouble() *  Math.pow(h_d, 1-this.cc_control_fairnessFactor_1.getDouble()) / (1-this.cc_control_fairnessFactor_1.getDouble());<a name="line.416"></a>
<span class="sourceLineNo">417</span>                                counter_d1 ++; <a name="line.417"></a>
<span class="sourceLineNo">418</span>                        } else <a name="line.418"></a>
<span class="sourceLineNo">419</span>                        { <a name="line.419"></a>
<span class="sourceLineNo">420</span>                                h2.set (counter_d2 , h_d);<a name="line.420"></a>
<span class="sourceLineNo">421</span>                                obj += (this.cc_control_fairnessFactor_2.getDouble() == 1)? this.cc_control_weightFairness_2.getDouble() * Math.log(h_d) : this.cc_control_weightFairness_2.getDouble() *  Math.pow(h_d, 1-this.cc_control_fairnessFactor_2.getDouble()) / (1-this.cc_control_fairnessFactor_2.getDouble());<a name="line.421"></a>
<span class="sourceLineNo">422</span>                                counter_d2 ++; <a name="line.422"></a>
<span class="sourceLineNo">423</span>                        } <a name="line.423"></a>
<span class="sourceLineNo">424</span>                }<a name="line.424"></a>
<span class="sourceLineNo">425</span>                if ((counter_d1 != D1) || (counter_d2 != D2)) throw new RuntimeException ("Bad");<a name="line.425"></a>
<span class="sourceLineNo">426</span>                return Triple.of(obj, Pair.of(h1, h2),Pair.of(y1, y2));<a name="line.426"></a>
<span class="sourceLineNo">427</span>        }<a name="line.427"></a>
<span class="sourceLineNo">428</span><a name="line.428"></a>
<span class="sourceLineNo">429</span><a name="line.429"></a>
<span class="sourceLineNo">430</span>        private double computeHdFromPrices (Demand d)<a name="line.430"></a>
<span class="sourceLineNo">431</span>        {<a name="line.431"></a>
<span class="sourceLineNo">432</span>                DoubleMatrix1D infoIKnow_price_e = this.control_mostUpdatedLinkPriceKnownDemand_de.viewRow(d.getIndex ());<a name="line.432"></a>
<span class="sourceLineNo">433</span><a name="line.433"></a>
<span class="sourceLineNo">434</span>                /* compute the demand price as weighted sum in the routes of route prices  */<a name="line.434"></a>
<span class="sourceLineNo">435</span>                double demandWeightedSumLinkPrices = 0;<a name="line.435"></a>
<span class="sourceLineNo">436</span>                double demandCarriedTraffic = 0; <a name="line.436"></a>
<span class="sourceLineNo">437</span>                for (Route r : d.getRoutes ())<a name="line.437"></a>
<span class="sourceLineNo">438</span>                {<a name="line.438"></a>
<span class="sourceLineNo">439</span>                        final double h_r = r.getCarriedTraffic();<a name="line.439"></a>
<span class="sourceLineNo">440</span>                        demandCarriedTraffic += h_r;<a name="line.440"></a>
<span class="sourceLineNo">441</span>                        for (Link e : r.getSeqLinksRealPath())<a name="line.441"></a>
<span class="sourceLineNo">442</span>                                demandWeightedSumLinkPrices += h_r * infoIKnow_price_e.get(e.getIndex ());<a name="line.442"></a>
<span class="sourceLineNo">443</span>                }<a name="line.443"></a>
<span class="sourceLineNo">444</span>                //if (Math.abs(demandCarriedTraffic - this.currentNetPlan.getDemandCarriedTraffic(dIdMe)) &gt; 1E-3) throw new RuntimeException ("Not all the traffic is carried");<a name="line.444"></a>
<span class="sourceLineNo">445</span>                demandWeightedSumLinkPrices /= demandCarriedTraffic;<a name="line.445"></a>
<span class="sourceLineNo">446</span><a name="line.446"></a>
<span class="sourceLineNo">447</span>                /* compute the new h_d */<a name="line.447"></a>
<span class="sourceLineNo">448</span>                final double alpha = (demandType.get(d.getIndex ()) == 1)? this.cc_control_fairnessFactor_1.getDouble() : this.cc_control_fairnessFactor_2.getDouble();<a name="line.448"></a>
<span class="sourceLineNo">449</span>                final double weight = (demandType.get(d.getIndex ()) == 1)? this.cc_control_weightFairness_1.getDouble() : this.cc_control_weightFairness_2.getDouble();<a name="line.449"></a>
<span class="sourceLineNo">450</span>                final double new_hd = Math.max(this.cc_control_minHd.getDouble() , Math.min(this.cc_control_maxHd.getDouble(), Math.pow(demandWeightedSumLinkPrices/weight, -1/alpha)));<a name="line.450"></a>
<span class="sourceLineNo">451</span><a name="line.451"></a>
<span class="sourceLineNo">452</span>                return new_hd;<a name="line.452"></a>
<span class="sourceLineNo">453</span>        }<a name="line.453"></a>
<span class="sourceLineNo">454</span><a name="line.454"></a>
<span class="sourceLineNo">455</span>}<a name="line.455"></a>




























































</pre>
</div>
</body>
</html>
