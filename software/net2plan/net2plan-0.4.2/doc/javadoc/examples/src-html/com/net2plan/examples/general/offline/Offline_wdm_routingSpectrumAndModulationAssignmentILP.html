<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="es">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/*******************************************************************************<a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2015 Pablo Pavon Mariño.<a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved. This program and the accompanying materials<a name="line.3"></a>
<span class="sourceLineNo">004</span> * are made available under the terms of the GNU Lesser Public License v2.1<a name="line.4"></a>
<span class="sourceLineNo">005</span> * which accompanies this distribution, and is available at<a name="line.5"></a>
<span class="sourceLineNo">006</span> * http://www.gnu.org/licenses/lgpl.html<a name="line.6"></a>
<span class="sourceLineNo">007</span> * <a name="line.7"></a>
<span class="sourceLineNo">008</span> * Contributors:<a name="line.8"></a>
<span class="sourceLineNo">009</span> *     Pablo Pavon Mariño - initial API and implementation<a name="line.9"></a>
<span class="sourceLineNo">010</span> ******************************************************************************/<a name="line.10"></a>
<span class="sourceLineNo">011</span>package com.net2plan.examples.general.offline;<a name="line.11"></a>
<span class="sourceLineNo">012</span><a name="line.12"></a>
<span class="sourceLineNo">013</span><a name="line.13"></a>
<span class="sourceLineNo">014</span>import java.util.ArrayList;<a name="line.14"></a>
<span class="sourceLineNo">015</span>import java.util.Collection;<a name="line.15"></a>
<span class="sourceLineNo">016</span>import java.util.HashMap;<a name="line.16"></a>
<span class="sourceLineNo">017</span>import java.util.List;<a name="line.17"></a>
<span class="sourceLineNo">018</span>import java.util.Map;<a name="line.18"></a>
<span class="sourceLineNo">019</span><a name="line.19"></a>
<span class="sourceLineNo">020</span>import com.jom.DoubleMatrixND;<a name="line.20"></a>
<span class="sourceLineNo">021</span>import com.jom.OptimizationProblem;<a name="line.21"></a>
<span class="sourceLineNo">022</span>import com.net2plan.interfaces.networkDesign.Demand;<a name="line.22"></a>
<span class="sourceLineNo">023</span>import com.net2plan.interfaces.networkDesign.IAlgorithm;<a name="line.23"></a>
<span class="sourceLineNo">024</span>import com.net2plan.interfaces.networkDesign.Link;<a name="line.24"></a>
<span class="sourceLineNo">025</span>import com.net2plan.interfaces.networkDesign.Net2PlanException;<a name="line.25"></a>
<span class="sourceLineNo">026</span>import com.net2plan.interfaces.networkDesign.NetPlan;<a name="line.26"></a>
<span class="sourceLineNo">027</span>import com.net2plan.interfaces.networkDesign.NetworkLayer;<a name="line.27"></a>
<span class="sourceLineNo">028</span>import com.net2plan.interfaces.networkDesign.ProtectionSegment;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import com.net2plan.interfaces.networkDesign.Route;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import com.net2plan.interfaces.networkDesign.SharedRiskGroup;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import com.net2plan.libraries.WDMUtils;<a name="line.31"></a>
<span class="sourceLineNo">032</span>import com.net2plan.utils.Constants.RoutingType;<a name="line.32"></a>
<span class="sourceLineNo">033</span>import com.net2plan.utils.InputParameter;<a name="line.33"></a>
<span class="sourceLineNo">034</span>import com.net2plan.utils.IntUtils;<a name="line.34"></a>
<span class="sourceLineNo">035</span>import com.net2plan.utils.Pair;<a name="line.35"></a>
<span class="sourceLineNo">036</span>import com.net2plan.utils.Triple;<a name="line.36"></a>
<span class="sourceLineNo">037</span><a name="line.37"></a>
<span class="sourceLineNo">038</span>import cern.colt.list.tdouble.DoubleArrayList;<a name="line.38"></a>
<span class="sourceLineNo">039</span>import cern.colt.list.tint.IntArrayList;<a name="line.39"></a>
<span class="sourceLineNo">040</span>import cern.colt.matrix.tdouble.DoubleFactory2D;<a name="line.40"></a>
<span class="sourceLineNo">041</span>import cern.colt.matrix.tdouble.DoubleMatrix2D;<a name="line.41"></a>
<span class="sourceLineNo">042</span><a name="line.42"></a>
<span class="sourceLineNo">043</span>/**<a name="line.43"></a>
<span class="sourceLineNo">044</span> * Algorithm based on an ILP solving the Routing, Spectrum, Modulation Assignment (RSMA) problem with regenerator placement, in flexi (elastic) or fixed grid optical WDM networks, with or without fault tolerance, latency and/or lightpath bidirectionality requisites.<a name="line.44"></a>
<span class="sourceLineNo">045</span> * <a name="line.45"></a>
<span class="sourceLineNo">046</span> * &lt;p&gt;The input design is assumed to have a WDM layer compatible with {@link com.net2plan.libraries.WDMUtils WDMUtils} Net2Plan <a name="line.46"></a>
<span class="sourceLineNo">047</span> * library usual assumptions:&lt;/p&gt;<a name="line.47"></a>
<span class="sourceLineNo">048</span> * &lt;ul&gt;<a name="line.48"></a>
<span class="sourceLineNo">049</span> * &lt;li&gt;Each network node is assumed to be an Optical Add/Drop Multiplexer WDM node&lt;/li&gt;<a name="line.49"></a>
<span class="sourceLineNo">050</span> * &lt;li&gt;Each network link at WDM layer is assumed to be an optical fiber.&lt;/li&gt;<a name="line.50"></a>
<span class="sourceLineNo">051</span> * &lt;li&gt;The spectrum in the fibers is assumed to be composed of a number of frequency slots. <a name="line.51"></a>
<span class="sourceLineNo">052</span> * In fixed-grid network, each frequency slot would correspond to a wavelength channel. <a name="line.52"></a>
<span class="sourceLineNo">053</span> * In flexi-grid networks, it is just a frequency slot, and lightpaths can occupy more than one. In any case, <a name="line.53"></a>
<span class="sourceLineNo">054</span> * two lightpaths that use overlapping frequency slots cannot traverse the same fiber, since their signals would mix.&lt;/li&gt;<a name="line.54"></a>
<span class="sourceLineNo">055</span> * &lt;li&gt;Each traffic demand is a need to transmit an amount of Gbps between two nodes. <a name="line.55"></a>
<span class="sourceLineNo">056</span> * A demand traffic can be carried using one or more lightpaths.&lt;/li&gt;<a name="line.56"></a>
<span class="sourceLineNo">057</span> * &lt;/ul&gt;<a name="line.57"></a>
<span class="sourceLineNo">058</span> * <a name="line.58"></a>
<span class="sourceLineNo">059</span> * &lt;p&gt;Each lightpath produced by the design is returned as a {@code Route} object. Protection lightpaths in 1+1 case <a name="line.59"></a>
<span class="sourceLineNo">060</span> * are returned as ProtectionSegment objects attached to the {@code Route}. They represent a set of reserved frequency slots in <a name="line.60"></a>
<span class="sourceLineNo">061</span> * a set of fibers, to be used to protect other lightpaths.&lt;/p&gt;<a name="line.61"></a>
<span class="sourceLineNo">062</span> * <a name="line.62"></a>
<span class="sourceLineNo">063</span> * &lt;p&gt;Each lightpath starts and ends in a transponder. The user is able to define a set of available transpoder types, so <a name="line.63"></a>
<span class="sourceLineNo">064</span> * the design can create lightpaths using any combination of them. The information user-defined per transponder is:&lt;/p&gt;<a name="line.64"></a>
<span class="sourceLineNo">065</span> * &lt;ul&gt;<a name="line.65"></a>
<span class="sourceLineNo">066</span> * &lt;li&gt;Line rate in Gbps (typically 10, 40, 100 in fixed-grid cases, and other multiples in flexi-grid networks).&lt;/li&gt; <a name="line.66"></a>
<span class="sourceLineNo">067</span> * &lt;li&gt;Cost&lt;/li&gt; <a name="line.67"></a>
<span class="sourceLineNo">068</span> * &lt;li&gt;Number of frequency slots occupied (for a given line rate, this depends on the modulation the transponder uses)&lt;/li&gt; <a name="line.68"></a>
<span class="sourceLineNo">069</span> * &lt;li&gt;Optical reach in km: Maximum allowed length in km of the lightpaths with this transponder. <a name="line.69"></a>
<span class="sourceLineNo">070</span> * Higher distances can be reached using signal regenerators.&lt;/li&gt; <a name="line.70"></a>
<span class="sourceLineNo">071</span> * &lt;li&gt;Cost of a regenerator for this transponder. Regenerators can be placed at intermdiate nodes of the lightpath route, <a name="line.71"></a>
<span class="sourceLineNo">072</span> * regenerate its optical signal, and then permit extending its reach. We consider that regenerators cannot change the <a name="line.72"></a>
<span class="sourceLineNo">073</span> * frequency slots occupied by the lightpath (that is, they are not capable of wavelength conversion)&lt;/li&gt; <a name="line.73"></a>
<span class="sourceLineNo">074</span> * &lt;/ul&gt;<a name="line.74"></a>
<span class="sourceLineNo">075</span> * &lt;p&gt; In addition, the user can force the design to use bidirectional transponders (the usual case). This means that (i) in <a name="line.75"></a>
<span class="sourceLineNo">076</span> * each transponder we have the transmission and reception side inseparable (so you cannot e.g. buy just the transmission side), <a name="line.76"></a>
<span class="sourceLineNo">077</span> * and (ii) a couple of transponders (of course of the same type) being the end points of a lightpath from node 1 to node 2, <a name="line.77"></a>
<span class="sourceLineNo">078</span> * also are used for a lightpath from node 2 to node 1, (iii) note however that the two opposite lightpaths can follow arbitrary routes <a name="line.78"></a>
<span class="sourceLineNo">079</span> * (they do not have to traverse the reversed sequence of nodes). This bidirectionality constraint is a common requirement if <a name="line.79"></a>
<span class="sourceLineNo">080</span> * the lightpath will be used for carrying IP traffic, since IP assumes that its links (the lightpaths) are bidirectional pipes.&lt;/p&gt;<a name="line.80"></a>
<span class="sourceLineNo">081</span> * <a name="line.81"></a>
<span class="sourceLineNo">082</span> * &lt;p&gt;We assume that all the fibers use the same wavelength grid, composed of a user-defined number of frequency slots. <a name="line.82"></a>
<span class="sourceLineNo">083</span> * The user can also select a limit in the maximum propagation delay of a lightpath. &lt;/p&gt;<a name="line.83"></a>
<span class="sourceLineNo">084</span> * &lt;p&gt;The output design consists in the set of lightpaths to establish, in the 1+1 case also with a 1+1 lightpath each. <a name="line.84"></a>
<span class="sourceLineNo">085</span> * Each lightpath is characterized by the transponder type used (which sets its line rate and number of occupied slots in the <a name="line.85"></a>
<span class="sourceLineNo">086</span> * traversed fibers), the particular set of contiguous frequency slots occupied, and the set of signal regeneration points (if any). <a name="line.86"></a>
<span class="sourceLineNo">087</span> * This information is stored in the {@code Route} and {@code ProtectionSegment} object using the regular methods in WDMUTils, <a name="line.87"></a>
<span class="sourceLineNo">088</span> * and can be retrieved in the same form (e.g. by a report showing the WDM network information). <a name="line.88"></a>
<span class="sourceLineNo">089</span> * If a feasible solution is not found (one where all the demands are satisfied with the given constraints), a message is shown.&lt;/p&gt;.  <a name="line.89"></a>
<span class="sourceLineNo">090</span> * <a name="line.90"></a>
<span class="sourceLineNo">091</span> * &lt;h2&gt;Failure tolerance&lt;/h2&gt;<a name="line.91"></a>
<span class="sourceLineNo">092</span> * &lt;p&gt;The user can choose among three possibilities for designing the network:&lt;/p&gt;<a name="line.92"></a>
<span class="sourceLineNo">093</span> * &lt;ul&gt;<a name="line.93"></a>
<span class="sourceLineNo">094</span> * &lt;li&gt;No failure tolerant: The lightpaths established should be enough to carry the traffic of all the demands when no failure <a name="line.94"></a>
<span class="sourceLineNo">095</span> * occurs in the network, but any losses are accepted if the network suffers failures in links or nodes.&lt;/li&gt;<a name="line.95"></a>
<span class="sourceLineNo">096</span> * &lt;li&gt;Tolerant to single-SRG (Shared Risk Group) failures with static lightpaths: All the traffic demands should be satisfied using <a name="line.96"></a>
<span class="sourceLineNo">097</span> * lightpaths, so that under any single-SRG failure (SRGs are taken from the input design), the surviving lightpaths are enough <a name="line.97"></a>
<span class="sourceLineNo">098</span> * to carry the 100% of the traffic. Note that lightpaths are static, in the sense that they are not rerouted when affected by a <a name="line.98"></a>
<span class="sourceLineNo">099</span> * failure (they just also fail), and the design should just overprovision the number of lightpaths to establish with that in mind.&lt;/li&gt;<a name="line.99"></a>
<span class="sourceLineNo">100</span> * &lt;li&gt;1+1 SRG-disjoint protection: This is another form to provide single-SRG failure tolerance. Each lightpath is backed up by <a name="line.100"></a>
<span class="sourceLineNo">101</span> * a SRG-disjoint lightpath (returned as a {@code ProtectionSegment} object). The backup lightpath uses the same type of transponder <a name="line.101"></a>
<span class="sourceLineNo">102</span> * as the primary (and thus the same line rate, an occupies the same number of slots), its path is SRG-disjoint, and the particular <a name="line.102"></a>
<span class="sourceLineNo">103</span> * set of slots occupied can be different. &lt;/li&gt;<a name="line.103"></a>
<span class="sourceLineNo">104</span> * &lt;/ul&gt;<a name="line.104"></a>
<span class="sourceLineNo">105</span> * &lt;h2&gt;Optimization targets&lt;/h2&gt;<a name="line.105"></a>
<span class="sourceLineNo">106</span> * &lt;p&gt;The user can choose between two optimization targets:&lt;/p&gt;<a name="line.106"></a>
<span class="sourceLineNo">107</span> * &lt;ul&gt;<a name="line.107"></a>
<span class="sourceLineNo">108</span> * &lt;li&gt;Minimizing the total cost, given by the transponders and regenerators (if any).&lt;/li&gt;<a name="line.108"></a>
<span class="sourceLineNo">109</span> * &lt;li&gt;Minimizing congestion at the WDM layer. This means looking for the design that maximizes the number of idle slots <a name="line.109"></a>
<span class="sourceLineNo">110</span> * in the bottleneck fiber (the one with less idle frequency slots). &lt;/li&gt;<a name="line.110"></a>
<span class="sourceLineNo">111</span> * &lt;/ul&gt;<a name="line.111"></a>
<span class="sourceLineNo">112</span> * &lt;h2&gt;Use cases&lt;/h2&gt;<a name="line.112"></a>
<span class="sourceLineNo">113</span> * &lt;p&gt;This algorithm is quite general, and fits a number of use cases designing WDM networks, for instance:&lt;/p&gt;<a name="line.113"></a>
<span class="sourceLineNo">114</span> * &lt;ul&gt;<a name="line.114"></a>
<span class="sourceLineNo">115</span> * &lt;li&gt;Single line rate, fixed grid networks: Then, one single type of transponder will be available, which occupies one frequency slot&lt;/li&gt;<a name="line.115"></a>
<span class="sourceLineNo">116</span> * &lt;li&gt;Mixed-Line Rate fixed-grid networks: In this case, several transponders can be available at different line rates and with different optical <a name="line.116"></a>
<span class="sourceLineNo">117</span> * reaches. However, all of them occupy one slot (one wavelength channel)&lt;/li&gt;<a name="line.117"></a>
<span class="sourceLineNo">118</span> * &lt;li&gt;Single line rate, flexi-grid networks using varying-modulation transponders: Several transponders are available (or the same <a name="line.118"></a>
<span class="sourceLineNo">119</span> * transponder with varying configurations), all of them with the same line rate, but thanks to the different usable modulations <a name="line.119"></a>
<span class="sourceLineNo">120</span> * they can have different optical reaches and/or number of occupied slots.&lt;/li&gt;<a name="line.120"></a>
<span class="sourceLineNo">121</span> * &lt;li&gt;Multiple line rate, flexi-grid networks using Bandwidth Variable Transponders: Here, it is possible to use different transponders <a name="line.121"></a>
<span class="sourceLineNo">122</span> * with different line rates, e.g. to reflect more sophisticated transponders which can have different configurations, varying its line rate, <a name="line.122"></a>
<span class="sourceLineNo">123</span> * optical reach, and number of occupied slots.&lt;/li&gt;<a name="line.123"></a>
<span class="sourceLineNo">124</span> * &lt;li&gt;...&lt;/li&gt;<a name="line.124"></a>
<span class="sourceLineNo">125</span> * &lt;/ul&gt;<a name="line.125"></a>
<span class="sourceLineNo">126</span> * &lt;h2&gt;Some details of the algorithm&lt;/h2&gt;<a name="line.126"></a>
<span class="sourceLineNo">127</span> * &lt;p&gt;The algorithm is based on solving a set of MILPs (Mixed Integer Linear Programs) interfacing from JOM to the user-defined <a name="line.127"></a>
<span class="sourceLineNo">128</span> * solver. The algorithm uses a flow-path formulation, where a number of candidate paths are pre-computed for each demand. The <a name="line.128"></a>
<span class="sourceLineNo">129</span> * user-defined parameter {@code k} limits the maximum number of paths computed per demand. In the 1+1 case, the usable SRG-disjoint <a name="line.129"></a>
<span class="sourceLineNo">130</span> * path pairs for each demand are computed from the candidate paths. Increasing the number of paths {@code k} also increases <a name="line.130"></a>
<span class="sourceLineNo">131</span> * the computational complexity of the algorithm, but can produce better solutions. In some occasions, a low {@code k} number is the <a name="line.131"></a>
<span class="sourceLineNo">132</span> * reason for the algorithm failing in finding a feasible solution.&lt;/p&gt;<a name="line.132"></a>
<span class="sourceLineNo">133</span> * &lt;p&gt;The details of the algorithm will be provided in a publication currently under elaboration.&lt;/p&gt;<a name="line.133"></a>
<span class="sourceLineNo">134</span> * <a name="line.134"></a>
<span class="sourceLineNo">135</span> * @net2plan.keywords JOM, WDM<a name="line.135"></a>
<span class="sourceLineNo">136</span> * @net2plan.inputParameters <a name="line.136"></a>
<span class="sourceLineNo">137</span> * @author Pablo Pavon-Marino<a name="line.137"></a>
<span class="sourceLineNo">138</span> */<a name="line.138"></a>
<span class="sourceLineNo">139</span>public class Offline_wdm_routingSpectrumAndModulationAssignmentILP implements IAlgorithm<a name="line.139"></a>
<span class="sourceLineNo">140</span>{<a name="line.140"></a>
<span class="sourceLineNo">141</span>        private InputParameter k = new InputParameter ("k", (int) 5 , "Maximum number of admissible paths per input-output node pair" , 1 , Integer.MAX_VALUE);<a name="line.141"></a>
<span class="sourceLineNo">142</span>        private InputParameter solverName = new InputParameter ("solverName", "#select# glpk ipopt xpress cplex", "The solver name to be used by JOM. GLPK and IPOPT are free, XPRESS and CPLEX commercial. GLPK, XPRESS and CPLEX solve linear problems w/w.o integer contraints. IPOPT is can solve nonlinear problems (if convex, returns global optimum), but cannot handle integer constraints");<a name="line.142"></a>
<span class="sourceLineNo">143</span>        private InputParameter solverLibraryName = new InputParameter ("solverLibraryName", "" , "The solver library full or relative path, to be used by JOM. Leave blank to use JOM default.");<a name="line.143"></a>
<span class="sourceLineNo">144</span>        private InputParameter maxSolverTimeInSeconds = new InputParameter ("maxSolverTimeInSeconds", (double) -1 , "Maximum time granted to the solver to solve the problem. If this time expires, the solver returns the best solution found so far (if a feasible solution is found)");<a name="line.144"></a>
<span class="sourceLineNo">145</span>        private InputParameter numFrequencySlotsPerFiber = new InputParameter ("numWavelengthsPerFiber", (int) 40 , "Number of wavelengths per link" , 1, Integer.MAX_VALUE);<a name="line.145"></a>
<span class="sourceLineNo">146</span>        private InputParameter transponderTypesInfo = new InputParameter ("transponderTypesInfo", "10 1 1 9600 1" , "Transpoder types separated by \";\" . Each type is characterized by the space-separated values: (i) Line rate in Gbps, (ii) cost of the transponder, (iii) number of slots occupied in each traversed fiber, (iv) optical reach in km (a non-positive number means no reach limit), (v) cost of the optical signal regenerator (regenerators do NOT make wavelength conversion ; if negative, regeneration is not possible).");<a name="line.146"></a>
<span class="sourceLineNo">147</span>        private InputParameter wdmLayerIndex = new InputParameter ("wdmLayerIndex", (int) 0 , "Index of the WDM layer (-1 means default layer)");<a name="line.147"></a>
<span class="sourceLineNo">148</span>        private InputParameter networkRecoveryType = new InputParameter ("networkRecoveryType", "#select# not-fault-tolerant single-srg-tolerant-static-lp 1+1-srg-disjoint-lps" , "Establish if the design should be tolerant or not to single SRG failures (SRGs are as defined in the input NetPlan). First option is that the design should not be fault tolerant, the second means that failed lightpaths are not recovered, but an overprovisioned should be made so enough lightpaths survive to carry all the traffic in every failure. The third means that each lightpath is 1+1 protceted by a SRG-disjoint one, that uses the same transponder");<a name="line.148"></a>
<span class="sourceLineNo">149</span>        private InputParameter optimizationTarget = new InputParameter ("optimizationTarget", "#select# min-cost maximin-fiber-number-idle-slots" , "Type of optimization target. Choose among minimize the network cost given by the su mof the transponders cost, and maximize the number of idle frequency slots in the fiber with less idle frequency slot");<a name="line.149"></a>
<span class="sourceLineNo">150</span>        private InputParameter maxPropagationDelayMs = new InputParameter ("maxPropagationDelayMs", (double) -1 , "Maximum allowed propagation time of a lighptath in miliseconds. If non-positive, no limit is assumed");<a name="line.150"></a>
<span class="sourceLineNo">151</span>        private InputParameter bidirectionalTransponders = new InputParameter ("bidirectionalTransponders", true , "If true, the transponders used are bidirectional. Then, the number of lightpaths of each type from node 1 to node 2, equals the number of lightpahts from 2 to 1 (see that both directions can have different routes and slots)");<a name="line.151"></a>
<span class="sourceLineNo">152</span>        <a name="line.152"></a>
<span class="sourceLineNo">153</span>        @Override<a name="line.153"></a>
<span class="sourceLineNo">154</span>        public String executeAlgorithm(NetPlan netPlan, Map&lt;String, String&gt; algorithmParameters, Map&lt;String, String&gt; net2planParameters)<a name="line.154"></a>
<span class="sourceLineNo">155</span>        {<a name="line.155"></a>
<span class="sourceLineNo">156</span>                /* Initialize all InputParameter objects defined in this object (this uses Java reflection) */<a name="line.156"></a>
<span class="sourceLineNo">157</span>                InputParameter.initializeAllInputParameterFieldsOfObject(this, algorithmParameters);<a name="line.157"></a>
<span class="sourceLineNo">158</span><a name="line.158"></a>
<span class="sourceLineNo">159</span>                final NetworkLayer wdmLayer = wdmLayerIndex.getInt () == -1? netPlan.getNetworkLayerDefault() : netPlan.getNetworkLayer(wdmLayerIndex.getInt ());<a name="line.159"></a>
<span class="sourceLineNo">160</span><a name="line.160"></a>
<span class="sourceLineNo">161</span>                /* Basic checks */<a name="line.161"></a>
<span class="sourceLineNo">162</span>                final int N = netPlan.getNumberOfNodes();<a name="line.162"></a>
<span class="sourceLineNo">163</span>                final int E = netPlan.getNumberOfLinks(wdmLayer);<a name="line.163"></a>
<span class="sourceLineNo">164</span>                final int D = netPlan.getNumberOfDemands(wdmLayer);<a name="line.164"></a>
<span class="sourceLineNo">165</span>                final int S = numFrequencySlotsPerFiber.getInt();<a name="line.165"></a>
<span class="sourceLineNo">166</span>                if (N == 0 || E == 0 || D == 0) throw new Net2PlanException("This algorithm requires a topology with links and a demand set");<a name="line.166"></a>
<span class="sourceLineNo">167</span><a name="line.167"></a>
<span class="sourceLineNo">168</span>                /* Store transpoder info */<a name="line.168"></a>
<span class="sourceLineNo">169</span>                WDMUtils.TransponderTypesInfo tpInfo = new WDMUtils.TransponderTypesInfo(transponderTypesInfo.getString());<a name="line.169"></a>
<span class="sourceLineNo">170</span>                final int T = tpInfo.getNumTypes();<a name="line.170"></a>
<span class="sourceLineNo">171</span>                <a name="line.171"></a>
<span class="sourceLineNo">172</span>                /* Remove all routes in current netPlan object. Initialize link capacities and attributes, and demand offered traffic */<a name="line.172"></a>
<span class="sourceLineNo">173</span>                netPlan.removeAllMulticastTrees(wdmLayer);<a name="line.173"></a>
<span class="sourceLineNo">174</span>                netPlan.removeAllUnicastRoutingInformation(wdmLayer);<a name="line.174"></a>
<span class="sourceLineNo">175</span>                netPlan.setRoutingType(RoutingType.SOURCE_ROUTING , wdmLayer);<a name="line.175"></a>
<span class="sourceLineNo">176</span><a name="line.176"></a>
<span class="sourceLineNo">177</span>                /* Compute the candidate path list of possible paths */<a name="line.177"></a>
<span class="sourceLineNo">178</span>                final Map&lt;Demand,List&lt;List&lt;Link&gt;&gt;&gt; cpl = netPlan.computeUnicastCandidatePathList(wdmLayer , <a name="line.178"></a>
<span class="sourceLineNo">179</span>                                netPlan.getVectorLinkLengthInKm(wdmLayer).toArray(), "K" , "" + k.getInt() , "maxLengthInKm" , ""+tpInfo.getMaxOpticalReachKm(), "maxPropDelayInMs" , "" + maxPropagationDelayMs.getDouble());<a name="line.179"></a>
<span class="sourceLineNo">180</span>                final Map&lt;Demand,List&lt;Pair&lt;List&lt;Link&gt;,List&lt;Link&gt;&gt;&gt;&gt; cpl11 = networkRecoveryType.getString().equals("1+1-srg-disjoint-lps")? NetPlan.computeUnicastCandidate11PathList(cpl,0) : null;<a name="line.180"></a>
<span class="sourceLineNo">181</span>                <a name="line.181"></a>
<span class="sourceLineNo">182</span>                /* Compute the CPL, adding the routes */<a name="line.182"></a>
<span class="sourceLineNo">183</span>                /* 1+1 case: as many routes as 1+1 valid pairs (then, the same sequence of links can be in more than one Route). The route index and segment index are the same (1+1 pair index) */<a name="line.183"></a>
<span class="sourceLineNo">184</span>                /* rest of the cases: each sequence of links appears at most once */<a name="line.184"></a>
<span class="sourceLineNo">185</span>                Map&lt;Link,Double&gt; linkLengthMap = new HashMap&lt;Link,Double&gt; (); for (Link e : netPlan.getLinks(wdmLayer)) linkLengthMap.put(e , e.getLengthInKm());<a name="line.185"></a>
<span class="sourceLineNo">186</span>                final int maximumNumberOfPaths = T*k.getInt()*D;<a name="line.186"></a>
<span class="sourceLineNo">187</span>                List&lt;Integer&gt; transponderType_p = new ArrayList&lt;Integer&gt; (maximumNumberOfPaths);<a name="line.187"></a>
<span class="sourceLineNo">188</span>                List&lt;Double&gt; cost_p = new ArrayList&lt;Double&gt; (maximumNumberOfPaths); <a name="line.188"></a>
<span class="sourceLineNo">189</span>                List&lt;Double&gt; lineRate_p = new ArrayList&lt;Double&gt; (maximumNumberOfPaths); <a name="line.189"></a>
<span class="sourceLineNo">190</span>                List&lt;Integer&gt; numSlots_p = new ArrayList&lt;Integer&gt; (maximumNumberOfPaths);<a name="line.190"></a>
<span class="sourceLineNo">191</span>                List&lt;List&lt;Link&gt;&gt; seqLinks_p = new ArrayList&lt;List&lt;Link&gt;&gt; (maximumNumberOfPaths);<a name="line.191"></a>
<span class="sourceLineNo">192</span>                List&lt;List&lt;Link&gt;&gt; seqLinks2_p = cpl11 == null? null : new ArrayList&lt;List&lt;Link&gt;&gt; (maximumNumberOfPaths);<a name="line.192"></a>
<span class="sourceLineNo">193</span>                List&lt;int []&gt; regPositions_p = new ArrayList&lt;int []&gt; (maximumNumberOfPaths);<a name="line.193"></a>
<span class="sourceLineNo">194</span>                List&lt;int []&gt; regPositions2_p = new ArrayList&lt;int []&gt; (maximumNumberOfPaths);<a name="line.194"></a>
<span class="sourceLineNo">195</span>                List&lt;Demand&gt; demand_p = new ArrayList&lt;Demand&gt; (maximumNumberOfPaths);<a name="line.195"></a>
<span class="sourceLineNo">196</span>                for (Demand d : netPlan.getDemands(wdmLayer))<a name="line.196"></a>
<span class="sourceLineNo">197</span>                {<a name="line.197"></a>
<span class="sourceLineNo">198</span>                        boolean atLeastOnePathOrPathPair = false;<a name="line.198"></a>
<span class="sourceLineNo">199</span>                        for (int t = 0 ; t &lt; T ; t ++)<a name="line.199"></a>
<span class="sourceLineNo">200</span>                        {<a name="line.200"></a>
<span class="sourceLineNo">201</span>                                final double regeneratorCost = tpInfo.getRegeneratorCost(t);<a name="line.201"></a>
<span class="sourceLineNo">202</span>                                final boolean isRegenerable = regeneratorCost &gt;= 0;<a name="line.202"></a>
<span class="sourceLineNo">203</span>                                for (Object sp : cpl11 != null? cpl11.get(d) : cpl.get(d))<a name="line.203"></a>
<span class="sourceLineNo">204</span>                                {<a name="line.204"></a>
<span class="sourceLineNo">205</span>                                        List&lt;Link&gt; firstPath = (cpl11 == null)? ((List&lt;Link&gt;) sp) : ((Pair&lt;List&lt;Link&gt;,List&lt;Link&gt;&gt;) sp).getFirst(); <a name="line.205"></a>
<span class="sourceLineNo">206</span>                                        List&lt;Link&gt; secondPath = (cpl11 == null)? null : ((Pair&lt;List&lt;Link&gt;,List&lt;Link&gt;&gt;) sp).getSecond (); <a name="line.206"></a>
<span class="sourceLineNo">207</span>                                        if (!isRegenerable &amp;&amp; (getLengthInKm(firstPath) &gt; tpInfo.getOpticalReachKm(t))) break;<a name="line.207"></a>
<span class="sourceLineNo">208</span>                                        if (secondPath != null) if (!isRegenerable &amp;&amp; (getLengthInKm(secondPath) &gt; tpInfo.getOpticalReachKm(t))) break;<a name="line.208"></a>
<span class="sourceLineNo">209</span><a name="line.209"></a>
<span class="sourceLineNo">210</span>                                        final int [] regPositions1 = isRegenerable? WDMUtils.computeRegeneratorPositions(firstPath , tpInfo.getOpticalReachKm(t)) : new int [firstPath.size()];<a name="line.210"></a>
<span class="sourceLineNo">211</span>                                        final int [] regPositions2 = cpl11 == null? null : isRegenerable? WDMUtils.computeRegeneratorPositions(secondPath , tpInfo.getOpticalReachKm(t)) : new int [secondPath.size()];<a name="line.211"></a>
<span class="sourceLineNo">212</span>                                        final int numRegeneratorsNeeded = !isRegenerable? 0 : (int) IntUtils.sum(regPositions1) + (secondPath == null? 0 : (int) IntUtils.sum(regPositions2)) ;<a name="line.212"></a>
<span class="sourceLineNo">213</span>                                        final double costOfLightpathOr11Pair = tpInfo.getCost(t) * (cpl11 != null? 2 : 1) + (tpInfo.getRegeneratorCost(t) * numRegeneratorsNeeded);<a name="line.213"></a>
<span class="sourceLineNo">214</span><a name="line.214"></a>
<span class="sourceLineNo">215</span>                                        cost_p.add (costOfLightpathOr11Pair);<a name="line.215"></a>
<span class="sourceLineNo">216</span>                                        transponderType_p.add (t);<a name="line.216"></a>
<span class="sourceLineNo">217</span>                                        lineRate_p.add(tpInfo.getLineRateGbps(t));<a name="line.217"></a>
<span class="sourceLineNo">218</span>                                        numSlots_p.add(tpInfo.getNumSlots(t));<a name="line.218"></a>
<span class="sourceLineNo">219</span>                                        demand_p.add(d);<a name="line.219"></a>
<span class="sourceLineNo">220</span>                                        seqLinks_p.add(firstPath);<a name="line.220"></a>
<span class="sourceLineNo">221</span>                                        regPositions_p.add(regPositions1);<a name="line.221"></a>
<span class="sourceLineNo">222</span>                                        if (cpl11 != null) { seqLinks2_p.add(secondPath); regPositions2_p.add(regPositions2); }<a name="line.222"></a>
<span class="sourceLineNo">223</span>                                        atLeastOnePathOrPathPair = true;<a name="line.223"></a>
<span class="sourceLineNo">224</span>                                }<a name="line.224"></a>
<span class="sourceLineNo">225</span>                        }<a name="line.225"></a>
<span class="sourceLineNo">226</span>                        if (!atLeastOnePathOrPathPair) throw new Net2PlanException ("There are no possible routes (or 1+1 pairs) for a demand (" + d + "). The topology may be not connected enough, or the optical reach may be too small");<a name="line.226"></a>
<span class="sourceLineNo">227</span>                }<a name="line.227"></a>
<span class="sourceLineNo">228</span>                final int P = transponderType_p.size(); // one per potential sequence of links (or 1+1 pairs of sequences) and transponder<a name="line.228"></a>
<span class="sourceLineNo">229</span><a name="line.229"></a>
<span class="sourceLineNo">230</span>                /* Compute some important matrices for the formulation */<a name="line.230"></a>
<span class="sourceLineNo">231</span>                DoubleMatrix2D A_dp = DoubleFactory2D.sparse.make(D,P); /* 1 is path p is assigned to demand d */<a name="line.231"></a>
<span class="sourceLineNo">232</span>                DoubleMatrix2D A_ep = DoubleFactory2D.sparse.make(E,P); /* 1 if path (or primary path in 1+1) p travserses link e */<a name="line.232"></a>
<span class="sourceLineNo">233</span>                DoubleMatrix2D A2_ep = DoubleFactory2D.sparse.make(E,P); /* 1 if backup path of pair p traverses link e */<a name="line.233"></a>
<span class="sourceLineNo">234</span>                DoubleMatrix2D A_psrg = DoubleFactory2D.sparse.make(P,netPlan.getNumberOfSRGs()); /* 1 if path p fails when srg fails */<a name="line.234"></a>
<span class="sourceLineNo">235</span>                double [][] feasibleAssignment_ps = new double [P][S];<a name="line.235"></a>
<span class="sourceLineNo">236</span>                DoubleMatrix2D [] A_n1Mn2p = new DoubleMatrix2D [T];<a name="line.236"></a>
<span class="sourceLineNo">237</span>                if (bidirectionalTransponders.getBoolean())<a name="line.237"></a>
<span class="sourceLineNo">238</span>                        for (int t = 0 ; t &lt; T ; t ++) A_n1Mn2p [t] = DoubleFactory2D.sparse.make(N*N , P);<a name="line.238"></a>
<span class="sourceLineNo">239</span>                for (int p = 0 ; p &lt; P ; p ++)<a name="line.239"></a>
<span class="sourceLineNo">240</span>                {<a name="line.240"></a>
<span class="sourceLineNo">241</span>                        A_dp.set(demand_p.get(p).getIndex() , p , 1.0);<a name="line.241"></a>
<span class="sourceLineNo">242</span>                        for (Link e : seqLinks_p.get(p)) A_ep.set (e.getIndex() , p , 1.0);<a name="line.242"></a>
<span class="sourceLineNo">243</span>                        if (cpl11 != null) for (Link e : seqLinks2_p.get(p)) A2_ep.set (e.getIndex() , p , 1.0);<a name="line.243"></a>
<span class="sourceLineNo">244</span>                        if (networkRecoveryType.getString().equals("single-srg-tolerant-static-lp"))<a name="line.244"></a>
<span class="sourceLineNo">245</span>                                for (Link e : seqLinks_p.get(p))<a name="line.245"></a>
<span class="sourceLineNo">246</span>                                {<a name="line.246"></a>
<span class="sourceLineNo">247</span>                                        for (SharedRiskGroup srg : e.getSRGs()) A_psrg.set(p,srg.getIndex(),1.0);<a name="line.247"></a>
<span class="sourceLineNo">248</span>                                        for (SharedRiskGroup srg : e.getOriginNode().getSRGs()) A_psrg.set(p,srg.getIndex(),1.0);<a name="line.248"></a>
<span class="sourceLineNo">249</span>                                        for (SharedRiskGroup srg : e.getDestinationNode().getSRGs()) A_psrg.set(p,srg.getIndex(),1.0);<a name="line.249"></a>
<span class="sourceLineNo">250</span>                                }<a name="line.250"></a>
<span class="sourceLineNo">251</span>                        for (int s = 0; s &lt; S + 1 - numSlots_p.get(p) ; s ++)<a name="line.251"></a>
<span class="sourceLineNo">252</span>                                feasibleAssignment_ps [p][s] = 1;<a name="line.252"></a>
<span class="sourceLineNo">253</span>                        if (bidirectionalTransponders.getBoolean())<a name="line.253"></a>
<span class="sourceLineNo">254</span>                        {<a name="line.254"></a>
<span class="sourceLineNo">255</span>                                final int t = transponderType_p.get(p);<a name="line.255"></a>
<span class="sourceLineNo">256</span>                                final int n1 = demand_p.get(p).getIngressNode().getIndex();<a name="line.256"></a>
<span class="sourceLineNo">257</span>                                final int n2 = demand_p.get(p).getEgressNode().getIndex();<a name="line.257"></a>
<span class="sourceLineNo">258</span>                                final int nLower = n1 &lt; n2? n1 : n2;<a name="line.258"></a>
<span class="sourceLineNo">259</span>                                final int nGreater = n1 &gt; n2? n1 : n2;<a name="line.259"></a>
<span class="sourceLineNo">260</span>                                A_n1Mn2p [t].set(nLower + N * nGreater , p , nLower == n1? 1.0 : -1.0);<a name="line.260"></a>
<span class="sourceLineNo">261</span>                        }<a name="line.261"></a>
<span class="sourceLineNo">262</span>                }<a name="line.262"></a>
<span class="sourceLineNo">263</span>                <a name="line.263"></a>
<span class="sourceLineNo">264</span>                <a name="line.264"></a>
<span class="sourceLineNo">265</span>                /* Create the optimization problem object (JOM library) */<a name="line.265"></a>
<span class="sourceLineNo">266</span>                OptimizationProblem op = new OptimizationProblem();<a name="line.266"></a>
<span class="sourceLineNo">267</span><a name="line.267"></a>
<span class="sourceLineNo">268</span>                /* Add the decision variables to the problem */<a name="line.268"></a>
<span class="sourceLineNo">269</span>                /* p is the route index and s the initial slot. In 1+1, p is the 1+1 pair index (equal to the route and segment indexes), s the initial slot of the primary (route)   */<a name="line.269"></a>
<span class="sourceLineNo">270</span>                op.addDecisionVariable("x_ps", true, new int[] {P, S}, new DoubleMatrixND (new int [] {P,S}) , new DoubleMatrixND (feasibleAssignment_ps)); /* 1 if lightpath d(p) is routed through path p in wavelength w */<a name="line.270"></a>
<span class="sourceLineNo">271</span>                if (cpl11 != null)<a name="line.271"></a>
<span class="sourceLineNo">272</span>                        /* p is the 1+1 pair index (equal to the route and segment indexes), s the initial slot of the backup (segment)   */<a name="line.272"></a>
<span class="sourceLineNo">273</span>                        op.addDecisionVariable("x2_ps", true, new int[] {P, S}, new DoubleMatrixND (new int [] {P,S}) , new DoubleMatrixND (feasibleAssignment_ps)); /* 1 if lightpath d(p) is routed through path p in wavelength w */<a name="line.273"></a>
<span class="sourceLineNo">274</span>                <a name="line.274"></a>
<span class="sourceLineNo">275</span>                /* Set some input parameters */<a name="line.275"></a>
<span class="sourceLineNo">276</span>                op.setInputParameter("S", S);<a name="line.276"></a>
<span class="sourceLineNo">277</span>                op.setInputParameter("h_d", netPlan.getVectorDemandOfferedTraffic(), "row");<a name="line.277"></a>
<span class="sourceLineNo">278</span>                op.setInputParameter("rate_p", lineRate_p , "row");<a name="line.278"></a>
<span class="sourceLineNo">279</span>                op.setInputParameter("c_p", cost_p , "row");<a name="line.279"></a>
<span class="sourceLineNo">280</span>                op.setInputParameter("A_dp", A_dp);<a name="line.280"></a>
<span class="sourceLineNo">281</span>                op.setInputParameter("A_ep", A_ep); // in 1+1, only occupation of the primaries (p is the 1+1 pair index, equal to route and segment indexes)<a name="line.281"></a>
<span class="sourceLineNo">282</span>                if (cpl11 != null)<a name="line.282"></a>
<span class="sourceLineNo">283</span>                        op.setInputParameter("A2_ep", A2_ep); <a name="line.283"></a>
<span class="sourceLineNo">284</span>                <a name="line.284"></a>
<span class="sourceLineNo">285</span>                /* Sets the objective function */<a name="line.285"></a>
<span class="sourceLineNo">286</span>                if (optimizationTarget.getString().equals("min-cost"))<a name="line.286"></a>
<span class="sourceLineNo">287</span>                        op.setObjectiveFunction("minimize", "sum(c_p * x_ps)"); /* sum_ps (c_p · x_ps). In 1+1 the cost is multiplied by two */<a name="line.287"></a>
<span class="sourceLineNo">288</span>                else if (optimizationTarget.getString().equals("maximin-fiber-number-idle-slots"))<a name="line.288"></a>
<span class="sourceLineNo">289</span>                {<a name="line.289"></a>
<span class="sourceLineNo">290</span>                        op.addDecisionVariable("u", true, new int[] {1, 1} , 0 , S); /* Number of idle slots in the worst case fiber */<a name="line.290"></a>
<span class="sourceLineNo">291</span>                        op.setObjectiveFunction("maximize", "u");<a name="line.291"></a>
<span class="sourceLineNo">292</span>                        op.setInputParameter("numSlots_p", numSlots_p , "row");<a name="line.292"></a>
<span class="sourceLineNo">293</span>                        if (cpl11 == null)<a name="line.293"></a>
<span class="sourceLineNo">294</span>                                op.addConstraint("sum(A_ep * diag(numSlots_p) * x_ps , 2) &lt;= S - u");<a name="line.294"></a>
<span class="sourceLineNo">295</span>                        else<a name="line.295"></a>
<span class="sourceLineNo">296</span>                                op.addConstraint("sum(A_ep * diag(numSlots_p) * x_ps + A2_ep * diag(numSlots_p) * x2_ps , 2) &lt;= S - u");<a name="line.296"></a>
<span class="sourceLineNo">297</span>                }<a name="line.297"></a>
<span class="sourceLineNo">298</span>                        <a name="line.298"></a>
<span class="sourceLineNo">299</span>                /* Carry enough traffic in each demand to satisfy the minimum traffic to carry (no failure state) */<a name="line.299"></a>
<span class="sourceLineNo">300</span>                /* sum_{s , p \in P_d} rate_p x_ps &gt;= h_d, for each d */<a name="line.300"></a>
<span class="sourceLineNo">301</span>                op.addConstraint("A_dp * diag (rate_p) * x_ps * ones([S; 1]) &gt;= h_d'"); /* each lightpath d: is carried in exactly one p-w --&gt; sum_{p in P_d, w} x_dp &lt;= 1, for all d */<a name="line.301"></a>
<span class="sourceLineNo">302</span>                if (cpl11 != null)<a name="line.302"></a>
<span class="sourceLineNo">303</span>                        op.addConstraint("sum(x_ps,2) == sum(x2_ps,2)"); /* The number of lightpath in primary of 1+1 pair p and inthe backup is the same  */<a name="line.303"></a>
<span class="sourceLineNo">304</span><a name="line.304"></a>
<span class="sourceLineNo">305</span>                /* (no 1+1, but fault tolerant) Carry enough traffic in each demand to satisfy the minimum traffic to carry, in all of the single-SRG failure states */<a name="line.305"></a>
<span class="sourceLineNo">306</span>                if (networkRecoveryType.getString().equals("single-srg-tolerant-static-lp"))<a name="line.306"></a>
<span class="sourceLineNo">307</span>                {<a name="line.307"></a>
<span class="sourceLineNo">308</span>                        /* sum_{s , p \in P_d, p survives} rate_p x_ps &gt;= h_d, for each d, for each srg */<a name="line.308"></a>
<span class="sourceLineNo">309</span>                        for (int srg = 0 ; srg &lt; A_psrg.columns() ; srg ++)<a name="line.309"></a>
<span class="sourceLineNo">310</span>                        {<a name="line.310"></a>
<span class="sourceLineNo">311</span>                                /* Asrg_pp_ Diagonal pxp matrix, with a one for surviving paths */<a name="line.311"></a>
<span class="sourceLineNo">312</span>                                DoubleMatrix2D Asrg_pp = DoubleFactory2D.sparse.make(P,P);<a name="line.312"></a>
<span class="sourceLineNo">313</span>                                for (int p = 0; p &lt; P ; p ++) Asrg_pp.set(p,p,1 - A_psrg.get(p , srg));<a name="line.313"></a>
<span class="sourceLineNo">314</span>                                op.setInputParameter("Asrg_pp" , Asrg_pp);<a name="line.314"></a>
<span class="sourceLineNo">315</span>                                op.addConstraint("A_dp * Asrg_pp * diag (rate_p) * x_ps * ones([S; 1]) &gt;= h_d'"); /* each lightpath d: is carried in exactly one p-w --&gt; sum_{p in P_d, w} x_dp &lt;= 1, for all d */<a name="line.315"></a>
<span class="sourceLineNo">316</span>                        }<a name="line.316"></a>
<span class="sourceLineNo">317</span>                }<a name="line.317"></a>
<span class="sourceLineNo">318</span>                <a name="line.318"></a>
<span class="sourceLineNo">319</span>                /* Frequency-slot clashing */<a name="line.319"></a>
<span class="sourceLineNo">320</span>                /* \sum_t \sum_{p \in P_e, sinit {s-numSlots(t),s} x_ps &lt;= 1, for each e, s   */<a name="line.320"></a>
<span class="sourceLineNo">321</span>                String constraintString = "";<a name="line.321"></a>
<span class="sourceLineNo">322</span>                for (int t = 0; t &lt; T ; t ++)<a name="line.322"></a>
<span class="sourceLineNo">323</span>                {<a name="line.323"></a>
<span class="sourceLineNo">324</span>                        {<a name="line.324"></a>
<span class="sourceLineNo">325</span>                                final String name_At_pp = "A" + Integer.toString(t) + "_pp";<a name="line.325"></a>
<span class="sourceLineNo">326</span>                                final String name_At_s1s2 = "A" + Integer.toString(t) + "_s1s2";<a name="line.326"></a>
<span class="sourceLineNo">327</span>                                /* At_pp, diagonal matrix, 1 if path p is associated to a transponder of type t */<a name="line.327"></a>
<span class="sourceLineNo">328</span>                                DoubleMatrix2D At_pp = DoubleFactory2D.sparse.make(P,P);<a name="line.328"></a>
<span class="sourceLineNo">329</span>                                int p = 0; for (int type : transponderType_p) { if (type == t) At_pp.set(p,p,1.0); p++; }<a name="line.329"></a>
<span class="sourceLineNo">330</span>                                /* At_s1s2, upper triangular matrix, 1 if a transponder of type with initial slot s1, occupied slots s2 (depends on number of slots occupied) */<a name="line.330"></a>
<span class="sourceLineNo">331</span>                                DoubleMatrix2D At_s1s2 = DoubleFactory2D.sparse.make(S,S);<a name="line.331"></a>
<span class="sourceLineNo">332</span>                                for (int s1 = 0 ; s1 &lt; S ; s1 ++)<a name="line.332"></a>
<span class="sourceLineNo">333</span>                                        for (int cont = 0 ; cont &lt; tpInfo.getNumSlots(t) ; cont ++)<a name="line.333"></a>
<span class="sourceLineNo">334</span>                                                if (s1 - cont &gt;= 0) At_s1s2.set(s1-cont,s1,1.0); <a name="line.334"></a>
<span class="sourceLineNo">335</span>                                op.setInputParameter(name_At_pp, At_pp);<a name="line.335"></a>
<span class="sourceLineNo">336</span>                                op.setInputParameter(name_At_s1s2, At_s1s2);<a name="line.336"></a>
<span class="sourceLineNo">337</span>                                constraintString += (t == 0? "" : " + ") + "( A_ep * " + name_At_pp + " * x_ps * " + name_At_s1s2 + " ) "; <a name="line.337"></a>
<span class="sourceLineNo">338</span>                        }<a name="line.338"></a>
<span class="sourceLineNo">339</span><a name="line.339"></a>
<span class="sourceLineNo">340</span>                        if (cpl11 != null) // sum also the slots occupied by the <a name="line.340"></a>
<span class="sourceLineNo">341</span>                        {<a name="line.341"></a>
<span class="sourceLineNo">342</span>                                final String name_A2t_pp = "A2" + Integer.toString(t) + "_pp";<a name="line.342"></a>
<span class="sourceLineNo">343</span>                                final String name_A2t_s1s2 = "A2" + Integer.toString(t) + "_s1s2";<a name="line.343"></a>
<span class="sourceLineNo">344</span>                                /* At_pp, diagonal matrix, 1 if path p is associated to a transponder of type t */<a name="line.344"></a>
<span class="sourceLineNo">345</span>                                DoubleMatrix2D A2t_pp = DoubleFactory2D.sparse.make(P,P);<a name="line.345"></a>
<span class="sourceLineNo">346</span>                                int p = 0; for (int type : transponderType_p) { if (type == t) A2t_pp.set(p,p,1.0); p++; }<a name="line.346"></a>
<span class="sourceLineNo">347</span>                                /* At_s1s2, upper triangular matrix, 1 if a transponder of type with initial slot s1, occupied slots s2 (depends on number of slots occupied) */<a name="line.347"></a>
<span class="sourceLineNo">348</span>                                DoubleMatrix2D A2t_s1s2 = DoubleFactory2D.sparse.make(S,S);<a name="line.348"></a>
<span class="sourceLineNo">349</span>                                for (int s1 = 0 ; s1 &lt; S ; s1 ++)<a name="line.349"></a>
<span class="sourceLineNo">350</span>                                        for (int cont = 0 ; cont &lt; tpInfo.getNumSlots(t) ; cont ++)<a name="line.350"></a>
<span class="sourceLineNo">351</span>                                                if (s1 - cont &gt;= 0) A2t_s1s2.set(s1-cont,s1,1.0); <a name="line.351"></a>
<span class="sourceLineNo">352</span>                                op.setInputParameter(name_A2t_pp, A2t_pp);<a name="line.352"></a>
<span class="sourceLineNo">353</span>                                op.setInputParameter(name_A2t_s1s2, A2t_s1s2);<a name="line.353"></a>
<span class="sourceLineNo">354</span>                                constraintString += " + ( A2_ep * " + name_A2t_pp + " * x2_ps * " + name_A2t_s1s2 + " ) "; <a name="line.354"></a>
<span class="sourceLineNo">355</span>                        }<a name="line.355"></a>
<span class="sourceLineNo">356</span>                }               <a name="line.356"></a>
<span class="sourceLineNo">357</span>                op.addConstraint(constraintString + " &lt;= 1"); /* wavelength-clashing constraints --&gt; sum_{p in P_e, w} x_pw &lt;= 1, for all e,w */<a name="line.357"></a>
<span class="sourceLineNo">358</span><a name="line.358"></a>
<span class="sourceLineNo">359</span>                /* Bidirectional constraints */<a name="line.359"></a>
<span class="sourceLineNo">360</span>                if (bidirectionalTransponders.getBoolean())<a name="line.360"></a>
<span class="sourceLineNo">361</span>                {<a name="line.361"></a>
<span class="sourceLineNo">362</span>                        for (int t = 0 ; t &lt; T ; t ++)<a name="line.362"></a>
<span class="sourceLineNo">363</span>                        {<a name="line.363"></a>
<span class="sourceLineNo">364</span>                                op.setInputParameter("At_n1Mn2p" , A_n1Mn2p [t]);<a name="line.364"></a>
<span class="sourceLineNo">365</span>                                if (cpl11 != null)<a name="line.365"></a>
<span class="sourceLineNo">366</span>                                        op.addConstraint("sum (At_n1Mn2p * (x_ps + x2_ps) , 2) == 0");<a name="line.366"></a>
<span class="sourceLineNo">367</span>                                else<a name="line.367"></a>
<span class="sourceLineNo">368</span>                                        op.addConstraint("sum (At_n1Mn2p * x_ps , 2) == 0");<a name="line.368"></a>
<span class="sourceLineNo">369</span>                        }<a name="line.369"></a>
<span class="sourceLineNo">370</span>                }<a name="line.370"></a>
<span class="sourceLineNo">371</span>                <a name="line.371"></a>
<span class="sourceLineNo">372</span>                /* Call the solver to solve the problem */<a name="line.372"></a>
<span class="sourceLineNo">373</span>                op.solve(solverName.getString(), "solverLibraryName", solverLibraryName.getString() , "maxSolverTimeInSeconds" , maxSolverTimeInSeconds.getDouble());<a name="line.373"></a>
<span class="sourceLineNo">374</span><a name="line.374"></a>
<span class="sourceLineNo">375</span>                /* If a feasible solution was not found, quit (this may also happen if after the maximum solver time no feasible solution is found) */<a name="line.375"></a>
<span class="sourceLineNo">376</span>                if (!op.solutionIsFeasible()) throw new Net2PlanException("A feasible solution was not found");<a name="line.376"></a>
<span class="sourceLineNo">377</span><a name="line.377"></a>
<span class="sourceLineNo">378</span>                /* Retrieve the optimum solutions */<a name="line.378"></a>
<span class="sourceLineNo">379</span>                DoubleMatrix2D x_ps = op.getPrimalSolution("x_ps").view2D();<a name="line.379"></a>
<span class="sourceLineNo">380</span>                DoubleMatrix2D x2_ps = cpl11 == null? null : op.getPrimalSolution("x2_ps").view2D();<a name="line.380"></a>
<span class="sourceLineNo">381</span><a name="line.381"></a>
<span class="sourceLineNo">382</span>                /* Create the lightpaths according to the solutions given */<a name="line.382"></a>
<span class="sourceLineNo">383</span>                WDMUtils.setFibersNumFrequencySlots(netPlan , numFrequencySlotsPerFiber.getInt() , wdmLayer);<a name="line.383"></a>
<span class="sourceLineNo">384</span>                IntArrayList slots = new IntArrayList (); DoubleArrayList vals = new DoubleArrayList ();<a name="line.384"></a>
<span class="sourceLineNo">385</span>                IntArrayList slots2 = new IntArrayList (); DoubleArrayList vals2 = new DoubleArrayList ();<a name="line.385"></a>
<span class="sourceLineNo">386</span>                for (int p = 0; p &lt; P ; p ++)<a name="line.386"></a>
<span class="sourceLineNo">387</span>                {<a name="line.387"></a>
<span class="sourceLineNo">388</span>                        slots.clear(); vals.clear();<a name="line.388"></a>
<span class="sourceLineNo">389</span>                        x_ps.viewRow(p).getNonZeros(slots , vals);<a name="line.389"></a>
<span class="sourceLineNo">390</span>                        if (cpl11 != null) <a name="line.390"></a>
<span class="sourceLineNo">391</span>                        { <a name="line.391"></a>
<span class="sourceLineNo">392</span>                                slots2.clear(); vals.clear(); x2_ps.viewRow(p).getNonZeros(slots2 , vals2);<a name="line.392"></a>
<span class="sourceLineNo">393</span>                                if (slots.size() != slots2.size()) throw new RuntimeException ("Bad");<a name="line.393"></a>
<span class="sourceLineNo">394</span>                        } <a name="line.394"></a>
<span class="sourceLineNo">395</span>                        if (slots.size() == 0) continue;<a name="line.395"></a>
<span class="sourceLineNo">396</span>                        for (int cont = 0 ; cont &lt; slots.size() ; cont ++)<a name="line.396"></a>
<span class="sourceLineNo">397</span>                        {<a name="line.397"></a>
<span class="sourceLineNo">398</span>                                final int s = slots.get (cont);<a name="line.398"></a>
<span class="sourceLineNo">399</span>                                final Route r = WDMUtils.addLightpath(demand_p.get(p) , new WDMUtils.RSA(seqLinks_p.get(p) , s , numSlots_p.get(p) , regPositions_p.get(p)) , lineRate_p.get(p));<a name="line.399"></a>
<span class="sourceLineNo">400</span>                                if (cpl11 != null)<a name="line.400"></a>
<span class="sourceLineNo">401</span>                                {<a name="line.401"></a>
<span class="sourceLineNo">402</span>                                        final int s2 = slots2.get(cont);<a name="line.402"></a>
<span class="sourceLineNo">403</span>                                        final ProtectionSegment segment = WDMUtils.addLightpathAsProtectionSegment(new WDMUtils.RSA(seqLinks2_p.get(p) , s2 , numSlots_p.get(p) , regPositions2_p.get(p)));<a name="line.403"></a>
<span class="sourceLineNo">404</span>                                        r.addProtectionSegment(segment);<a name="line.404"></a>
<span class="sourceLineNo">405</span>                                }<a name="line.405"></a>
<span class="sourceLineNo">406</span>                        }<a name="line.406"></a>
<span class="sourceLineNo">407</span>                }<a name="line.407"></a>
<span class="sourceLineNo">408</span>                <a name="line.408"></a>
<span class="sourceLineNo">409</span>                WDMUtils.checkResourceAllocationClashing(netPlan,true,true,wdmLayer);<a name="line.409"></a>
<span class="sourceLineNo">410</span><a name="line.410"></a>
<span class="sourceLineNo">411</span>                return "Ok!";<a name="line.411"></a>
<span class="sourceLineNo">412</span>        }<a name="line.412"></a>
<span class="sourceLineNo">413</span><a name="line.413"></a>
<span class="sourceLineNo">414</span>        private static double getLengthInKm (Collection&lt;Link&gt; r) { double res = 0; for (Link e : r) res += e.getLengthInKm(); return res; }<a name="line.414"></a>
<span class="sourceLineNo">415</span>        <a name="line.415"></a>
<span class="sourceLineNo">416</span>        @Override<a name="line.416"></a>
<span class="sourceLineNo">417</span>        public String getDescription()<a name="line.417"></a>
<span class="sourceLineNo">418</span>        {<a name="line.418"></a>
<span class="sourceLineNo">419</span>                return "Algorithm based on an ILP solving the Routing, Spectrum, Modulation Assignment (RSMA) problem with regenerator placement, in flexi (elastic) or fixed grid optical WDM networks, with or without fault tolerance, latency and/or lightpath bidirectionality requisites (see the Javadoc for details).";<a name="line.419"></a>
<span class="sourceLineNo">420</span>        }<a name="line.420"></a>
<span class="sourceLineNo">421</span><a name="line.421"></a>
<span class="sourceLineNo">422</span>        @Override<a name="line.422"></a>
<span class="sourceLineNo">423</span>        public List&lt;Triple&lt;String, String, String&gt;&gt; getParameters()<a name="line.423"></a>
<span class="sourceLineNo">424</span>        {<a name="line.424"></a>
<span class="sourceLineNo">425</span>                /* Returns the parameter information for all the InputParameter objects defined in this object (uses Java reflection) */<a name="line.425"></a>
<span class="sourceLineNo">426</span>                return InputParameter.getInformationAllInputParameterFieldsOfObject(this);<a name="line.426"></a>
<span class="sourceLineNo">427</span>        }<a name="line.427"></a>
<span class="sourceLineNo">428</span>}<a name="line.428"></a>




























































</pre>
</div>
</body>
</html>
