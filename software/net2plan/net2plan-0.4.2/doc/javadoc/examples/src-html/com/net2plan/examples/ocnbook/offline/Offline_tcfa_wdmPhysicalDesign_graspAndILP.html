<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="es">
<head>
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../../../stylesheet.css" title="Style">
</head>
<body>
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span>/*******************************************************************************<a name="line.1"></a>
<span class="sourceLineNo">002</span> * Copyright (c) 2016 Pablo Pavon Mari√±o.<a name="line.2"></a>
<span class="sourceLineNo">003</span> * All rights reserved. This program and the accompanying materials<a name="line.3"></a>
<span class="sourceLineNo">004</span> * are made available under the terms of the GNU Lesser Public License v2.1<a name="line.4"></a>
<span class="sourceLineNo">005</span> * which accompanies this distribution, and is available at<a name="line.5"></a>
<span class="sourceLineNo">006</span> * http://www.gnu.org/licenses/lgpl.html<a name="line.6"></a>
<span class="sourceLineNo">007</span> ******************************************************************************/<a name="line.7"></a>
<span class="sourceLineNo">008</span><a name="line.8"></a>
<span class="sourceLineNo">009</span><a name="line.9"></a>
<span class="sourceLineNo">010</span><a name="line.10"></a>
<span class="sourceLineNo">011</span><a name="line.11"></a>
<span class="sourceLineNo">012</span>package com.net2plan.examples.ocnbook.offline;<a name="line.12"></a>
<span class="sourceLineNo">013</span><a name="line.13"></a>
<span class="sourceLineNo">014</span>import java.io.File;<a name="line.14"></a>
<span class="sourceLineNo">015</span>import java.io.PrintWriter;<a name="line.15"></a>
<span class="sourceLineNo">016</span>import java.util.ArrayList;<a name="line.16"></a>
<span class="sourceLineNo">017</span>import java.util.Collection;<a name="line.17"></a>
<span class="sourceLineNo">018</span>import java.util.Collections;<a name="line.18"></a>
<span class="sourceLineNo">019</span>import java.util.HashMap;<a name="line.19"></a>
<span class="sourceLineNo">020</span>import java.util.HashSet;<a name="line.20"></a>
<span class="sourceLineNo">021</span>import java.util.LinkedList;<a name="line.21"></a>
<span class="sourceLineNo">022</span>import java.util.List;<a name="line.22"></a>
<span class="sourceLineNo">023</span>import java.util.Map;<a name="line.23"></a>
<span class="sourceLineNo">024</span>import java.util.Map.Entry;<a name="line.24"></a>
<span class="sourceLineNo">025</span>import java.util.Random;<a name="line.25"></a>
<span class="sourceLineNo">026</span>import java.util.Set;<a name="line.26"></a>
<span class="sourceLineNo">027</span><a name="line.27"></a>
<span class="sourceLineNo">028</span>import cern.colt.matrix.tdouble.DoubleFactory1D;<a name="line.28"></a>
<span class="sourceLineNo">029</span>import cern.colt.matrix.tdouble.DoubleFactory2D;<a name="line.29"></a>
<span class="sourceLineNo">030</span>import cern.colt.matrix.tdouble.DoubleMatrix1D;<a name="line.30"></a>
<span class="sourceLineNo">031</span>import cern.colt.matrix.tdouble.DoubleMatrix2D;<a name="line.31"></a>
<span class="sourceLineNo">032</span>import cern.jet.math.tdouble.DoubleFunctions;<a name="line.32"></a>
<span class="sourceLineNo">033</span><a name="line.33"></a>
<span class="sourceLineNo">034</span>import com.jom.DoubleMatrixND;<a name="line.34"></a>
<span class="sourceLineNo">035</span>import com.jom.OptimizationProblem;<a name="line.35"></a>
<span class="sourceLineNo">036</span>import com.net2plan.interfaces.networkDesign.Demand;<a name="line.36"></a>
<span class="sourceLineNo">037</span>import com.net2plan.interfaces.networkDesign.IAlgorithm;<a name="line.37"></a>
<span class="sourceLineNo">038</span>import com.net2plan.interfaces.networkDesign.Link;<a name="line.38"></a>
<span class="sourceLineNo">039</span>import com.net2plan.interfaces.networkDesign.Net2PlanException;<a name="line.39"></a>
<span class="sourceLineNo">040</span>import com.net2plan.interfaces.networkDesign.NetPlan;<a name="line.40"></a>
<span class="sourceLineNo">041</span>import com.net2plan.interfaces.networkDesign.NetworkElement;<a name="line.41"></a>
<span class="sourceLineNo">042</span>import com.net2plan.interfaces.networkDesign.Node;<a name="line.42"></a>
<span class="sourceLineNo">043</span>import com.net2plan.interfaces.networkDesign.ProtectionSegment;<a name="line.43"></a>
<span class="sourceLineNo">044</span>import com.net2plan.interfaces.networkDesign.Route;<a name="line.44"></a>
<span class="sourceLineNo">045</span>import com.net2plan.interfaces.networkDesign.SharedRiskGroup;<a name="line.45"></a>
<span class="sourceLineNo">046</span>import com.net2plan.utils.Constants.RoutingType;<a name="line.46"></a>
<span class="sourceLineNo">047</span>import com.net2plan.utils.Constants.SearchType;<a name="line.47"></a>
<span class="sourceLineNo">048</span>import com.net2plan.utils.DoubleUtils;<a name="line.48"></a>
<span class="sourceLineNo">049</span>import com.net2plan.utils.InputParameter;<a name="line.49"></a>
<span class="sourceLineNo">050</span>import com.net2plan.utils.IntUtils;<a name="line.50"></a>
<span class="sourceLineNo">051</span>import com.net2plan.utils.Pair;<a name="line.51"></a>
<span class="sourceLineNo">052</span>import com.net2plan.utils.Quadruple;<a name="line.52"></a>
<span class="sourceLineNo">053</span>import com.net2plan.utils.Triple;<a name="line.53"></a>
<span class="sourceLineNo">054</span><a name="line.54"></a>
<span class="sourceLineNo">055</span>/**<a name="line.55"></a>
<span class="sourceLineNo">056</span> * This algorithm is devoted to solve the several network planning problems in an optical WDM network (fiber placement, RWA, under different recovery schemes), appearing in the case study in the book section mentioned below. <a name="line.56"></a>
<span class="sourceLineNo">057</span> * @net2plan.description <a name="line.57"></a>
<span class="sourceLineNo">058</span> * @net2plan.keywords WDM, Topology assignment (TA), Flow assignment (FA), GRASP, JOM<a name="line.58"></a>
<span class="sourceLineNo">059</span> * @net2plan.ocnbooksections Section 12.10<a name="line.59"></a>
<span class="sourceLineNo">060</span> * @net2plan.inputParameters <a name="line.60"></a>
<span class="sourceLineNo">061</span> * @author Pablo Pavon-Marino<a name="line.61"></a>
<span class="sourceLineNo">062</span> */<a name="line.62"></a>
<span class="sourceLineNo">063</span>public class Offline_tcfa_wdmPhysicalDesign_graspAndILP implements IAlgorithm<a name="line.63"></a>
<span class="sourceLineNo">064</span>{<a name="line.64"></a>
<span class="sourceLineNo">065</span>        /* Stat */<a name="line.65"></a>
<span class="sourceLineNo">066</span>        private double stat_totalCost , stat_costinks , stat_costCirc , stat_costNodes;<a name="line.66"></a>
<span class="sourceLineNo">067</span>        private int stat_numLinks , stat_numCirc , stat_numNodesDeg2 , stat_numNodesDeg3;<a name="line.67"></a>
<span class="sourceLineNo">068</span>        private int stat_numItGRASP , stat_numLSIterationsReducingCost , stat_numSolverCalls , stat_numSolverCallsOk;<a name="line.68"></a>
<span class="sourceLineNo">069</span>        private double stat_totalTimeSecs , stat_totalTimeCreateProgramsSecs , stat_totalTimeSolverSecs;<a name="line.69"></a>
<span class="sourceLineNo">070</span>        <a name="line.70"></a>
<span class="sourceLineNo">071</span>        /* Parameters */<a name="line.71"></a>
<span class="sourceLineNo">072</span>        private DoubleMatrix1D linkCost_e;<a name="line.72"></a>
<span class="sourceLineNo">073</span>        private Random rng;<a name="line.73"></a>
<span class="sourceLineNo">074</span>        private NetPlan netPlan;<a name="line.74"></a>
<span class="sourceLineNo">075</span>        <a name="line.75"></a>
<span class="sourceLineNo">076</span>        /* Control */<a name="line.76"></a>
<span class="sourceLineNo">077</span>        private int Efm, N, nSRGs , D , R; <a name="line.77"></a>
<span class="sourceLineNo">078</span>        private DoubleMatrix1D numCircH_d; <a name="line.78"></a>
<span class="sourceLineNo">079</span>        private DoubleMatrix2D A_er , A_dr , A_rs , A_se , Aout_ne , Ain_ne, Abid_dd , Abid_rr , Abid_ee;<a name="line.79"></a>
<span class="sourceLineNo">080</span>        private Map&lt;Demand,Demand&gt; opposite_d;<a name="line.80"></a>
<span class="sourceLineNo">081</span>        private Map&lt;Route,Route&gt; opposite_r;<a name="line.81"></a>
<span class="sourceLineNo">082</span>        private int [][] routeList_d; // for each demand, the array of route ids assigned to it<a name="line.82"></a>
<span class="sourceLineNo">083</span>        private int [][] traversedLinks_r; // for each demand, the array of route ids assigned to it<a name="line.83"></a>
<span class="sourceLineNo">084</span><a name="line.84"></a>
<span class="sourceLineNo">085</span>        <a name="line.85"></a>
<span class="sourceLineNo">086</span>        private InputParameter algorithm_randomSeed = new InputParameter ("algorithm_randomSeed", (long) 1 , "Seed of the random number generator");<a name="line.86"></a>
<span class="sourceLineNo">087</span>        private InputParameter algorithm_outputFileNameRoot = new InputParameter ("algorithm_outputFileNameRoot", "tcfaWDM_graspAndILP" , "Root of the file name to be used in the output files. If blank, no output");<a name="line.87"></a>
<span class="sourceLineNo">088</span>        private InputParameter algorithm_maxExecutionTimeInSeconds = new InputParameter ("algorithm_maxExecutionTimeInSeconds", (double) 300 , "Algorithm maximum running time in seconds" , 0 , false , Double.MAX_VALUE , true);<a name="line.88"></a>
<span class="sourceLineNo">089</span>        private InputParameter tcfa_circuitCost = new InputParameter ("tcfa_circuitCost", (double) 3.0 , "Cost of each circuit" , 0 , true , Double.MAX_VALUE , true);<a name="line.89"></a>
<span class="sourceLineNo">090</span>        private InputParameter tcfa_circuitCapacity_Gbps = new InputParameter ("tcfa_circuitCapacity_Gbps", (double) 10.0 , "Capacity of an optical circuit" , 0 , true , Double.MAX_VALUE , true);<a name="line.90"></a>
<span class="sourceLineNo">091</span>        private InputParameter tcfa_srgType = new InputParameter ("tcfa_srgType" , "#select# perBidirectionalLinkBundle noFailure", "Determines how the SRGs are initialized. The design must be tolerant to single SRG failures");<a name="line.91"></a>
<span class="sourceLineNo">092</span>        private InputParameter tcfa_srgMttfPer1000Km_hrs = new InputParameter ("tcfa_srgMttfPer1000Km_hrs" , (double) 4380 , "Mean Time To Fail (MTTF) of the SRGs defined is this value multiplied by the link length divided by 1000",  0 , false , Double.MAX_VALUE , true);<a name="line.92"></a>
<span class="sourceLineNo">093</span>        private InputParameter tcfa_srgMttr_hrs = new InputParameter ("tcfa_srgMttr_hrs" , (double) 24 , "Mean Time To Repair (MTTR) of the SRGs",  0 , true , Double.MAX_VALUE , true);<a name="line.93"></a>
<span class="sourceLineNo">094</span>        private InputParameter tcfa_recoveryType = new InputParameter ("tcfa_recoveryType" , "#select# 1+1 shared restoration", "Determines the type of network recovery mechanism in the network.");<a name="line.94"></a>
<span class="sourceLineNo">095</span>        private InputParameter tcfa_maxPathLengthInKm = new InputParameter ("tcfa_maxPathLengthInKm" , (double) 10000 , "Maximum length that a lightpath can have",  0 , true , Double.MAX_VALUE , true);<a name="line.95"></a>
<span class="sourceLineNo">096</span>        private InputParameter tcfa_maxPathNumberOfHops = new InputParameter ("tcfa_maxPathNumberOfHops" , (int) 4 , "Maximum number of hops that a lightpath can make",  1 , Integer.MAX_VALUE);<a name="line.96"></a>
<span class="sourceLineNo">097</span>        private InputParameter tcfa_maxNumberPathsPerDemand = new InputParameter ("tcfa_maxNumberPathsPerDemand" , (int) 200 , "Maximum number of paths in the candidate path list, for each demand",  1 , Integer.MAX_VALUE);<a name="line.97"></a>
<span class="sourceLineNo">098</span>        private InputParameter tcfa_linkCapacity_numCirc = new InputParameter ("tcfa_linkCapacity_numCirc" , (int) 80 , "Number of wavelengths available per fiber",  1 , Integer.MAX_VALUE);<a name="line.98"></a>
<span class="sourceLineNo">099</span>        private InputParameter tcfa_linkCostPerKm = new InputParameter ("tcfa_linkCostPerKm" , (double) 0.4 , "Cost of one km of optical fiber",  0 , true  , Double.MAX_VALUE , true);<a name="line.99"></a>
<span class="sourceLineNo">100</span>        private InputParameter tcfa_costNodeDegree2 = new InputParameter ("tcfa_costNodeDegree2" , (double) 4.0 , "Cost of one OADM of degree lower or equal than two",  0 , true  , Double.MAX_VALUE , true);<a name="line.100"></a>
<span class="sourceLineNo">101</span>        private InputParameter tcfa_costNodeDegreeHigherThan2 = new InputParameter ("tcfa_costNodeDegreeHigherThan2" , (double) 4.0 , "Cost of one OADM of degree higher than two",  0 , true  , Double.MAX_VALUE , true);<a name="line.101"></a>
<span class="sourceLineNo">102</span>        private InputParameter tcfa_networkDiameterKmToNormalize = new InputParameter ("tcfa_networkDiameterKmToNormalize" , (double) 4500 , "The link lengths are normalized so the longest link has this value",  0 , true  , Double.MAX_VALUE , true);<a name="line.102"></a>
<span class="sourceLineNo">103</span>        private InputParameter tcfa_maxNumIterations = new InputParameter ("tcfa_maxNumIterations", (int) 10000 , "Maximum number of iterations" , 1 , Integer.MAX_VALUE);<a name="line.103"></a>
<span class="sourceLineNo">104</span>        private InputParameter algorithm_solverName = new InputParameter ("solverName", "#select# glpk ipopt xpress cplex", "The solver name to be used by JOM. GLPK and IPOPT are free, XPRESS and CPLEX commercial. GLPK, XPRESS and CPLEX solve linear problems w/w.o integer contraints. IPOPT is can solve nonlinear problems (if convex, returns global optimum), but cannot handle integer constraints");<a name="line.104"></a>
<span class="sourceLineNo">105</span>        private InputParameter algorithm_solverLibraryName = new InputParameter ("solverLibraryName", "", "The solver library full or relative path, to be used by JOM. Leave blank to use JOM default.");<a name="line.105"></a>
<span class="sourceLineNo">106</span>        private InputParameter algorithm_maxSolverTimeInSeconds = new InputParameter ("maxSolverTimeInSeconds", (double) 2 , "Maximum time granted to the solver in to solve each problem instance. If this time expires, the solver returns the best solution found so far (if a feasible solution is found)");<a name="line.106"></a>
<span class="sourceLineNo">107</span>        private InputParameter tcfa_bidirectionalLinks = new InputParameter ("tcfa_bidirectionalLinks", true , "If true, the topology of fibers deployed is constrained to be bidirectional (the same number of fibers in both directions)");<a name="line.107"></a>
<span class="sourceLineNo">108</span><a name="line.108"></a>
<span class="sourceLineNo">109</span>        @Override<a name="line.109"></a>
<span class="sourceLineNo">110</span>        public String executeAlgorithm(NetPlan netPlan, Map&lt;String, String&gt; algorithmParameters, Map&lt;String, String&gt; net2planParameters)<a name="line.110"></a>
<span class="sourceLineNo">111</span>        {<a name="line.111"></a>
<span class="sourceLineNo">112</span>                /* Initialize all InputParameter objects defined in this object (this uses Java reflection) */<a name="line.112"></a>
<span class="sourceLineNo">113</span>                InputParameter.initializeAllInputParameterFieldsOfObject(this, algorithmParameters);<a name="line.113"></a>
<span class="sourceLineNo">114</span>                if (netPlan.getNumberOfNodes() == 0) throw new Net2PlanException ("The input design has no nodes");<a name="line.114"></a>
<span class="sourceLineNo">115</span>                <a name="line.115"></a>
<span class="sourceLineNo">116</span>                <a name="line.116"></a>
<span class="sourceLineNo">117</span>                try{ <a name="line.117"></a>
<span class="sourceLineNo">118</span>                this.netPlan = netPlan;<a name="line.118"></a>
<span class="sourceLineNo">119</span>                /* Initializations */<a name="line.119"></a>
<span class="sourceLineNo">120</span><a name="line.120"></a>
<span class="sourceLineNo">121</span>                netPlan.removeAllLinks(); netPlan.setRoutingType(RoutingType.SOURCE_ROUTING);<a name="line.121"></a>
<span class="sourceLineNo">122</span>                this.N = netPlan.getNumberOfNodes();<a name="line.122"></a>
<span class="sourceLineNo">123</span>                this.rng = new Random (algorithm_randomSeed.getLong ());<a name="line.123"></a>
<span class="sourceLineNo">124</span>                <a name="line.124"></a>
<span class="sourceLineNo">125</span>                /* Initialize links */<a name="line.125"></a>
<span class="sourceLineNo">126</span>                for (Node n1 : netPlan.getNodes()) for (Node n2 : netPlan.getNodes()) if (n1 != n2) netPlan.addLink(n1, n2, 0.01, netPlan.getNodePairEuclideanDistance(n1, n2), 200000 , null);<a name="line.126"></a>
<span class="sourceLineNo">127</span>                final double linkLengthKmFromEuclideanDistanceFactor = tcfa_networkDiameterKmToNormalize.getDouble() / netPlan.getVectorLinkLengthInKm().getMaxLocation() [0];<a name="line.127"></a>
<span class="sourceLineNo">128</span>                for (Link e : netPlan.getLinks()) e.setLengthInKm(e.getLengthInKm() * linkLengthKmFromEuclideanDistanceFactor);<a name="line.128"></a>
<span class="sourceLineNo">129</span>                this.Efm = netPlan.getNumberOfLinks(); if (Efm != N*(N-1)) throw new RuntimeException ("Bad, Efm" + Efm + ", N: " + N);<a name="line.129"></a>
<span class="sourceLineNo">130</span>                this.linkCost_e = DoubleFactory1D.dense.make(Efm); for (Link e : netPlan.getLinks ()) linkCost_e.set(e.getIndex () , tcfa_linkCostPerKm.getDouble() * e.getLengthInKm());<a name="line.130"></a>
<span class="sourceLineNo">131</span>                <a name="line.131"></a>
<span class="sourceLineNo">132</span>                /* If there is no traffic, create uniform traffic matrix */<a name="line.132"></a>
<span class="sourceLineNo">133</span>                if (netPlan.getNumberOfDemands() == 0)<a name="line.133"></a>
<span class="sourceLineNo">134</span>                        for (Node n1 : netPlan.getNodes()) for (Node n2 : netPlan.getNodes()) if (n1 != n2) netPlan.addDemand(n1, n2, tcfa_circuitCapacity_Gbps.getDouble(), null);<a name="line.134"></a>
<span class="sourceLineNo">135</span><a name="line.135"></a>
<span class="sourceLineNo">136</span>                <a name="line.136"></a>
<span class="sourceLineNo">137</span>                /* Convert the demand offered traffic in the upper multiple of circuit capacity */<a name="line.137"></a>
<span class="sourceLineNo">138</span>                DoubleMatrix2D trafficMatrix = netPlan.getMatrixNode2NodeOfferedTraffic();<a name="line.138"></a>
<span class="sourceLineNo">139</span>                netPlan.removeAllDemands();<a name="line.139"></a>
<span class="sourceLineNo">140</span>                for (Node n1 : netPlan.getNodes()) for (Node n2 : netPlan.getNodes()) if (n1.getIndex () &gt; n2.getIndex ())<a name="line.140"></a>
<span class="sourceLineNo">141</span>                {<a name="line.141"></a>
<span class="sourceLineNo">142</span>                        final double maxTrafficBidir = Math.max(trafficMatrix.get(n1.getIndex (), n2.getIndex ()), trafficMatrix.get(n2.getIndex (), n1.getIndex ()));<a name="line.142"></a>
<span class="sourceLineNo">143</span>                        netPlan.addDemand(n1, n2, tcfa_circuitCapacity_Gbps.getDouble() * Math.ceil(maxTrafficBidir / tcfa_circuitCapacity_Gbps.getDouble()) , null); <a name="line.143"></a>
<span class="sourceLineNo">144</span>                        netPlan.addDemand(n2, n1, tcfa_circuitCapacity_Gbps.getDouble() * Math.ceil(maxTrafficBidir / tcfa_circuitCapacity_Gbps.getDouble()) , null); <a name="line.144"></a>
<span class="sourceLineNo">145</span>                }<a name="line.145"></a>
<span class="sourceLineNo">146</span>                        <a name="line.146"></a>
<span class="sourceLineNo">147</span>                /* If 1+1 then decouple demands in one per channel */<a name="line.147"></a>
<span class="sourceLineNo">148</span>                if (tcfa_recoveryType.getString ().equals("1+1"))<a name="line.148"></a>
<span class="sourceLineNo">149</span>                {<a name="line.149"></a>
<span class="sourceLineNo">150</span>                        NetPlan npcopy = netPlan.copy();<a name="line.150"></a>
<span class="sourceLineNo">151</span>                        netPlan.removeAllDemands();<a name="line.151"></a>
<span class="sourceLineNo">152</span>                        for (Demand d : npcopy.getDemands())<a name="line.152"></a>
<span class="sourceLineNo">153</span>                        {<a name="line.153"></a>
<span class="sourceLineNo">154</span>                                final int numChannels = (int) Math.round (d.getOfferedTraffic() / tcfa_circuitCapacity_Gbps.getDouble ());<a name="line.154"></a>
<span class="sourceLineNo">155</span>                                for (int cont = 0 ; cont &lt; numChannels ; cont ++) netPlan.addDemand(netPlan.getNodeFromId (d.getIngressNode().getId ()), netPlan.getNodeFromId (d.getEgressNode().getId ()), tcfa_circuitCapacity_Gbps.getDouble () , d.getAttributes());<a name="line.155"></a>
<span class="sourceLineNo">156</span>                        }<a name="line.156"></a>
<span class="sourceLineNo">157</span>                }<a name="line.157"></a>
<span class="sourceLineNo">158</span><a name="line.158"></a>
<span class="sourceLineNo">159</span>                /* Initialize routes and demands to make it bidirectional */<a name="line.159"></a>
<span class="sourceLineNo">160</span>                Pair&lt;Map&lt;Demand,Demand&gt;,Map&lt;Route,Route&gt;&gt; pair = initializeNetPlanLinksBidirDemandsAndRoutes (netPlan);<a name="line.160"></a>
<span class="sourceLineNo">161</span>                this.opposite_d = pair.getFirst();<a name="line.161"></a>
<span class="sourceLineNo">162</span>                this.opposite_r = pair.getSecond();<a name="line.162"></a>
<span class="sourceLineNo">163</span><a name="line.163"></a>
<span class="sourceLineNo">164</span>                /* Initialize demand info */<a name="line.164"></a>
<span class="sourceLineNo">165</span>                this.D = netPlan.getNumberOfDemands();<a name="line.165"></a>
<span class="sourceLineNo">166</span>                this.numCircH_d = netPlan.getVectorDemandOfferedTraffic().assign(DoubleFunctions.div(this.tcfa_circuitCapacity_Gbps.getDouble ())).assign(DoubleFunctions.rint);<a name="line.166"></a>
<span class="sourceLineNo">167</span>                System.out.println("Total number of circuits to establish: " + numCircH_d.zSum());<a name="line.167"></a>
<span class="sourceLineNo">168</span>                <a name="line.168"></a>
<span class="sourceLineNo">169</span>                //if (1==1) throw new RuntimeException ("Stop");<a name="line.169"></a>
<span class="sourceLineNo">170</span>                this.R = netPlan.getNumberOfRoutes();<a name="line.170"></a>
<span class="sourceLineNo">171</span>                //System.out.println ("numCircH_d: " + numCircH_d);<a name="line.171"></a>
<span class="sourceLineNo">172</span><a name="line.172"></a>
<span class="sourceLineNo">173</span>                /* Initialize SRG information */<a name="line.173"></a>
<span class="sourceLineNo">174</span>                initializeSRGs(netPlan);<a name="line.174"></a>
<span class="sourceLineNo">175</span>                this.nSRGs = netPlan.getNumberOfSRGs();<a name="line.175"></a>
<span class="sourceLineNo">176</span>                this.routeList_d = new int [D][]; for (Demand d : netPlan.getDemands ()) routeList_d [d.getIndex ()] = getIndexes (d.getRoutes ());<a name="line.176"></a>
<span class="sourceLineNo">177</span>                this.traversedLinks_r = new int [R][]; for (Route r : netPlan.getRoutes ()) traversedLinks_r [r.getIndex ()] = getIndexes (r.getSeqLinksRealPath());<a name="line.177"></a>
<span class="sourceLineNo">178</span>                <a name="line.178"></a>
<span class="sourceLineNo">179</span>                <a name="line.179"></a>
<span class="sourceLineNo">180</span>                /* Initialize aux arrays for speed-up */<a name="line.180"></a>
<span class="sourceLineNo">181</span>                this.A_dr = netPlan.getMatrixDemand2RouteAssignment();<a name="line.181"></a>
<span class="sourceLineNo">182</span>                for (Demand d : netPlan.getDemands ()) if (d.getRoutes().isEmpty()) throw new Net2PlanException ("A demand has no assigned routes");<a name="line.182"></a>
<span class="sourceLineNo">183</span>                this.A_er = netPlan.getMatrixLink2RouteAssignment();<a name="line.183"></a>
<span class="sourceLineNo">184</span>                this.A_se = DoubleFactory2D.dense.make(1 + nSRGs , Efm , 1.0); // 1 if link OK, 0 if fails<a name="line.184"></a>
<span class="sourceLineNo">185</span>                for (int contSRG = 0 ; contSRG &lt; nSRGs ; contSRG ++)<a name="line.185"></a>
<span class="sourceLineNo">186</span>                        for (Link e : netPlan.getSRG (contSRG).getLinks())<a name="line.186"></a>
<span class="sourceLineNo">187</span>                                A_se.set(contSRG+1 , e.getIndex () , 0.0);<a name="line.187"></a>
<span class="sourceLineNo">188</span>                this.A_rs = DoubleFactory2D.dense.make(R , 1 + nSRGs , 1.0); // 1 if link OK, 0 if fails<a name="line.188"></a>
<span class="sourceLineNo">189</span>                for (Route r : netPlan.getRoutes ()) for (Link e : r.getSeqLinksRealPath()) for (SharedRiskGroup srg : e.getSRGs())<a name="line.189"></a>
<span class="sourceLineNo">190</span>                                        A_rs.set(r.getIndex (),1+srg.getIndex () , 0.0);<a name="line.190"></a>
<span class="sourceLineNo">191</span><a name="line.191"></a>
<span class="sourceLineNo">192</span>                /* Check if the problem may have a solution: demands have at least one path in any failure state  */<a name="line.192"></a>
<span class="sourceLineNo">193</span>                if (A_dr.zMult(A_rs, null).getMinLocation() [0] == 0) { System.out.println("A_dr.zMult(A_rs, null): " + A_dr.zMult(A_rs, null)); throw new Net2PlanException ("Some demands cannot be routed in some failure state. We need more paths! (e.g. extend the path reach)"); }<a name="line.193"></a>
<span class="sourceLineNo">194</span><a name="line.194"></a>
<span class="sourceLineNo">195</span>                this.Aout_ne = netPlan.getMatrixNodeLinkOutgoingIncidence();<a name="line.195"></a>
<span class="sourceLineNo">196</span>                this.Ain_ne = netPlan.getMatrixNodeLinkIncomingIncidence(); <a name="line.196"></a>
<span class="sourceLineNo">197</span>                this.Abid_dd = DoubleFactory2D.sparse.make(D,D); for (Entry&lt;Demand,Demand&gt; entry : opposite_d.entrySet()) { Abid_dd.set(entry.getKey().getIndex (), entry.getValue().getIndex (), 1.0); Abid_dd.set(entry.getValue().getIndex (), entry.getKey().getIndex (), 1.0); } <a name="line.197"></a>
<span class="sourceLineNo">198</span>                this.Abid_rr = DoubleFactory2D.sparse.make(R,R); for (Entry&lt;Route,Route&gt; entry : opposite_r.entrySet()) { Abid_rr.set(entry.getKey().getIndex (), entry.getValue().getIndex (), 1.0); Abid_rr.set(entry.getValue().getIndex (), entry.getKey().getIndex (), 1.0); } <a name="line.198"></a>
<span class="sourceLineNo">199</span>                this.Abid_ee = DoubleFactory2D.sparse.make(Efm,Efm); for (Link e : netPlan.getLinks ()) { Abid_ee.set(e.getIndex (), oppositeLink(e).getIndex (), 1.0);  Abid_ee.set(oppositeLink(e).getIndex (), e.getIndex (), 1.0); }<a name="line.199"></a>
<span class="sourceLineNo">200</span>                <a name="line.200"></a>
<span class="sourceLineNo">201</span>                final long algorithmInitialtime = System.nanoTime();<a name="line.201"></a>
<span class="sourceLineNo">202</span>                final long algorithmEndtime = algorithmInitialtime + (long) (algorithm_maxExecutionTimeInSeconds.getDouble() * 1E9);<a name="line.202"></a>
<span class="sourceLineNo">203</span><a name="line.203"></a>
<span class="sourceLineNo">204</span>                /* Up stage */<a name="line.204"></a>
<span class="sourceLineNo">205</span>                ArrayList&lt;Integer&gt; shuffledDemands = new ArrayList&lt;Integer&gt; (D); for (int d = 0 ; d &lt; D ; d ++) shuffledDemands.add(d);<a name="line.205"></a>
<span class="sourceLineNo">206</span>                Collections.shuffle(shuffledDemands , rng);<a name="line.206"></a>
<span class="sourceLineNo">207</span>                if (tcfa_recoveryType.getString ().equals("shared"))<a name="line.207"></a>
<span class="sourceLineNo">208</span>                {<a name="line.208"></a>
<span class="sourceLineNo">209</span>                        DoubleMatrix1D best_xr = null; DoubleMatrix1D best_pe = null; double bestCost = Double.MAX_VALUE;<a name="line.209"></a>
<span class="sourceLineNo">210</span>                        int iterationCounter = 0;<a name="line.210"></a>
<span class="sourceLineNo">211</span>                        while ((System.nanoTime() &lt; algorithmEndtime) &amp;&amp; (iterationCounter &lt; tcfa_maxNumIterations.getInt ()))<a name="line.211"></a>
<span class="sourceLineNo">212</span>                        {<a name="line.212"></a>
<span class="sourceLineNo">213</span>                                DoubleMatrix1D thisIt_xr = greedyAndLocalSearch_shared(algorithmEndtime , netPlan);<a name="line.213"></a>
<span class="sourceLineNo">214</span>                                DoubleMatrix1D thisIt_pe = A_er.zMult(thisIt_xr, null); thisIt_pe.assign(DoubleFunctions.div(tcfa_linkCapacity_numCirc.getInt ())).assign(DoubleFunctions.ceil);<a name="line.214"></a>
<span class="sourceLineNo">215</span>                                double thisItCost = computeCost_shared(thisIt_xr, thisIt_pe);<a name="line.215"></a>
<span class="sourceLineNo">216</span>                                if (thisItCost &lt; bestCost) { best_xr = thisIt_xr; best_pe = thisIt_pe; bestCost = thisItCost; }<a name="line.216"></a>
<span class="sourceLineNo">217</span>                                iterationCounter ++;<a name="line.217"></a>
<span class="sourceLineNo">218</span>                        }<a name="line.218"></a>
<span class="sourceLineNo">219</span>                        stat_numItGRASP = iterationCounter;<a name="line.219"></a>
<span class="sourceLineNo">220</span>                        for (Route r : netPlan.getRoutes ()) r.setCarriedTraffic(tcfa_circuitCapacity_Gbps.getDouble () * best_xr.get(r.getIndex ()) , tcfa_circuitCapacity_Gbps.getDouble () * best_xr.get(r.getIndex ()));<a name="line.220"></a>
<span class="sourceLineNo">221</span>                        for (Link e : netPlan.getLinks ()) e.setCapacity(tcfa_linkCapacity_numCirc.getInt () * tcfa_circuitCapacity_Gbps.getDouble () * best_pe.get(e.getIndex()));<a name="line.221"></a>
<span class="sourceLineNo">222</span>                } else if (tcfa_recoveryType.getString ().equals("1+1"))<a name="line.222"></a>
<span class="sourceLineNo">223</span>                {<a name="line.223"></a>
<span class="sourceLineNo">224</span>                        DoubleMatrix1D best_xr = null; DoubleMatrix1D best_x2r = null; DoubleMatrix1D best_pe = null; double bestCost = Double.MAX_VALUE;<a name="line.224"></a>
<span class="sourceLineNo">225</span>                        int iterationCounter = 0;<a name="line.225"></a>
<span class="sourceLineNo">226</span>                        while ((System.nanoTime() &lt; algorithmEndtime) &amp;&amp; (iterationCounter &lt; tcfa_maxNumIterations.getInt ()))<a name="line.226"></a>
<span class="sourceLineNo">227</span>                        {<a name="line.227"></a>
<span class="sourceLineNo">228</span>                                Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt; thisItSolution = greedyAndLocalSearch_11(algorithmEndtime , netPlan);<a name="line.228"></a>
<span class="sourceLineNo">229</span>                                DoubleMatrix1D thisIt_xr = thisItSolution.getFirst();   <a name="line.229"></a>
<span class="sourceLineNo">230</span>                                DoubleMatrix1D thisIt_x2r = thisItSolution.getSecond();<a name="line.230"></a>
<span class="sourceLineNo">231</span>                                DoubleMatrix1D thisIt_pe = computePe_11(thisIt_xr, thisIt_x2r);<a name="line.231"></a>
<span class="sourceLineNo">232</span>                                double thisItCost = computeCost_11(thisIt_xr, thisIt_x2r , thisIt_pe);<a name="line.232"></a>
<span class="sourceLineNo">233</span>                                if (thisItCost &lt; bestCost) { best_xr = thisIt_xr; best_x2r = thisIt_x2r; best_pe = thisIt_pe; bestCost = thisItCost; }<a name="line.233"></a>
<span class="sourceLineNo">234</span>                                iterationCounter ++;<a name="line.234"></a>
<span class="sourceLineNo">235</span>                        }<a name="line.235"></a>
<span class="sourceLineNo">236</span>                        stat_numItGRASP = iterationCounter;<a name="line.236"></a>
<span class="sourceLineNo">237</span>                        for (Demand d : netPlan.getDemands ())<a name="line.237"></a>
<span class="sourceLineNo">238</span>                        {<a name="line.238"></a>
<span class="sourceLineNo">239</span>                                if (Math.abs(best_xr.viewSelection(routeList_d [d.getIndex ()]).zSum() - 1) &gt; 1E-3) throw new RuntimeException ("Bad");<a name="line.239"></a>
<span class="sourceLineNo">240</span>                                if (Math.abs(best_x2r.viewSelection(routeList_d [d.getIndex ()]).zSum() - 1) &gt; 1E-3) throw new RuntimeException ("Bad");<a name="line.240"></a>
<span class="sourceLineNo">241</span>                                Route primaryRoute = null; ProtectionSegment protSegment = null;  <a name="line.241"></a>
<span class="sourceLineNo">242</span>                                for (Route r : d.getRoutes ()) if (Math.abs(best_xr.get(r.getIndex ()) - 1) &lt;= 1e-3) { primaryRoute = r; primaryRoute.setCarriedTraffic(tcfa_circuitCapacity_Gbps.getDouble () , tcfa_circuitCapacity_Gbps.getDouble ()); break; }<a name="line.242"></a>
<span class="sourceLineNo">243</span>                                for (Route r : d.getRoutes ()) if (Math.abs(best_x2r.get(r.getIndex ()) - 1) &lt;= 1e-3) { protSegment = netPlan.addProtectionSegment(r.getSeqLinksRealPath() , tcfa_circuitCapacity_Gbps.getDouble () , null); break; }<a name="line.243"></a>
<span class="sourceLineNo">244</span>                                primaryRoute.addProtectionSegment(protSegment);<a name="line.244"></a>
<span class="sourceLineNo">245</span>                        }<a name="line.245"></a>
<span class="sourceLineNo">246</span>                        for (Link e : netPlan.getLinks ()) e.setCapacity(tcfa_linkCapacity_numCirc.getInt () * tcfa_circuitCapacity_Gbps.getDouble () * best_pe.get(e.getIndex()));<a name="line.246"></a>
<span class="sourceLineNo">247</span>                <a name="line.247"></a>
<span class="sourceLineNo">248</span>                } else if (tcfa_recoveryType.getString ().equals("restoration"))<a name="line.248"></a>
<span class="sourceLineNo">249</span>                {<a name="line.249"></a>
<span class="sourceLineNo">250</span>                        DoubleMatrix2D best_xrs = null; DoubleMatrix1D best_pe = null; double bestCost = Double.MAX_VALUE;<a name="line.250"></a>
<span class="sourceLineNo">251</span>                        int iterationCounter = 0;<a name="line.251"></a>
<span class="sourceLineNo">252</span>                        while ((System.nanoTime() &lt; algorithmEndtime) &amp;&amp; (iterationCounter &lt; tcfa_maxNumIterations.getInt ()))<a name="line.252"></a>
<span class="sourceLineNo">253</span>                        {<a name="line.253"></a>
<span class="sourceLineNo">254</span>                                DoubleMatrix2D thisIt_xrs = greedyAndLocalSearch_restoration(algorithmEndtime , netPlan);<a name="line.254"></a>
<span class="sourceLineNo">255</span>                                DoubleMatrix1D thisIt_pe = computePe_restoration (thisIt_xrs); <a name="line.255"></a>
<span class="sourceLineNo">256</span>                                double thisItCost = computeCost_shared(thisIt_xrs.viewColumn(0), thisIt_pe);<a name="line.256"></a>
<span class="sourceLineNo">257</span>                                if (thisItCost &lt; bestCost) { best_xrs = thisIt_xrs; best_pe = thisIt_pe; bestCost = thisItCost; }<a name="line.257"></a>
<span class="sourceLineNo">258</span>                                iterationCounter ++;<a name="line.258"></a>
<span class="sourceLineNo">259</span>                        }<a name="line.259"></a>
<span class="sourceLineNo">260</span>                        stat_numItGRASP = iterationCounter;<a name="line.260"></a>
<span class="sourceLineNo">261</span>                        for (Route r : netPlan.getRoutes ()) r.setCarriedTraffic(tcfa_circuitCapacity_Gbps.getDouble () * best_xrs.get(r.getIndex (),0) , tcfa_circuitCapacity_Gbps.getDouble () * best_xrs.get(r.getIndex (),0));<a name="line.261"></a>
<span class="sourceLineNo">262</span>                        for (Link e : netPlan.getLinks ()) e.setCapacity(tcfa_linkCapacity_numCirc.getInt () * tcfa_circuitCapacity_Gbps.getDouble () * best_pe.get(e.getIndex()));<a name="line.262"></a>
<span class="sourceLineNo">263</span>                } else throw new RuntimeException ("Bad");              <a name="line.263"></a>
<span class="sourceLineNo">264</span>                <a name="line.264"></a>
<span class="sourceLineNo">265</span>                /* Remove unused routes and links */<a name="line.265"></a>
<span class="sourceLineNo">266</span>                for (Route r : new HashSet&lt;Route&gt;(netPlan.getRoutes())) if (r.getCarriedTraffic() == 0) r.remove();<a name="line.266"></a>
<span class="sourceLineNo">267</span>                for (Link e : new HashSet&lt;Link&gt;(netPlan.getLinks())) if (e.getCapacity() == 0) e.remove();<a name="line.267"></a>
<span class="sourceLineNo">268</span>                <a name="line.268"></a>
<span class="sourceLineNo">269</span>                Quadruple&lt;Double,Double,Double,Double&gt; q = computeCost (netPlan);<a name="line.269"></a>
<span class="sourceLineNo">270</span>                stat_totalCost = q.getFirst();<a name="line.270"></a>
<span class="sourceLineNo">271</span>                stat_costinks = q.getSecond();<a name="line.271"></a>
<span class="sourceLineNo">272</span>                stat_costNodes = q.getThird();<a name="line.272"></a>
<span class="sourceLineNo">273</span>                stat_costCirc = q.getFourth();<a name="line.273"></a>
<span class="sourceLineNo">274</span>                stat_numLinks = (int) (netPlan.getVectorLinkCapacity().zSum () / (tcfa_linkCapacity_numCirc.getInt () * tcfa_circuitCapacity_Gbps.getDouble ())); <a name="line.274"></a>
<span class="sourceLineNo">275</span>                stat_numCirc = (int) Math.round(netPlan.getDemandTotalCarriedTraffic() / tcfa_circuitCapacity_Gbps.getDouble ()); if (tcfa_recoveryType.getString ().equals("1+1")) stat_numCirc *=2; <a name="line.275"></a>
<span class="sourceLineNo">276</span>                for (Node n : netPlan.getNodes()) if (n.getOutgoingLinks().size() &gt; 2) stat_numNodesDeg3 ++; else stat_numNodesDeg2 ++;<a name="line.276"></a>
<span class="sourceLineNo">277</span>                stat_totalTimeSecs = (System.nanoTime() - algorithmInitialtime)*1e-9;<a name="line.277"></a>
<span class="sourceLineNo">278</span>                checkSolution (netPlan);<a name="line.278"></a>
<span class="sourceLineNo">279</span><a name="line.279"></a>
<span class="sourceLineNo">280</span>                double averageLinkUtilization = netPlan.getVectorLinkUtilizationIncludingProtectionSegments().zSum() / stat_numLinks;<a name="line.280"></a>
<span class="sourceLineNo">281</span>                final String fileNameStem = algorithm_outputFileNameRoot.getString() + "_" + tcfa_srgType.getString() + "_c" + tcfa_circuitCapacity_Gbps.getDouble () + "_t" + algorithm_maxExecutionTimeInSeconds.getDouble() + "_r" + tcfa_recoveryType.getString ();  <a name="line.281"></a>
<span class="sourceLineNo">282</span>                try <a name="line.282"></a>
<span class="sourceLineNo">283</span>                {<a name="line.283"></a>
<span class="sourceLineNo">284</span>                        PrintWriter pw = new PrintWriter (new File (fileNameStem + "_allResults.txt"));<a name="line.284"></a>
<span class="sourceLineNo">285</span>                        pw.println(stat_totalCost );<a name="line.285"></a>
<span class="sourceLineNo">286</span>                        pw.println( stat_costinks );<a name="line.286"></a>
<span class="sourceLineNo">287</span>                        pw.println( stat_costNodes );<a name="line.287"></a>
<span class="sourceLineNo">288</span>                        pw.println( stat_costCirc );<a name="line.288"></a>
<span class="sourceLineNo">289</span>                        pw.println( stat_numLinks );<a name="line.289"></a>
<span class="sourceLineNo">290</span>                        pw.println( stat_numCirc );<a name="line.290"></a>
<span class="sourceLineNo">291</span>                        pw.println( stat_numNodesDeg2 );<a name="line.291"></a>
<span class="sourceLineNo">292</span>                        pw.println( stat_numNodesDeg3 );<a name="line.292"></a>
<span class="sourceLineNo">293</span>                        pw.println( stat_numItGRASP );<a name="line.293"></a>
<span class="sourceLineNo">294</span>                        pw.println( stat_numLSIterationsReducingCost );<a name="line.294"></a>
<span class="sourceLineNo">295</span>                        pw.println( stat_numSolverCalls );<a name="line.295"></a>
<span class="sourceLineNo">296</span>                        pw.println( stat_numSolverCallsOk );<a name="line.296"></a>
<span class="sourceLineNo">297</span>                        pw.println( stat_totalTimeSecs );<a name="line.297"></a>
<span class="sourceLineNo">298</span>                        pw.println( stat_totalTimeCreateProgramsSecs );<a name="line.298"></a>
<span class="sourceLineNo">299</span>                        pw.println( stat_totalTimeSolverSecs );<a name="line.299"></a>
<span class="sourceLineNo">300</span>                        pw.println( averageLinkUtilization );<a name="line.300"></a>
<span class="sourceLineNo">301</span>                        pw.close ();<a name="line.301"></a>
<span class="sourceLineNo">302</span>                } catch (Exception e) { e.printStackTrace(); throw new RuntimeException ("Not possible to write in File " + fileNameStem  + "_allResults.txt"); } <a name="line.302"></a>
<span class="sourceLineNo">303</span><a name="line.303"></a>
<span class="sourceLineNo">304</span><a name="line.304"></a>
<span class="sourceLineNo">305</span>                netPlan.setAttribute("stat_totalCost", ""+stat_totalCost);<a name="line.305"></a>
<span class="sourceLineNo">306</span>                netPlan.setAttribute("stat_costinks", ""+stat_costinks);<a name="line.306"></a>
<span class="sourceLineNo">307</span>                netPlan.setAttribute("stat_costNodes", ""+stat_costNodes);<a name="line.307"></a>
<span class="sourceLineNo">308</span>                netPlan.setAttribute("stat_costCirc", ""+stat_costCirc);<a name="line.308"></a>
<span class="sourceLineNo">309</span>                netPlan.setAttribute("stat_numLinks", ""+stat_numLinks);<a name="line.309"></a>
<span class="sourceLineNo">310</span>                netPlan.setAttribute("stat_numCirc", ""+stat_numCirc);<a name="line.310"></a>
<span class="sourceLineNo">311</span>                netPlan.setAttribute("stat_numNodesDeg2", ""+stat_numNodesDeg2);<a name="line.311"></a>
<span class="sourceLineNo">312</span>                netPlan.setAttribute("stat_numNodesDeg3", ""+stat_numNodesDeg3);<a name="line.312"></a>
<span class="sourceLineNo">313</span>                netPlan.setAttribute("stat_numItGRASP", ""+stat_numItGRASP);<a name="line.313"></a>
<span class="sourceLineNo">314</span>                netPlan.setAttribute("stat_numLSIterationsReducingCost", ""+stat_numLSIterationsReducingCost);<a name="line.314"></a>
<span class="sourceLineNo">315</span>                netPlan.setAttribute("stat_numSolverCalls", ""+stat_numSolverCalls);<a name="line.315"></a>
<span class="sourceLineNo">316</span>                netPlan.setAttribute("stat_numSolverCallsOk", ""+stat_numSolverCallsOk);<a name="line.316"></a>
<span class="sourceLineNo">317</span>                netPlan.setAttribute("stat_totalTimeSecs", ""+stat_totalTimeSecs);<a name="line.317"></a>
<span class="sourceLineNo">318</span>                netPlan.setAttribute("stat_totalTimeCreateProgramsSecs", ""+stat_totalTimeCreateProgramsSecs);<a name="line.318"></a>
<span class="sourceLineNo">319</span>                netPlan.setAttribute("stat_totalTimeSolverSecs", ""+stat_totalTimeSolverSecs);<a name="line.319"></a>
<span class="sourceLineNo">320</span><a name="line.320"></a>
<span class="sourceLineNo">321</span>                netPlan.saveToFile(new File (fileNameStem + ".n2p"));<a name="line.321"></a>
<span class="sourceLineNo">322</span><a name="line.322"></a>
<span class="sourceLineNo">323</span>//              if (netPlan.getDemandTotalBlockedTraffic() &gt; 1E-3) throw new RuntimeException ("Bad");<a name="line.323"></a>
<span class="sourceLineNo">324</span>//              if (netPlan.getLinksOversubscribed().size() &gt; 0) throw new RuntimeException ("Bad");<a name="line.324"></a>
<span class="sourceLineNo">325</span>                System.out.println("JOM sol: cost: " + stat_totalCost + ", num links: "+ stat_numLinks);<a name="line.325"></a>
<span class="sourceLineNo">326</span><a name="line.326"></a>
<span class="sourceLineNo">327</span>                return "Ok! cost: " + stat_totalCost + ", num links: "+ stat_numLinks;<a name="line.327"></a>
<span class="sourceLineNo">328</span><a name="line.328"></a>
<span class="sourceLineNo">329</span>                } catch (Exception e) { e.printStackTrace(); throw new RuntimeException ("BAD OUT"); }  <a name="line.329"></a>
<span class="sourceLineNo">330</span><a name="line.330"></a>
<span class="sourceLineNo">331</span>        }<a name="line.331"></a>
<span class="sourceLineNo">332</span><a name="line.332"></a>
<span class="sourceLineNo">333</span>        @Override<a name="line.333"></a>
<span class="sourceLineNo">334</span>        public String getDescription()<a name="line.334"></a>
<span class="sourceLineNo">335</span>        {<a name="line.335"></a>
<span class="sourceLineNo">336</span>                return "This algorithm is devoted to solve the several network planning problems appearing in the case study in Section 12.10 of the book mentioned below. The context is the planning of a WDM optical network, given a set of node locations, and a set of end-to-end optical connections (lightpaths) to establish. The algorithm should decide on the fibers to deploy, and the routing of the lightpaths on the fibers, minimizing the total network cost. The cost model includes the fiber renting cost (paid to a dark fiber provider), OADM cost (separating between OADMs of degree two, and degree higher than two), and the cost of the transponders. The network must be tolerant to a set of user-defined failures (defined by SRGs). The algorithm permits choosing between two recovery types: 1+1, and shared protection. In the latter, the number of lightpaths between two nodes that survive to any of the failures is at least the number of optical connections requested for that node pair. For solving the problem, the algorithm uses a GRASP heuristic, to govern the iterative search that is performed using small ILPs solved with JOM in each iteration.";<a name="line.336"></a>
<span class="sourceLineNo">337</span>        }<a name="line.337"></a>
<span class="sourceLineNo">338</span><a name="line.338"></a>
<span class="sourceLineNo">339</span>        @Override<a name="line.339"></a>
<span class="sourceLineNo">340</span>        public List&lt;Triple&lt;String, String, String&gt;&gt; getParameters()<a name="line.340"></a>
<span class="sourceLineNo">341</span>        {<a name="line.341"></a>
<span class="sourceLineNo">342</span>                /* Returns the parameter information for all the InputParameter objects defined in this object (uses Java reflection) */<a name="line.342"></a>
<span class="sourceLineNo">343</span>                return InputParameter.getInformationAllInputParameterFieldsOfObject(this);<a name="line.343"></a>
<span class="sourceLineNo">344</span>        }<a name="line.344"></a>
<span class="sourceLineNo">345</span><a name="line.345"></a>
<span class="sourceLineNo">346</span>        private Quadruple&lt;Double,Double,Double,Double&gt; computeCost (NetPlan  np)<a name="line.346"></a>
<span class="sourceLineNo">347</span>        {<a name="line.347"></a>
<span class="sourceLineNo">348</span>                double costLinks = 0;<a name="line.348"></a>
<span class="sourceLineNo">349</span>                for (Link e : np.getLinks ())<a name="line.349"></a>
<span class="sourceLineNo">350</span>                        costLinks += linkCost_e.get(e.getIndex ()) * e.getCapacity() / (tcfa_linkCapacity_numCirc.getInt () * tcfa_circuitCapacity_Gbps.getDouble ());<a name="line.350"></a>
<span class="sourceLineNo">351</span>                <a name="line.351"></a>
<span class="sourceLineNo">352</span>                double costCircuits = 0;<a name="line.352"></a>
<span class="sourceLineNo">353</span>                for (Route r : np.getRoutes ())<a name="line.353"></a>
<span class="sourceLineNo">354</span>                        costCircuits += tcfa_circuitCost.getDouble () * (r.getCarriedTraffic() / tcfa_circuitCapacity_Gbps.getDouble ());<a name="line.354"></a>
<span class="sourceLineNo">355</span>                for (ProtectionSegment p : np.getProtectionSegments())<a name="line.355"></a>
<span class="sourceLineNo">356</span>                        costCircuits += tcfa_circuitCost.getDouble () * (p.getReservedCapacityForProtection() / tcfa_circuitCapacity_Gbps.getDouble ());<a name="line.356"></a>
<span class="sourceLineNo">357</span>                double costNodes = 0;<a name="line.357"></a>
<span class="sourceLineNo">358</span>                for (Node n : np.getNodes())<a name="line.358"></a>
<span class="sourceLineNo">359</span>                {<a name="line.359"></a>
<span class="sourceLineNo">360</span>                        final int nodeDegree = (int) Math.max(n.getOutgoingLinks().size(), n.getIncomingLinks().size()); <a name="line.360"></a>
<span class="sourceLineNo">361</span>                        costNodes += (nodeDegree &lt;= 2)? tcfa_costNodeDegree2.getDouble () : tcfa_costNodeDegreeHigherThan2.getDouble ();<a name="line.361"></a>
<span class="sourceLineNo">362</span>                }<a name="line.362"></a>
<span class="sourceLineNo">363</span>                final double totalCost = costLinks+  costCircuits + costNodes;<a name="line.363"></a>
<span class="sourceLineNo">364</span><a name="line.364"></a>
<span class="sourceLineNo">365</span>                System.out.println("Total cost: " + totalCost + ", links %: " + (costLinks/totalCost) + ", circ %: " + (costCircuits/totalCost) + ", nodes %: " + (costNodes/totalCost));<a name="line.365"></a>
<span class="sourceLineNo">366</span>                <a name="line.366"></a>
<span class="sourceLineNo">367</span>                System.out.println("-- From np cost total :" + totalCost + ", links: " + costLinks + ", nodes: " + costNodes + ", circ: " + costCircuits);<a name="line.367"></a>
<span class="sourceLineNo">368</span><a name="line.368"></a>
<span class="sourceLineNo">369</span>                return Quadruple.of(totalCost,costLinks,costNodes,costCircuits);<a name="line.369"></a>
<span class="sourceLineNo">370</span>        }<a name="line.370"></a>
<span class="sourceLineNo">371</span>        <a name="line.371"></a>
<span class="sourceLineNo">372</span>        private double computeCost_shared (DoubleMatrix1D x_r , DoubleMatrix1D p_e)<a name="line.372"></a>
<span class="sourceLineNo">373</span>        {<a name="line.373"></a>
<span class="sourceLineNo">374</span>                double costLinks = p_e.zDotProduct(linkCost_e);<a name="line.374"></a>
<span class="sourceLineNo">375</span>                final double costCircuits = tcfa_circuitCost.getDouble () * x_r.zSum();<a name="line.375"></a>
<span class="sourceLineNo">376</span>                double costNodes = 0;<a name="line.376"></a>
<span class="sourceLineNo">377</span>                DoubleMatrix1D degree_n = Aout_ne.zMult(p_e, null);<a name="line.377"></a>
<span class="sourceLineNo">378</span>                for (int n = 0; n &lt; N ; n ++)<a name="line.378"></a>
<span class="sourceLineNo">379</span>                        costNodes += (degree_n.get(n) &lt;= 2)? tcfa_costNodeDegree2.getDouble () : tcfa_costNodeDegreeHigherThan2.getDouble ();<a name="line.379"></a>
<span class="sourceLineNo">380</span>                final double totalCost = costLinks+  costCircuits + costNodes;<a name="line.380"></a>
<span class="sourceLineNo">381</span>                //System.out.println("-- shared cost total :" + totalCost + ", links: " + costLinks + ", nodes: " + costNodes + ", circ: " + costCircuits);<a name="line.381"></a>
<span class="sourceLineNo">382</span>                return totalCost;<a name="line.382"></a>
<span class="sourceLineNo">383</span>        }<a name="line.383"></a>
<span class="sourceLineNo">384</span>        private double computeCost_11 (DoubleMatrix1D x_r , DoubleMatrix1D x2_r , DoubleMatrix1D p_e)<a name="line.384"></a>
<span class="sourceLineNo">385</span>        {<a name="line.385"></a>
<span class="sourceLineNo">386</span>                double costLinks = p_e.zDotProduct(linkCost_e);<a name="line.386"></a>
<span class="sourceLineNo">387</span>                final double costCircuits = tcfa_circuitCost.getDouble () * (x_r.zSum() + x2_r.zSum());<a name="line.387"></a>
<span class="sourceLineNo">388</span>                double costNodes = 0;<a name="line.388"></a>
<span class="sourceLineNo">389</span>                DoubleMatrix1D degree_n = Aout_ne.zMult(p_e, null);<a name="line.389"></a>
<span class="sourceLineNo">390</span>                for (int n = 0; n &lt; N ; n ++)<a name="line.390"></a>
<span class="sourceLineNo">391</span>                        costNodes += (degree_n.get(n) &lt;= 2)? tcfa_costNodeDegree2.getDouble () : tcfa_costNodeDegreeHigherThan2.getDouble ();<a name="line.391"></a>
<span class="sourceLineNo">392</span>                final double totalCost = costLinks+  costCircuits + costNodes;<a name="line.392"></a>
<span class="sourceLineNo">393</span>                //System.out.println("-- shared cost total :" + totalCost + ", links: " + costLinks + ", nodes: " + costNodes + ", circ: " + costCircuits);<a name="line.393"></a>
<span class="sourceLineNo">394</span>                return totalCost;<a name="line.394"></a>
<span class="sourceLineNo">395</span>        }<a name="line.395"></a>
<span class="sourceLineNo">396</span><a name="line.396"></a>
<span class="sourceLineNo">397</span>        private Link oppositeLink (Link e) { return e.getNetPlan ().getNodePairLinks(e.getDestinationNode(), e.getOriginNode() , false).iterator().next(); }<a name="line.397"></a>
<span class="sourceLineNo">398</span>        <a name="line.398"></a>
<span class="sourceLineNo">399</span>        private Pair&lt;Map&lt;Demand,Demand&gt;,Map&lt;Route,Route&gt;&gt; initializeNetPlanLinksBidirDemandsAndRoutes (NetPlan np)<a name="line.399"></a>
<span class="sourceLineNo">400</span>        {<a name="line.400"></a>
<span class="sourceLineNo">401</span>                /* Remove lower half demands from np */<a name="line.401"></a>
<span class="sourceLineNo">402</span>                np.removeAllRoutes(); np.removeAllProtectionSegments();<a name="line.402"></a>
<span class="sourceLineNo">403</span>                for (Node n1 : np.getNodes()) for (Node n2 : np.getNodes()) if (n1.getIndex () &gt; n2.getIndex ()) for (Demand d : np.getNodePairDemands(n1, n2,false)) d.remove ();<a name="line.403"></a>
<span class="sourceLineNo">404</span>                np.addRoutesFromCandidatePathList(null , "K" , "" + tcfa_maxNumberPathsPerDemand.getInt () , "maxLengthInKm" , "" + tcfa_maxPathLengthInKm.getDouble() ,  "maxNumHops" , "" + tcfa_maxPathNumberOfHops.getInt ());<a name="line.404"></a>
<span class="sourceLineNo">405</span><a name="line.405"></a>
<span class="sourceLineNo">406</span>                /* Add symmetric demands and routes */<a name="line.406"></a>
<span class="sourceLineNo">407</span>                Map&lt;Demand,Demand&gt; opposite_d = new HashMap&lt;Demand,Demand&gt; ();<a name="line.407"></a>
<span class="sourceLineNo">408</span>                Map&lt;Route,Route&gt; opposite_r = new HashMap&lt;Route,Route&gt; ();<a name="line.408"></a>
<span class="sourceLineNo">409</span>                for (Demand d : new HashSet&lt;Demand&gt; (np.getDemands()))<a name="line.409"></a>
<span class="sourceLineNo">410</span>                {<a name="line.410"></a>
<span class="sourceLineNo">411</span>                        final Demand opDemand = np.addDemand(d.getEgressNode(), d.getIngressNode(), d.getOfferedTraffic(), null);<a name="line.411"></a>
<span class="sourceLineNo">412</span>                        opposite_d.put(d,opDemand);<a name="line.412"></a>
<span class="sourceLineNo">413</span>                        opposite_d.put(opDemand,d);<a name="line.413"></a>
<span class="sourceLineNo">414</span>                        for (Route r : new HashSet&lt;Route&gt; (d.getRoutes ()))<a name="line.414"></a>
<span class="sourceLineNo">415</span>                        {<a name="line.415"></a>
<span class="sourceLineNo">416</span>                                final Route oppRoute = np.addRoute(opDemand, r.getCarriedTraffic(), r.getOccupiedCapacity() , oppositeSeqLinks (r.getSeqLinksRealPath()), null);<a name="line.416"></a>
<span class="sourceLineNo">417</span>                                opposite_r.put(r,oppRoute); opposite_r.put(oppRoute,r);<a name="line.417"></a>
<span class="sourceLineNo">418</span>                        }<a name="line.418"></a>
<span class="sourceLineNo">419</span>                }<a name="line.419"></a>
<span class="sourceLineNo">420</span>                return Pair.of(opposite_d,opposite_r);<a name="line.420"></a>
<span class="sourceLineNo">421</span>        }<a name="line.421"></a>
<span class="sourceLineNo">422</span><a name="line.422"></a>
<span class="sourceLineNo">423</span>        private void initializeSRGs (NetPlan np)<a name="line.423"></a>
<span class="sourceLineNo">424</span>        {<a name="line.424"></a>
<span class="sourceLineNo">425</span>                np.removeAllSRGs();<a name="line.425"></a>
<span class="sourceLineNo">426</span>                if (tcfa_srgType.getString ().equals("perBidirectionalLinkBundle"))<a name="line.426"></a>
<span class="sourceLineNo">427</span>                {<a name="line.427"></a>
<span class="sourceLineNo">428</span>                        for (Node n1 : np.getNodes()) for (Node n2 : np.getNodes()) if (n1.getIndex () &lt; n2.getIndex())<a name="line.428"></a>
<span class="sourceLineNo">429</span>                        {<a name="line.429"></a>
<span class="sourceLineNo">430</span>                                final double linkLengthKm = np.getNodePairLinks(n1, n2,false).iterator().next().getLengthInKm();<a name="line.430"></a>
<span class="sourceLineNo">431</span>                                final SharedRiskGroup srg = np.addSRG(tcfa_srgMttfPer1000Km_hrs.getDouble () * linkLengthKm / 1000, tcfa_srgMttr_hrs.getDouble (), null);<a name="line.431"></a>
<span class="sourceLineNo">432</span>                                for (Link e : np.getNodePairLinks(n1, n2,true)) srg.addLink(e); <a name="line.432"></a>
<span class="sourceLineNo">433</span>                        }<a name="line.433"></a>
<span class="sourceLineNo">434</span>                }<a name="line.434"></a>
<span class="sourceLineNo">435</span>                else if (tcfa_srgType.getString ().equals("noFailure"))<a name="line.435"></a>
<span class="sourceLineNo">436</span>                {<a name="line.436"></a>
<span class="sourceLineNo">437</span>                } else throw new Net2PlanException ("Wrong SRG type");<a name="line.437"></a>
<span class="sourceLineNo">438</span>        }<a name="line.438"></a>
<span class="sourceLineNo">439</span>        <a name="line.439"></a>
<span class="sourceLineNo">440</span>        private List&lt;Link&gt; oppositeSeqLinks  (List&lt;Link&gt; s)<a name="line.440"></a>
<span class="sourceLineNo">441</span>        {<a name="line.441"></a>
<span class="sourceLineNo">442</span>                LinkedList&lt;Link&gt; oppList = new LinkedList&lt;Link&gt; ();<a name="line.442"></a>
<span class="sourceLineNo">443</span>                for (Link e : s) oppList.addFirst(oppositeLink(e));<a name="line.443"></a>
<span class="sourceLineNo">444</span>                return (List&lt;Link&gt;) oppList;<a name="line.444"></a>
<span class="sourceLineNo">445</span>        }<a name="line.445"></a>
<span class="sourceLineNo">446</span><a name="line.446"></a>
<span class="sourceLineNo">447</span>        private void checkSolution (NetPlan np)<a name="line.447"></a>
<span class="sourceLineNo">448</span>        {<a name="line.448"></a>
<span class="sourceLineNo">449</span>                if (np.getDemandsBlocked().size() != 0)<a name="line.449"></a>
<span class="sourceLineNo">450</span>                {<a name="line.450"></a>
<span class="sourceLineNo">451</span>                        System.out.println("np.getDemandsBlocked(): " + np.getDemandsBlocked());<a name="line.451"></a>
<span class="sourceLineNo">452</span>                        System.out.println("np.getDemandOfferedTrafficMap(): " + np.getVectorDemandOfferedTraffic());<a name="line.452"></a>
<span class="sourceLineNo">453</span>                        System.out.println("np.getDemandBlockedTrafficMap(): " + np.getVectorDemandBlockedTraffic());<a name="line.453"></a>
<span class="sourceLineNo">454</span>                        throw new RuntimeException ("Bad");<a name="line.454"></a>
<span class="sourceLineNo">455</span>                }<a name="line.455"></a>
<span class="sourceLineNo">456</span>                if (np.getLinksOversubscribed().size() != 0)<a name="line.456"></a>
<span class="sourceLineNo">457</span>                {<a name="line.457"></a>
<span class="sourceLineNo">458</span>                        System.out.println("np.getLinksOversubscribed(): " + np.getLinksOversubscribed());<a name="line.458"></a>
<span class="sourceLineNo">459</span>                        System.out.println("np.getLinkCapacityMap(): " + np.getVectorLinkCapacity());<a name="line.459"></a>
<span class="sourceLineNo">460</span>                        System.out.println("np.getLinkCarriedTrafficMap(): " + np.getVectorLinkTotalCarriedTraffic());<a name="line.460"></a>
<span class="sourceLineNo">461</span>                        throw new RuntimeException ("Bad");<a name="line.461"></a>
<span class="sourceLineNo">462</span>                }<a name="line.462"></a>
<span class="sourceLineNo">463</span>                <a name="line.463"></a>
<span class="sourceLineNo">464</span>                /* Check bidirectional topology */<a name="line.464"></a>
<span class="sourceLineNo">465</span>                for (Node n1 : np.getNodes()) <a name="line.465"></a>
<span class="sourceLineNo">466</span>                        for (Node n2 : np.getNodes()) <a name="line.466"></a>
<span class="sourceLineNo">467</span>                                if (n1.getIndex () &gt; n2.getIndex ()) <a name="line.467"></a>
<span class="sourceLineNo">468</span>                                {<a name="line.468"></a>
<span class="sourceLineNo">469</span>                                        Set&lt;Link&gt; thisLinks = np.getNodePairLinks(n1, n2,false);<a name="line.469"></a>
<span class="sourceLineNo">470</span>                                        Set&lt;Link&gt; oppLinks = np.getNodePairLinks(n2, n1,false);<a name="line.470"></a>
<span class="sourceLineNo">471</span>                                        if (thisLinks.size() &gt; 1) throw new RuntimeException ("Bad");<a name="line.471"></a>
<span class="sourceLineNo">472</span>                                        if (oppLinks.size() &gt; 1) throw new RuntimeException ("Bad");<a name="line.472"></a>
<span class="sourceLineNo">473</span>                                        if (tcfa_bidirectionalLinks.getBoolean())<a name="line.473"></a>
<span class="sourceLineNo">474</span>                                        {<a name="line.474"></a>
<span class="sourceLineNo">475</span>                                                if (thisLinks.size() != oppLinks.size()) throw new RuntimeException ("Bad");<a name="line.475"></a>
<span class="sourceLineNo">476</span>                                                if (thisLinks.size() &gt; 0)<a name="line.476"></a>
<span class="sourceLineNo">477</span>                                                        if (thisLinks.iterator().next().getCapacity() != oppLinks.iterator().next().getCapacity() ) throw new RuntimeException ("Bad");<a name="line.477"></a>
<span class="sourceLineNo">478</span>                                        }<a name="line.478"></a>
<span class="sourceLineNo">479</span>                                }<a name="line.479"></a>
<span class="sourceLineNo">480</span><a name="line.480"></a>
<span class="sourceLineNo">481</span>                /* Check bidirectional routes */<a name="line.481"></a>
<span class="sourceLineNo">482</span>                for (Route r : np.getRoutes())<a name="line.482"></a>
<span class="sourceLineNo">483</span>                {<a name="line.483"></a>
<span class="sourceLineNo">484</span>                        final Route oppRoute = opposite_r.get(r);<a name="line.484"></a>
<span class="sourceLineNo">485</span>                        if (!np.getRoutes().contains(oppRoute)) throw new RuntimeException ("Bad");<a name="line.485"></a>
<span class="sourceLineNo">486</span>                        if (r.getCarriedTraffic() != oppRoute.getCarriedTraffic()) throw new RuntimeException ("Bad");<a name="line.486"></a>
<span class="sourceLineNo">487</span>                }<a name="line.487"></a>
<span class="sourceLineNo">488</span><a name="line.488"></a>
<span class="sourceLineNo">489</span>                if (tcfa_recoveryType.getString ().equals("1+1"))<a name="line.489"></a>
<span class="sourceLineNo">490</span>                { // one prot segment, and link disjoint<a name="line.490"></a>
<span class="sourceLineNo">491</span>                        for (Route r : np.getRoutes())<a name="line.491"></a>
<span class="sourceLineNo">492</span>                        {<a name="line.492"></a>
<span class="sourceLineNo">493</span>                                if (r.getPotentialBackupProtectionSegments().size() != 1) throw new RuntimeException ("Bad");<a name="line.493"></a>
<span class="sourceLineNo">494</span>                                final ProtectionSegment protSegment = r.getPotentialBackupProtectionSegments().iterator().next();<a name="line.494"></a>
<span class="sourceLineNo">495</span>                                List&lt;Link&gt; seqLinks = new ArrayList&lt;Link&gt; (r.getSeqLinksRealPath());<a name="line.495"></a>
<span class="sourceLineNo">496</span>                                seqLinks.retainAll(protSegment.getSeqLinks());<a name="line.496"></a>
<span class="sourceLineNo">497</span>                                if (!seqLinks.isEmpty()) <a name="line.497"></a>
<span class="sourceLineNo">498</span>                                {<a name="line.498"></a>
<span class="sourceLineNo">499</span>                                        System.out.println ("Route : "+  r + " links: " + r.getSeqLinksRealPath() + ", prot segment " + protSegment + " links: " + protSegment.getSeqLinks() + ", get route carried traffic: " + r.getCarriedTraffic() + ", prot segment reserved traffic: " + protSegment.getReservedCapacityForProtection());<a name="line.499"></a>
<span class="sourceLineNo">500</span>                                        throw new RuntimeException ("Bad");<a name="line.500"></a>
<span class="sourceLineNo">501</span>                                }<a name="line.501"></a>
<span class="sourceLineNo">502</span>                        }<a name="line.502"></a>
<span class="sourceLineNo">503</span>                }<a name="line.503"></a>
<span class="sourceLineNo">504</span>                <a name="line.504"></a>
<span class="sourceLineNo">505</span>        }<a name="line.505"></a>
<span class="sourceLineNo">506</span>        <a name="line.506"></a>
<span class="sourceLineNo">507</span>        private DoubleMatrix1D jomStep_shared (Set&lt;Integer&gt; demandsChange , DoubleMatrix1D maxPe , DoubleMatrix1D  x_r)<a name="line.507"></a>
<span class="sourceLineNo">508</span>        {<a name="line.508"></a>
<span class="sourceLineNo">509</span>                final long initTimeBeforeCreatingProgram = System.nanoTime();<a name="line.509"></a>
<span class="sourceLineNo">510</span>                if (demandsChange.isEmpty()) throw new RuntimeException ("Bad");<a name="line.510"></a>
<span class="sourceLineNo">511</span>                final int [] dChange = IntUtils.toArray(demandsChange);<a name="line.511"></a>
<span class="sourceLineNo">512</span>                int [] rChange = new int [0]; for (int d : dChange) rChange = IntUtils.concatenate(rChange,  routeList_d [d]);<a name="line.512"></a>
<span class="sourceLineNo">513</span>                final int Rrest = rChange.length;<a name="line.513"></a>
<span class="sourceLineNo">514</span>                x_r.viewSelection(rChange).assign(0);<a name="line.514"></a>
<span class="sourceLineNo">515</span>                DoubleMatrix2D A_dRestrRest = A_dr.viewSelection(dChange, rChange);<a name="line.515"></a>
<span class="sourceLineNo">516</span>                DoubleMatrix2D A_erRest = A_er.viewSelection(null, rChange);<a name="line.516"></a>
<span class="sourceLineNo">517</span>                DoubleMatrix2D A_rRests = A_rs.viewSelection(rChange,null);<a name="line.517"></a>
<span class="sourceLineNo">518</span>                DoubleMatrix1D occupiedWithoutChangingR_e = A_er.zMult (x_r,null);<a name="line.518"></a>
<span class="sourceLineNo">519</span>                DoubleMatrix2D Abid_rRestrRest = DoubleFactory2D.sparse.make(Rrest,Rrest);<a name="line.519"></a>
<span class="sourceLineNo">520</span>                for (int rRest = 0 ; rRest &lt; Rrest ; rRest ++) <a name="line.520"></a>
<span class="sourceLineNo">521</span>                { <a name="line.521"></a>
<span class="sourceLineNo">522</span>                        final int r = rChange [rRest]; <a name="line.522"></a>
<span class="sourceLineNo">523</span>                        final int opp_r = opposite_r.get(netPlan.getRoute(r)).getIndex ();<a name="line.523"></a>
<span class="sourceLineNo">524</span>                        final int [] oppRrest = IntUtils.find(rChange, opp_r, SearchType.ALL);<a name="line.524"></a>
<span class="sourceLineNo">525</span>                        if (oppRrest.length != 1) throw new RuntimeException ("Bad");<a name="line.525"></a>
<span class="sourceLineNo">526</span>                        Abid_rRestrRest.set(rRest , oppRrest [0] , 1.0); Abid_rRestrRest.set(oppRrest [0], rRest , 1);<a name="line.526"></a>
<span class="sourceLineNo">527</span>                }<a name="line.527"></a>
<span class="sourceLineNo">528</span>                OptimizationProblem op = new OptimizationProblem();<a name="line.528"></a>
<span class="sourceLineNo">529</span>                op.setInputParameter("R",R);<a name="line.529"></a>
<span class="sourceLineNo">530</span>                op.setInputParameter("U",tcfa_linkCapacity_numCirc.getInt ());<a name="line.530"></a>
<span class="sourceLineNo">531</span>                op.setInputParameter("c_e", linkCost_e.toArray() , "row");<a name="line.531"></a>
<span class="sourceLineNo">532</span>                op.setInputParameter("c",  tcfa_circuitCost.getDouble ());<a name="line.532"></a>
<span class="sourceLineNo">533</span>                op.setInputParameter("d3Cost",  tcfa_costNodeDegreeHigherThan2.getDouble ());<a name="line.533"></a>
<span class="sourceLineNo">534</span>                op.setInputParameter("onesS",  DoubleUtils.ones(1+nSRGs) , "row");<a name="line.534"></a>
<span class="sourceLineNo">535</span>                op.setInputParameter("onesE",  DoubleUtils.ones(Efm) , "row");<a name="line.535"></a>
<span class="sourceLineNo">536</span>                op.setInputParameter("A_dRestrRest", new DoubleMatrixND (A_dRestrRest));<a name="line.536"></a>
<span class="sourceLineNo">537</span>                op.setInputParameter("h_dRest", numCircH_d.viewSelection(dChange).toArray(), "row");<a name="line.537"></a>
<span class="sourceLineNo">538</span>                op.setInputParameter("A_rRests", new DoubleMatrixND (A_rRests));<a name="line.538"></a>
<span class="sourceLineNo">539</span>                op.setInputParameter("A_erRest", new DoubleMatrixND (A_erRest));<a name="line.539"></a>
<span class="sourceLineNo">540</span>                op.setInputParameter("Aout_ne", new DoubleMatrixND (Aout_ne));<a name="line.540"></a>
<span class="sourceLineNo">541</span>                op.setInputParameter("Abid_rRestrRest", new DoubleMatrixND (Abid_rRestrRest));<a name="line.541"></a>
<span class="sourceLineNo">542</span>                op.setInputParameter("occup_e", occupiedWithoutChangingR_e.toArray(),  "row");<a name="line.542"></a>
<span class="sourceLineNo">543</span>                <a name="line.543"></a>
<span class="sourceLineNo">544</span>                op.addDecisionVariable("d3_n", true, new int[] { 1, N }, 0, 1); <a name="line.544"></a>
<span class="sourceLineNo">545</span>                op.addDecisionVariable("p_e", true, new int[] { 1, Efm }, DoubleUtils.zeros(Efm) , (maxPe == null)? DoubleUtils.constantArray(Efm, Double.MAX_VALUE) : maxPe.toArray());<a name="line.545"></a>
<span class="sourceLineNo">546</span>                op.addDecisionVariable("x_rRest", true, new int[] { 1, Rrest}, 0 ,  Double.MAX_VALUE); /* 1 if there is a link from node i to node j, 0 otherwise */<a name="line.546"></a>
<span class="sourceLineNo">547</span><a name="line.547"></a>
<span class="sourceLineNo">548</span>                op.setObjectiveFunction("minimize", "sum(c_e .* p_e) + c * sum (x_rRest) + d3Cost * sum(d3_n)");<a name="line.548"></a>
<span class="sourceLineNo">549</span>                op.addConstraint("A_dRestrRest * diag(x_rRest) * A_rRests &gt;= h_dRest' * onesS"); /* the flow-conservation constraints (NxD constraints) */<a name="line.549"></a>
<span class="sourceLineNo">550</span>                op.addConstraint("A_erRest * x_rRest' + occup_e' &lt;= U * p_e'"); /* the capacity constraints (E constraints) */<a name="line.550"></a>
<span class="sourceLineNo">551</span>                op.addConstraint("Aout_ne * p_e' &lt;= 2 + R * d3_n'"); /* the capacity constraints (E constraints) */<a name="line.551"></a>
<span class="sourceLineNo">552</span>                op.addConstraint("x_rRest == x_rRest * Abid_rRestrRest");<a name="line.552"></a>
<span class="sourceLineNo">553</span>                if (tcfa_bidirectionalLinks.getBoolean()) { op.setInputParameter("Abid_ee", new DoubleMatrixND (Abid_ee)); op.addConstraint("p_e == p_e * Abid_ee"); } <a name="line.553"></a>
<span class="sourceLineNo">554</span><a name="line.554"></a>
<span class="sourceLineNo">555</span>                stat_totalTimeCreateProgramsSecs += eTime (initTimeBeforeCreatingProgram); <a name="line.555"></a>
<span class="sourceLineNo">556</span>                                <a name="line.556"></a>
<span class="sourceLineNo">557</span>                double solverTimeAllowed = algorithm_maxSolverTimeInSeconds.getDouble();<a name="line.557"></a>
<span class="sourceLineNo">558</span>                do <a name="line.558"></a>
<span class="sourceLineNo">559</span>                {<a name="line.559"></a>
<span class="sourceLineNo">560</span>                        final long t = System.nanoTime(); <a name="line.560"></a>
<span class="sourceLineNo">561</span>                        try <a name="line.561"></a>
<span class="sourceLineNo">562</span>                        { <a name="line.562"></a>
<span class="sourceLineNo">563</span>                                stat_numSolverCalls ++; op.solve(algorithm_solverName.getString() , "solverLibraryName", algorithm_solverLibraryName.getString () ,  "maxSolverTimeInSeconds" , solverTimeAllowed);<a name="line.563"></a>
<span class="sourceLineNo">564</span>                        } catch (Exception e) { System.out.println ("-- EXTRA TIME FOR SOLVER, NOW: " + solverTimeAllowed); solverTimeAllowed += 2; stat_totalTimeSolverSecs += eTime(t);  continue;} <a name="line.564"></a>
<span class="sourceLineNo">565</span>                        stat_totalTimeSolverSecs += eTime(t);  <a name="line.565"></a>
<span class="sourceLineNo">566</span>                        if (solverTimeAllowed != algorithm_maxSolverTimeInSeconds.getDouble()) System.out.println ("-- EXTRA TIME FOR SOLVER, NOW: " + solverTimeAllowed);<a name="line.566"></a>
<span class="sourceLineNo">567</span>                        solverTimeAllowed *= 2; // duplicate the time if not feasible solution is found<a name="line.567"></a>
<span class="sourceLineNo">568</span>                } while (!op.solutionIsFeasible());             <a name="line.568"></a>
<span class="sourceLineNo">569</span>                stat_numSolverCallsOk ++;<a name="line.569"></a>
<span class="sourceLineNo">570</span>                final double [] new_x_rRest = op.getPrimalSolution("x_rRest").to1DArray();<a name="line.570"></a>
<span class="sourceLineNo">571</span>                x_r.viewSelection(rChange).assign(new_x_rRest);<a name="line.571"></a>
<span class="sourceLineNo">572</span>                return x_r;<a name="line.572"></a>
<span class="sourceLineNo">573</span>        }<a name="line.573"></a>
<span class="sourceLineNo">574</span><a name="line.574"></a>
<span class="sourceLineNo">575</span>        private Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt; jomStep_11 (Set&lt;Integer&gt; demandsChange ,  DoubleMatrix1D maxPe , DoubleMatrix1D x_r , DoubleMatrix1D x2_r)<a name="line.575"></a>
<span class="sourceLineNo">576</span>        {<a name="line.576"></a>
<span class="sourceLineNo">577</span>//              System.out.println ("demandsChange :" + demandsChange);<a name="line.577"></a>
<span class="sourceLineNo">578</span>                final long initTimeBeforeCreatingProgram = System.nanoTime();<a name="line.578"></a>
<span class="sourceLineNo">579</span><a name="line.579"></a>
<span class="sourceLineNo">580</span>                if (demandsChange.isEmpty()) throw new RuntimeException ("Bad");<a name="line.580"></a>
<span class="sourceLineNo">581</span>                final int [] dChange = IntUtils.toArray(demandsChange);<a name="line.581"></a>
<span class="sourceLineNo">582</span>//              System.out.println ("dChange :" + Arrays.toString(dChange));<a name="line.582"></a>
<span class="sourceLineNo">583</span>                int [] rChange = new int [0]; for (int d : dChange) rChange = IntUtils.concatenate(rChange,  routeList_d [d]);<a name="line.583"></a>
<span class="sourceLineNo">584</span>                final int Rrest = rChange.length;<a name="line.584"></a>
<span class="sourceLineNo">585</span>                final int Drest = dChange.length;<a name="line.585"></a>
<span class="sourceLineNo">586</span>                x_r.viewSelection(rChange).assign(0);<a name="line.586"></a>
<span class="sourceLineNo">587</span>                x2_r.viewSelection(rChange).assign(0);<a name="line.587"></a>
<span class="sourceLineNo">588</span>                DoubleMatrix2D A_dRestrRest = A_dr.viewSelection(dChange, rChange);<a name="line.588"></a>
<span class="sourceLineNo">589</span>                DoubleMatrix2D A_erRest = A_er.viewSelection(null, rChange);<a name="line.589"></a>
<span class="sourceLineNo">590</span>                DoubleMatrix2D A_rRests = A_rs.viewSelection(rChange,null);<a name="line.590"></a>
<span class="sourceLineNo">591</span>                DoubleMatrix1D occupiedWithoutChangingR_e = A_er.zMult (x_r,null);<a name="line.591"></a>
<span class="sourceLineNo">592</span>                DoubleMatrix1D backup_occupiedWithoutChangingR_e = A_er.zMult (x2_r,null);<a name="line.592"></a>
<span class="sourceLineNo">593</span>                for (int e = 0;e &lt; Efm; e ++) occupiedWithoutChangingR_e.set(e, occupiedWithoutChangingR_e.get(e) + backup_occupiedWithoutChangingR_e.get(e));<a name="line.593"></a>
<span class="sourceLineNo">594</span>                DoubleMatrix2D Abid_rRestrRest = DoubleFactory2D.sparse.make(Rrest,Rrest);<a name="line.594"></a>
<span class="sourceLineNo">595</span>                for (int rRest = 0 ; rRest &lt; Rrest ; rRest ++) <a name="line.595"></a>
<span class="sourceLineNo">596</span>                { <a name="line.596"></a>
<span class="sourceLineNo">597</span>                        final int r = rChange [rRest]; final int opp_r = opposite_r.get(netPlan.getRoute (r)).getIndex ();<a name="line.597"></a>
<span class="sourceLineNo">598</span>                        final int [] oppRrest = IntUtils.find(rChange, opp_r, SearchType.ALL); if (oppRrest.length != 1) throw new RuntimeException ("Bad");<a name="line.598"></a>
<span class="sourceLineNo">599</span>                        Abid_rRestrRest.set(rRest , oppRrest [0] , 1.0); Abid_rRestrRest.set(oppRrest [0], rRest , 1);<a name="line.599"></a>
<span class="sourceLineNo">600</span>                }<a name="line.600"></a>
<span class="sourceLineNo">601</span>                <a name="line.601"></a>
<span class="sourceLineNo">602</span>                OptimizationProblem op = new OptimizationProblem();<a name="line.602"></a>
<span class="sourceLineNo">603</span>                op.setInputParameter("R",R);<a name="line.603"></a>
<span class="sourceLineNo">604</span>                op.setInputParameter("U",tcfa_linkCapacity_numCirc.getInt ());<a name="line.604"></a>
<span class="sourceLineNo">605</span>                op.setInputParameter("c_e", linkCost_e.toArray() , "row");<a name="line.605"></a>
<span class="sourceLineNo">606</span>                op.setInputParameter("c",  tcfa_circuitCost.getDouble ());<a name="line.606"></a>
<span class="sourceLineNo">607</span>                op.setInputParameter("d3Cost",  tcfa_costNodeDegreeHigherThan2.getDouble ());<a name="line.607"></a>
<span class="sourceLineNo">608</span>                op.setInputParameter("onesS",  DoubleUtils.ones(1+nSRGs) , "row");<a name="line.608"></a>
<span class="sourceLineNo">609</span>                op.setInputParameter("onesE",  DoubleUtils.ones(Efm) , "row");<a name="line.609"></a>
<span class="sourceLineNo">610</span>                op.setInputParameter("A_dRestrRest", new DoubleMatrixND (A_dRestrRest));<a name="line.610"></a>
<span class="sourceLineNo">611</span>                op.setInputParameter("h_dRest", numCircH_d.viewSelection(dChange).toArray(), "row");<a name="line.611"></a>
<span class="sourceLineNo">612</span>                op.setInputParameter("A_rRests", new DoubleMatrixND (A_rRests));<a name="line.612"></a>
<span class="sourceLineNo">613</span>                op.setInputParameter("A_erRest", new DoubleMatrixND (A_erRest));<a name="line.613"></a>
<span class="sourceLineNo">614</span>                op.setInputParameter("Aout_ne", new DoubleMatrixND (Aout_ne));<a name="line.614"></a>
<span class="sourceLineNo">615</span>                op.setInputParameter("Abid_rRestrRest", new DoubleMatrixND (Abid_rRestrRest));<a name="line.615"></a>
<span class="sourceLineNo">616</span>                op.setInputParameter("occup_e", occupiedWithoutChangingR_e.toArray(),  "row");<a name="line.616"></a>
<span class="sourceLineNo">617</span>                <a name="line.617"></a>
<span class="sourceLineNo">618</span>                op.addDecisionVariable("d3_n", true, new int[] { 1, N }, 0, 1); <a name="line.618"></a>
<span class="sourceLineNo">619</span>                op.addDecisionVariable("p_e", true, new int[] { 1, Efm }, DoubleUtils.zeros(Efm) , (maxPe == null)? DoubleUtils.constantArray(Efm, Double.MAX_VALUE) : maxPe.toArray());<a name="line.619"></a>
<span class="sourceLineNo">620</span>                op.addDecisionVariable("x_rRest", true, new int[] { 1, Rrest}, 0 ,  1); <a name="line.620"></a>
<span class="sourceLineNo">621</span>                op.addDecisionVariable("x2_rRest", true, new int[] { 1, Rrest}, 0 ,  1); <a name="line.621"></a>
<span class="sourceLineNo">622</span><a name="line.622"></a>
<span class="sourceLineNo">623</span>                op.setObjectiveFunction("minimize", "sum(c_e .* p_e) + d3Cost * sum(d3_n)");<a name="line.623"></a>
<span class="sourceLineNo">624</span>                op.addConstraint("A_dRestrRest * x_rRest' == h_dRest'"); /* the flow-conservation constraints (NxD constraints) */<a name="line.624"></a>
<span class="sourceLineNo">625</span>                op.addConstraint("A_dRestrRest * x2_rRest' == h_dRest'"); /* the flow-conservation constraints (NxD constraints) */<a name="line.625"></a>
<span class="sourceLineNo">626</span>                op.addConstraint("A_erRest * (x_rRest+x2_rRest)' + occup_e' &lt;= U * p_e'"); /* the capacity constraints (E constraints) */<a name="line.626"></a>
<span class="sourceLineNo">627</span>                op.addConstraint("Aout_ne * p_e' &lt;= 2 + R*d3_n'"); /* the capacity constraints (E constraints) */<a name="line.627"></a>
<span class="sourceLineNo">628</span>                op.addConstraint("A_dRestrRest * diag(x_rRest+x2_rRest) * A_erRest' &lt;= 1"); <a name="line.628"></a>
<span class="sourceLineNo">629</span>                op.addConstraint("x_rRest == x_rRest * Abid_rRestrRest"); <a name="line.629"></a>
<span class="sourceLineNo">630</span>                op.addConstraint("x2_rRest == x2_rRest * Abid_rRestrRest"); <a name="line.630"></a>
<span class="sourceLineNo">631</span>                if (tcfa_bidirectionalLinks.getBoolean()) { op.setInputParameter("Abid_ee", new DoubleMatrixND (Abid_ee)); op.addConstraint("p_e == p_e * Abid_ee"); } <a name="line.631"></a>
<span class="sourceLineNo">632</span><a name="line.632"></a>
<span class="sourceLineNo">633</span>//              System.out.println("Abid_rr sum filas: " + Abid_rRestrRest.zMult(DoubleFactory1D.dense.make(Rrest,1), null));<a name="line.633"></a>
<span class="sourceLineNo">634</span>//              System.out.println("Abid_rr sum cols: " +  Abid_rRestrRest.zMult(DoubleFactory1D.dense.make(Rrest,1), null , 1 , 0 , true));<a name="line.634"></a>
<span class="sourceLineNo">635</span>//              System.out.println("Abid_rr non zeros: " +  Abid_rRestrRest.zSum());<a name="line.635"></a>
<span class="sourceLineNo">636</span>                stat_totalTimeCreateProgramsSecs += eTime (initTimeBeforeCreatingProgram); <a name="line.636"></a>
<span class="sourceLineNo">637</span>                <a name="line.637"></a>
<span class="sourceLineNo">638</span>                double solverTimeAllowed = algorithm_maxSolverTimeInSeconds.getDouble ();<a name="line.638"></a>
<span class="sourceLineNo">639</span>                do <a name="line.639"></a>
<span class="sourceLineNo">640</span>                { <a name="line.640"></a>
<span class="sourceLineNo">641</span>                        final long t = System.nanoTime(); <a name="line.641"></a>
<span class="sourceLineNo">642</span>                        try <a name="line.642"></a>
<span class="sourceLineNo">643</span>                        {<a name="line.643"></a>
<span class="sourceLineNo">644</span>                                stat_numSolverCalls ++; op.solve(algorithm_solverName.getString() , "solverLibraryName", algorithm_solverLibraryName.getString () ,  "maxSolverTimeInSeconds" , solverTimeAllowed);<a name="line.644"></a>
<span class="sourceLineNo">645</span>                        } catch (Exception e) { System.out.println ("-- EXTRA TIME FOR SOLVER, NOW: " + solverTimeAllowed); solverTimeAllowed += 2; stat_totalTimeSolverSecs += eTime(t);  continue; }<a name="line.645"></a>
<span class="sourceLineNo">646</span>                        if (solverTimeAllowed != algorithm_maxSolverTimeInSeconds.getDouble ()) System.out.println ("-- EXTRA TIME FOR SOLVER, NOW: " + solverTimeAllowed);<a name="line.646"></a>
<span class="sourceLineNo">647</span>                        stat_totalTimeSolverSecs += eTime(t);  <a name="line.647"></a>
<span class="sourceLineNo">648</span>                        solverTimeAllowed *= 2; // duplicate the time if not feasible solution is found<a name="line.648"></a>
<span class="sourceLineNo">649</span>                        //System.out.println ("Time to create program: " + (1E-9*(t-initTimeBeforeCreatingProgram)) + ", solver time " + ((System.nanoTime()-t)*1E-9) + " s ; ");<a name="line.649"></a>
<span class="sourceLineNo">650</span>                } while (!op.solutionIsFeasible());             <a name="line.650"></a>
<span class="sourceLineNo">651</span>                stat_numSolverCallsOk ++; <a name="line.651"></a>
<span class="sourceLineNo">652</span>                final double[] new_x_rRest = op.getPrimalSolution("x_rRest").to1DArray();<a name="line.652"></a>
<span class="sourceLineNo">653</span>                final double[] new_x2_rRest = op.getPrimalSolution("x2_rRest").to1DArray();<a name="line.653"></a>
<span class="sourceLineNo">654</span><a name="line.654"></a>
<span class="sourceLineNo">655</span>                x_r.viewSelection(rChange).assign(new_x_rRest);<a name="line.655"></a>
<span class="sourceLineNo">656</span>                x2_r.viewSelection(rChange).assign(new_x2_rRest);<a name="line.656"></a>
<span class="sourceLineNo">657</span>                return Pair.of(x_r,x2_r);<a name="line.657"></a>
<span class="sourceLineNo">658</span>        }<a name="line.658"></a>
<span class="sourceLineNo">659</span><a name="line.659"></a>
<span class="sourceLineNo">660</span>        private DoubleMatrix2D jomStep_restoration (Set&lt;Integer&gt; demandsChange ,  DoubleMatrix1D maxPe , DoubleMatrix2D  x_rs)<a name="line.660"></a>
<span class="sourceLineNo">661</span>        {<a name="line.661"></a>
<span class="sourceLineNo">662</span>                final long initTimeBeforeCreatingProgram = System.nanoTime();<a name="line.662"></a>
<span class="sourceLineNo">663</span>                if (demandsChange.isEmpty()) throw new RuntimeException ("Bad");<a name="line.663"></a>
<span class="sourceLineNo">664</span>                final int [] dChange = IntUtils.toArray(demandsChange);<a name="line.664"></a>
<span class="sourceLineNo">665</span>                int [] rChange = new int [0]; for (int d : dChange) rChange = IntUtils.concatenate(rChange,  routeList_d [d]);<a name="line.665"></a>
<span class="sourceLineNo">666</span>                final int Rrest = rChange.length;<a name="line.666"></a>
<span class="sourceLineNo">667</span>                final int Drest = dChange.length;<a name="line.667"></a>
<span class="sourceLineNo">668</span>                x_rs.viewSelection(rChange,null).assign(0);<a name="line.668"></a>
<span class="sourceLineNo">669</span>//              DoubleMatrix2D A_dRestrRest = A_dr.viewSelection(dChange, rChange);<a name="line.669"></a>
<span class="sourceLineNo">670</span>                DoubleMatrix2D A_dRestrRest = DoubleFactory2D.sparse.make(Drest,Rrest);<a name="line.670"></a>
<span class="sourceLineNo">671</span>                for (int rRest = 0 ; rRest &lt; Rrest ; rRest ++) <a name="line.671"></a>
<span class="sourceLineNo">672</span>                { <a name="line.672"></a>
<span class="sourceLineNo">673</span>                        final int r = rChange [rRest]; final int dRest [] = IntUtils.find(dChange, netPlan.getRoute (r).getDemand().getIndex () , SearchType.ALL);<a name="line.673"></a>
<span class="sourceLineNo">674</span>                        if (dRest.length  != 1) throw new RuntimeException ("Bad");<a name="line.674"></a>
<span class="sourceLineNo">675</span>                        A_dRestrRest.set(dRest [0], rRest , 1.0);<a name="line.675"></a>
<span class="sourceLineNo">676</span>                }<a name="line.676"></a>
<span class="sourceLineNo">677</span>                <a name="line.677"></a>
<span class="sourceLineNo">678</span>                DoubleMatrix2D A_erRest = A_er.viewSelection(null, rChange);<a name="line.678"></a>
<span class="sourceLineNo">679</span>                DoubleMatrix2D A_rRests = A_rs.viewSelection(rChange,null);<a name="line.679"></a>
<span class="sourceLineNo">680</span>                DoubleMatrix2D occupiedWithoutChangingR_es = A_er.zMult (x_rs,null);<a name="line.680"></a>
<span class="sourceLineNo">681</span>                DoubleMatrix2D Abid_rRestrRest = DoubleFactory2D.sparse.make(Rrest,Rrest);<a name="line.681"></a>
<span class="sourceLineNo">682</span>                for (int rRest = 0 ; rRest &lt; Rrest ; rRest ++) <a name="line.682"></a>
<span class="sourceLineNo">683</span>                { <a name="line.683"></a>
<span class="sourceLineNo">684</span>                        final int r = rChange [rRest]; final int opp_r = opposite_r.get(netPlan.getRoute (r)).getIndex ();<a name="line.684"></a>
<span class="sourceLineNo">685</span>                        final int [] oppRrest = IntUtils.find(rChange, opp_r, SearchType.ALL);<a name="line.685"></a>
<span class="sourceLineNo">686</span>                        if (oppRrest.length != 1) throw new RuntimeException ("Bad");<a name="line.686"></a>
<span class="sourceLineNo">687</span>                        Abid_rRestrRest.set(rRest , oppRrest [0] , 1.0); Abid_rRestrRest.set(oppRrest [0], rRest , 1);<a name="line.687"></a>
<span class="sourceLineNo">688</span>                }<a name="line.688"></a>
<span class="sourceLineNo">689</span>                <a name="line.689"></a>
<span class="sourceLineNo">690</span>                OptimizationProblem op = new OptimizationProblem();<a name="line.690"></a>
<span class="sourceLineNo">691</span>                op.setInputParameter("R",R);<a name="line.691"></a>
<span class="sourceLineNo">692</span>                op.setInputParameter("U",tcfa_linkCapacity_numCirc.getInt ());<a name="line.692"></a>
<span class="sourceLineNo">693</span>                op.setInputParameter("c_e", linkCost_e.toArray() , "row");<a name="line.693"></a>
<span class="sourceLineNo">694</span>                op.setInputParameter("c",  tcfa_circuitCost.getDouble ());<a name="line.694"></a>
<span class="sourceLineNo">695</span>                op.setInputParameter("d3Cost",  tcfa_costNodeDegreeHigherThan2.getDouble ());<a name="line.695"></a>
<span class="sourceLineNo">696</span>                op.setInputParameter("onesS",  DoubleUtils.ones(1+nSRGs) , "row");<a name="line.696"></a>
<span class="sourceLineNo">697</span>                op.setInputParameter("onesE",  DoubleUtils.ones(Efm) , "row");<a name="line.697"></a>
<span class="sourceLineNo">698</span>                op.setInputParameter("A_dRestrRest", new DoubleMatrixND (A_dRestrRest));<a name="line.698"></a>
<span class="sourceLineNo">699</span>                op.setInputParameter("h_dRest", numCircH_d.viewSelection(dChange).toArray(), "row");<a name="line.699"></a>
<span class="sourceLineNo">700</span>                op.setInputParameter("A_rRests", new DoubleMatrixND (A_rRests));<a name="line.700"></a>
<span class="sourceLineNo">701</span>                op.setInputParameter("A_erRest", new DoubleMatrixND (A_erRest));<a name="line.701"></a>
<span class="sourceLineNo">702</span>                op.setInputParameter("Aout_ne", new DoubleMatrixND (Aout_ne));<a name="line.702"></a>
<span class="sourceLineNo">703</span>                op.setInputParameter("Abid_rRestrRest", new DoubleMatrixND (Abid_rRestrRest));<a name="line.703"></a>
<span class="sourceLineNo">704</span>                op.setInputParameter("occup_es", occupiedWithoutChangingR_es.toArray());<a name="line.704"></a>
<span class="sourceLineNo">705</span>                <a name="line.705"></a>
<span class="sourceLineNo">706</span>                op.addDecisionVariable("d3_n", true, new int[] { 1, N }, 0, 1); <a name="line.706"></a>
<span class="sourceLineNo">707</span>                op.addDecisionVariable("p_e", true, new int[] { 1, Efm }, DoubleUtils.zeros(Efm) , (maxPe == null)? DoubleUtils.constantArray(Efm, Double.MAX_VALUE) : maxPe.toArray());<a name="line.707"></a>
<span class="sourceLineNo">708</span>                op.addDecisionVariable("x_rRests", true, new int[] { Rrest, 1+nSRGs}, 0 , Double.MAX_VALUE); /* 1 if there is a link from node i to node j, 0 otherwise */<a name="line.708"></a>
<span class="sourceLineNo">709</span><a name="line.709"></a>
<span class="sourceLineNo">710</span>                op.setObjectiveFunction("minimize", "sum(c_e .* p_e) + d3Cost * sum(d3_n)");<a name="line.710"></a>
<span class="sourceLineNo">711</span>                op.addConstraint("A_dRestrRest * x_rRests(all,0) == h_dRest'"); /* the flow-conservation constraints (NxD constraints) */<a name="line.711"></a>
<span class="sourceLineNo">712</span>                op.addConstraint("A_dRestrRest * (x_rRests .* A_rRests) &gt;= h_dRest' * onesS"); /* the flow-conservation constraints (NxD constraints) */<a name="line.712"></a>
<span class="sourceLineNo">713</span>                op.addConstraint("A_erRest * x_rRests + occup_es &lt;= U * p_e' * onesS"); /* the capacity constraints (E constraints) */<a name="line.713"></a>
<span class="sourceLineNo">714</span>                op.addConstraint("Aout_ne * p_e' &lt;= 2 + R*d3_n'"); /* the capacity constraints (E constraints) */<a name="line.714"></a>
<span class="sourceLineNo">715</span>                op.addConstraint("x_rRests == Abid_rRestrRest * x_rRests"); <a name="line.715"></a>
<span class="sourceLineNo">716</span>                op.addConstraint("x_rRests &gt;= diag(x_rRests(all,0)) * A_rRests"); // if not affected by failure, do not change <a name="line.716"></a>
<span class="sourceLineNo">717</span>                if (tcfa_bidirectionalLinks.getBoolean()) { op.setInputParameter("Abid_ee", new DoubleMatrixND (Abid_ee)); op.addConstraint("p_e == p_e * Abid_ee"); } <a name="line.717"></a>
<span class="sourceLineNo">718</span><a name="line.718"></a>
<span class="sourceLineNo">719</span>                stat_totalTimeCreateProgramsSecs += eTime (initTimeBeforeCreatingProgram); <a name="line.719"></a>
<span class="sourceLineNo">720</span><a name="line.720"></a>
<span class="sourceLineNo">721</span>                double solverTimeAllowed = algorithm_maxSolverTimeInSeconds.getDouble ();<a name="line.721"></a>
<span class="sourceLineNo">722</span>                do <a name="line.722"></a>
<span class="sourceLineNo">723</span>                { <a name="line.723"></a>
<span class="sourceLineNo">724</span>                        final long t = System.nanoTime(); <a name="line.724"></a>
<span class="sourceLineNo">725</span>                        try { stat_numSolverCalls ++; op.solve(algorithm_solverName.getString() , "solverLibraryName", algorithm_solverLibraryName.getString () ,  "maxSolverTimeInSeconds" , solverTimeAllowed); } catch (Exception e) { System.out.println ("-- EXTRA TIME FOR SOLVER, NOW: " + solverTimeAllowed); solverTimeAllowed += 2; stat_totalTimeSolverSecs += eTime(t);  continue;} <a name="line.725"></a>
<span class="sourceLineNo">726</span>                        if (solverTimeAllowed != algorithm_maxSolverTimeInSeconds.getDouble ()) System.out.println ("-- EXTRA TIME FOR SOLVER, NOW: " + solverTimeAllowed);<a name="line.726"></a>
<span class="sourceLineNo">727</span>                        stat_totalTimeSolverSecs += eTime(t);  <a name="line.727"></a>
<span class="sourceLineNo">728</span>                        solverTimeAllowed *= 2; // duplicate the time if not feasible solution is found<a name="line.728"></a>
<span class="sourceLineNo">729</span>                        //System.out.println ("Time to create program: " + (1E-9*(t-initTimeBeforeCreatingProgram)) + ", solver time " + ((System.nanoTime()-t)*1E-9) + " s ; ");<a name="line.729"></a>
<span class="sourceLineNo">730</span>                } while (!op.solutionIsFeasible());             <a name="line.730"></a>
<span class="sourceLineNo">731</span>                stat_numSolverCallsOk ++; <a name="line.731"></a>
<span class="sourceLineNo">732</span>                final DoubleMatrix2D new_x_rRests = op.getPrimalSolution("x_rRests").view2D();<a name="line.732"></a>
<span class="sourceLineNo">733</span>                final DoubleMatrix1D new_pe = DoubleFactory1D.dense.make(op.getPrimalSolution("p_e").to1DArray());<a name="line.733"></a>
<span class="sourceLineNo">734</span>                x_rs.viewSelection(rChange, null).assign(new_x_rRests);<a name="line.734"></a>
<span class="sourceLineNo">735</span>                return x_rs;<a name="line.735"></a>
<span class="sourceLineNo">736</span>        }<a name="line.736"></a>
<span class="sourceLineNo">737</span><a name="line.737"></a>
<span class="sourceLineNo">738</span>        private DoubleMatrix1D greedyAndLocalSearch_shared (long algorithmEndtime , NetPlan np)<a name="line.738"></a>
<span class="sourceLineNo">739</span>        {<a name="line.739"></a>
<span class="sourceLineNo">740</span>                final long initGreedy = System.nanoTime();<a name="line.740"></a>
<span class="sourceLineNo">741</span>                ArrayList&lt;Pair&lt;Node,Node&gt;&gt; shuffledNodePairs = new ArrayList&lt;Pair&lt;Node,Node&gt;&gt; (N*(N-1)/2); <a name="line.741"></a>
<span class="sourceLineNo">742</span>                for (Node n1 : np.getNodes ()) for (Node n2 : np.getNodes ()) if (n1.getIndex () &lt; n2.getIndex ()) shuffledNodePairs.add(Pair.of(n1, n2));<a name="line.742"></a>
<span class="sourceLineNo">743</span>                Collections.shuffle(shuffledNodePairs , rng);<a name="line.743"></a>
<span class="sourceLineNo">744</span>                DoubleMatrix1D current_xr = DoubleFactory1D.dense.make(R);<a name="line.744"></a>
<span class="sourceLineNo">745</span>                for (Pair&lt;Node,Node&gt; nodePair : shuffledNodePairs)<a name="line.745"></a>
<span class="sourceLineNo">746</span>                {<a name="line.746"></a>
<span class="sourceLineNo">747</span>                        Set&lt;Integer&gt; thisDemand = new HashSet&lt;Integer&gt; ();<a name="line.747"></a>
<span class="sourceLineNo">748</span>                        for (Demand d : np.getNodePairDemands(nodePair.getFirst(), nodePair.getSecond() , true))<a name="line.748"></a>
<span class="sourceLineNo">749</span>                                thisDemand.add(d.getIndex());<a name="line.749"></a>
<span class="sourceLineNo">750</span>//                      System.out.println("thsiDemand: " + thisDemand);<a name="line.750"></a>
<span class="sourceLineNo">751</span>                        if (jomStep_shared(thisDemand , null , current_xr) == null) throw new RuntimeException ("Returned null");<a name="line.751"></a>
<span class="sourceLineNo">752</span>                }<a name="line.752"></a>
<span class="sourceLineNo">753</span>                DoubleMatrix1D current_pe = A_er.zMult(current_xr, null); current_pe.assign(DoubleFunctions.div(tcfa_linkCapacity_numCirc.getInt ())).assign(DoubleFunctions.ceil);<a name="line.753"></a>
<span class="sourceLineNo">754</span>                double current_cost = computeCost_shared(current_xr, current_pe); <a name="line.754"></a>
<span class="sourceLineNo">755</span>                //DoubleMatrix1D best_xr = current_xr.copy(); DoubleMatrix1D best_pe = current_pe.copy(); double bestCost = ;<a name="line.755"></a>
<span class="sourceLineNo">756</span>                <a name="line.756"></a>
<span class="sourceLineNo">757</span>                System.out.println("---- Greedy solution Time " + (1E-9*(System.nanoTime() - initGreedy)) +",  Cost : "+  current_cost + ", num links: " + current_pe.zSum());<a name="line.757"></a>
<span class="sourceLineNo">758</span><a name="line.758"></a>
<span class="sourceLineNo">759</span>                while (System.nanoTime() &lt; algorithmEndtime) <a name="line.759"></a>
<span class="sourceLineNo">760</span>                {<a name="line.760"></a>
<span class="sourceLineNo">761</span>                        //DoubleMatrix1D bestNeighbor_xr = null; DoubleMatrix1D bestNeighbor_pe = null; double bestNeighborCost = Double.MAX_VALUE; Pair&lt;Long,Long&gt; bestNeighborNodePair = null;<a name="line.761"></a>
<span class="sourceLineNo">762</span>                        Collections.shuffle(shuffledNodePairs ,rng);<a name="line.762"></a>
<span class="sourceLineNo">763</span>                        final long initLSIteration = System.nanoTime();<a name="line.763"></a>
<span class="sourceLineNo">764</span><a name="line.764"></a>
<span class="sourceLineNo">765</span>                        boolean improvedSolution = false;<a name="line.765"></a>
<span class="sourceLineNo">766</span>                        for (Pair&lt;Node,Node&gt; nodePair : shuffledNodePairs)<a name="line.766"></a>
<span class="sourceLineNo">767</span>                        {<a name="line.767"></a>
<span class="sourceLineNo">768</span>//                              System.out.println("Pair: " + nodePair + ". Tabu list: " + tabuList_n1n2 + ", IS TABU: " + tabuList_n1n2.contains(nodePair));<a name="line.768"></a>
<span class="sourceLineNo">769</span>                                Set&lt;Integer&gt; demandsToChange = new HashSet&lt;Integer&gt; (); <a name="line.769"></a>
<span class="sourceLineNo">770</span>                                for (Demand d : np.getNodePairDemands(nodePair.getFirst(), nodePair.getSecond() , true))<a name="line.770"></a>
<span class="sourceLineNo">771</span>                                        demandsToChange.add(d.getIndex ()); <a name="line.771"></a>
<span class="sourceLineNo">772</span>                                DoubleMatrix1D thisNeighbor_xr = current_xr.copy(); // do not modify the original one<a name="line.772"></a>
<span class="sourceLineNo">773</span>                                if (jomStep_shared(demandsToChange , null , thisNeighbor_xr) == null) throw new RuntimeException ("Returned null");<a name="line.773"></a>
<span class="sourceLineNo">774</span>                                DoubleMatrix1D thisNeighbor_pe = A_er.zMult(thisNeighbor_xr, null); thisNeighbor_pe.assign(DoubleFunctions.div(tcfa_linkCapacity_numCirc.getInt ())).assign(DoubleFunctions.ceil);<a name="line.774"></a>
<span class="sourceLineNo">775</span>                                final double thisNeighborCost = computeCost_shared (thisNeighbor_xr , thisNeighbor_pe);<a name="line.775"></a>
<span class="sourceLineNo">776</span>                                if (thisNeighborCost &lt; current_cost)<a name="line.776"></a>
<span class="sourceLineNo">777</span>                                { <a name="line.777"></a>
<span class="sourceLineNo">778</span>                                        current_xr = thisNeighbor_xr; current_pe = thisNeighbor_pe; current_cost = thisNeighborCost; improvedSolution = true; <a name="line.778"></a>
<span class="sourceLineNo">779</span>                                        System.out.println("NEW BEST COST: " + current_cost + ", num links: " + current_pe.zSum()); <a name="line.779"></a>
<span class="sourceLineNo">780</span>                                        break; <a name="line.780"></a>
<span class="sourceLineNo">781</span>                                }<a name="line.781"></a>
<span class="sourceLineNo">782</span>                        }                       <a name="line.782"></a>
<span class="sourceLineNo">783</span>                        <a name="line.783"></a>
<span class="sourceLineNo">784</span>                        System.out.println("- Local search TIME: " + ((System.nanoTime()-initLSIteration)*1e-9) + ", current cost: " + current_cost + ", num links: " + current_pe.zSum() + ", IMPROVED: " + improvedSolution);<a name="line.784"></a>
<span class="sourceLineNo">785</span><a name="line.785"></a>
<span class="sourceLineNo">786</span>                        if (!improvedSolution) break; else stat_numLSIterationsReducingCost ++; // end grasp iteration <a name="line.786"></a>
<span class="sourceLineNo">787</span>                }<a name="line.787"></a>
<span class="sourceLineNo">788</span>                <a name="line.788"></a>
<span class="sourceLineNo">789</span>                return current_xr;<a name="line.789"></a>
<span class="sourceLineNo">790</span>        }<a name="line.790"></a>
<span class="sourceLineNo">791</span><a name="line.791"></a>
<span class="sourceLineNo">792</span>        private Pair&lt;DoubleMatrix1D,DoubleMatrix1D&gt; greedyAndLocalSearch_11 (long algorithmEndtime , NetPlan np)<a name="line.792"></a>
<span class="sourceLineNo">793</span>        {<a name="line.793"></a>
<span class="sourceLineNo">794</span>                final long initGreedy = System.nanoTime();<a name="line.794"></a>
<span class="sourceLineNo">795</span>                ArrayList&lt;Pair&lt;Node,Node&gt;&gt; shuffledNodePairs = new ArrayList&lt;Pair&lt;Node,Node&gt;&gt; (N*(N-1)/2); <a name="line.795"></a>
<span class="sourceLineNo">796</span>                for (Node n1 : np.getNodes ()) for (Node n2 : np.getNodes ()) if (n1.getIndex () &lt; n2.getIndex ()) shuffledNodePairs.add(Pair.of(n1, n2));<a name="line.796"></a>
<span class="sourceLineNo">797</span>                Collections.shuffle(shuffledNodePairs , rng);<a name="line.797"></a>
<span class="sourceLineNo">798</span>                DoubleMatrix1D current_xr = DoubleFactory1D.dense.make(R);<a name="line.798"></a>
<span class="sourceLineNo">799</span>                DoubleMatrix1D current_x2r = DoubleFactory1D.dense.make(R);<a name="line.799"></a>
<span class="sourceLineNo">800</span>                for (Pair&lt;Node,Node&gt; nodePair : shuffledNodePairs)<a name="line.800"></a>
<span class="sourceLineNo">801</span>                {<a name="line.801"></a>
<span class="sourceLineNo">802</span>                        Set&lt;Integer&gt; thisDemand = new HashSet&lt;Integer&gt; ();<a name="line.802"></a>
<span class="sourceLineNo">803</span>                        for (Demand d : np.getNodePairDemands(nodePair.getFirst(), nodePair.getSecond() , true))<a name="line.803"></a>
<span class="sourceLineNo">804</span>                                thisDemand.add(d.getIndex());<a name="line.804"></a>
<span class="sourceLineNo">805</span>                        final long t = System.nanoTime(); if (jomStep_11(thisDemand , null , current_xr , current_x2r) == null) throw new RuntimeException ("Returned null");<a name="line.805"></a>
<span class="sourceLineNo">806</span>                        //System.out.println("Node pair " + nodePair + " time increasing it: " + (1E-9*(System.nanoTime()-t)) + ", num demands: " + thisDemand.size());<a name="line.806"></a>
<span class="sourceLineNo">807</span>                }<a name="line.807"></a>
<span class="sourceLineNo">808</span>                DoubleMatrix1D current_pe = computePe_11 (current_xr , current_xr);<a name="line.808"></a>
<span class="sourceLineNo">809</span>                double current_cost = computeCost_11(current_xr, current_x2r , current_pe); <a name="line.809"></a>
<span class="sourceLineNo">810</span><a name="line.810"></a>
<span class="sourceLineNo">811</span>                System.out.println("---- Greedy solution Time " + (1E-9*(System.nanoTime() - initGreedy)) +",  Cost : "+  current_cost + ", num links: " + current_pe.zSum());<a name="line.811"></a>
<span class="sourceLineNo">812</span><a name="line.812"></a>
<span class="sourceLineNo">813</span>                while (System.nanoTime() &lt; algorithmEndtime) <a name="line.813"></a>
<span class="sourceLineNo">814</span>                {<a name="line.814"></a>
<span class="sourceLineNo">815</span>                        Collections.shuffle(shuffledNodePairs ,rng);<a name="line.815"></a>
<span class="sourceLineNo">816</span>                        final long initLSIteration = System.nanoTime();<a name="line.816"></a>
<span class="sourceLineNo">817</span><a name="line.817"></a>
<span class="sourceLineNo">818</span>                        boolean improvedSolution = false;<a name="line.818"></a>
<span class="sourceLineNo">819</span>                        for (Pair&lt;Node,Node&gt; nodePair : shuffledNodePairs)<a name="line.819"></a>
<span class="sourceLineNo">820</span>                        {<a name="line.820"></a>
<span class="sourceLineNo">821</span>                                Set&lt;Integer&gt; demandsToChange = new HashSet&lt;Integer&gt; (); <a name="line.821"></a>
<span class="sourceLineNo">822</span>                                for (Demand d : np.getNodePairDemands(nodePair.getFirst(), nodePair.getSecond() , true))<a name="line.822"></a>
<span class="sourceLineNo">823</span>                                        demandsToChange.add(d.getIndex()); <a name="line.823"></a>
<span class="sourceLineNo">824</span>                                DoubleMatrix1D thisNeighbor_xr = current_xr.copy(); // do not modify the original one<a name="line.824"></a>
<span class="sourceLineNo">825</span>                                DoubleMatrix1D thisNeighbor_x2r = current_x2r.copy(); // do not modify the original one<a name="line.825"></a>
<span class="sourceLineNo">826</span>                                if (jomStep_11(demandsToChange , null , thisNeighbor_xr , thisNeighbor_x2r) == null) throw new RuntimeException ("Returned null");<a name="line.826"></a>
<span class="sourceLineNo">827</span>                                DoubleMatrix1D thisNeighbor_pe = computePe_11(thisNeighbor_xr, thisNeighbor_x2r);<a name="line.827"></a>
<span class="sourceLineNo">828</span>                                final double thisNeighborCost = computeCost_11 (thisNeighbor_xr , thisNeighbor_x2r , thisNeighbor_pe);<a name="line.828"></a>
<span class="sourceLineNo">829</span>                                if (thisNeighborCost &lt; current_cost) <a name="line.829"></a>
<span class="sourceLineNo">830</span>                                { <a name="line.830"></a>
<span class="sourceLineNo">831</span>                                        current_xr = thisNeighbor_xr; current_x2r = thisNeighbor_x2r; current_pe = thisNeighbor_pe; current_cost = thisNeighborCost; improvedSolution = true; <a name="line.831"></a>
<span class="sourceLineNo">832</span>                                        System.out.println("NEW BEST COST: " + current_cost + ", num links: " + current_pe.zSum()); <a name="line.832"></a>
<span class="sourceLineNo">833</span>                                        break;<a name="line.833"></a>
<span class="sourceLineNo">834</span>                                }<a name="line.834"></a>
<span class="sourceLineNo">835</span>                        }                       <a name="line.835"></a>
<span class="sourceLineNo">836</span>                        <a name="line.836"></a>
<span class="sourceLineNo">837</span>                        System.out.println("- Local search TIME: " + ((System.nanoTime()-initLSIteration)*1e-9) + ", current cost: " + current_cost + ", num links: " + current_pe.zSum() + ", IMPROVED: " + improvedSolution);<a name="line.837"></a>
<span class="sourceLineNo">838</span><a name="line.838"></a>
<span class="sourceLineNo">839</span>                        if (!improvedSolution) break; else stat_numLSIterationsReducingCost ++; // end grasp iteration <a name="line.839"></a>
<span class="sourceLineNo">840</span>                }<a name="line.840"></a>
<span class="sourceLineNo">841</span>                <a name="line.841"></a>
<span class="sourceLineNo">842</span>                return Pair.of(current_xr , current_x2r);<a name="line.842"></a>
<span class="sourceLineNo">843</span>        }<a name="line.843"></a>
<span class="sourceLineNo">844</span>        private DoubleMatrix2D greedyAndLocalSearch_restoration (long algorithmEndtime , NetPlan np)<a name="line.844"></a>
<span class="sourceLineNo">845</span>        {<a name="line.845"></a>
<span class="sourceLineNo">846</span>                final long initGreedy = System.nanoTime();<a name="line.846"></a>
<span class="sourceLineNo">847</span>                ArrayList&lt;Pair&lt;Node,Node&gt;&gt; shuffledNodePairs = new ArrayList&lt;Pair&lt;Node,Node&gt;&gt; (N*(N-1)/2); <a name="line.847"></a>
<span class="sourceLineNo">848</span>                for (Node n1 : np.getNodes ()) for (Node n2 : np.getNodes ()) if (n1.getIndex () &lt; n2.getIndex()) shuffledNodePairs.add(Pair.of(n1, n2));<a name="line.848"></a>
<span class="sourceLineNo">849</span>                Collections.shuffle(shuffledNodePairs , rng);<a name="line.849"></a>
<span class="sourceLineNo">850</span>                DoubleMatrix2D current_xrs = DoubleFactory2D.dense.make(R,1+nSRGs);<a name="line.850"></a>
<span class="sourceLineNo">851</span>                for (Pair&lt;Node,Node&gt; nodePair : shuffledNodePairs)<a name="line.851"></a>
<span class="sourceLineNo">852</span>                {<a name="line.852"></a>
<span class="sourceLineNo">853</span>                        Set&lt;Integer&gt; thisDemand = new HashSet&lt;Integer&gt; ();<a name="line.853"></a>
<span class="sourceLineNo">854</span>                        for (Demand d : np.getNodePairDemands(nodePair.getFirst(), nodePair.getSecond(),true))<a name="line.854"></a>
<span class="sourceLineNo">855</span>                                thisDemand.add(d.getIndex ());<a name="line.855"></a>
<span class="sourceLineNo">856</span>//                      System.out.println("thsiDemand: " + thisDemand);<a name="line.856"></a>
<span class="sourceLineNo">857</span>                        if (jomStep_restoration(thisDemand , null , current_xrs) == null) throw new RuntimeException ("Returned null");<a name="line.857"></a>
<span class="sourceLineNo">858</span>                }<a name="line.858"></a>
<span class="sourceLineNo">859</span>                DoubleMatrix1D current_pe = computePe_restoration(current_xrs);<a name="line.859"></a>
<span class="sourceLineNo">860</span>                double current_cost = computeCost_shared(current_xrs.viewColumn(0), current_pe); <a name="line.860"></a>
<span class="sourceLineNo">861</span>                <a name="line.861"></a>
<span class="sourceLineNo">862</span>                System.out.println("---- Greedy solution Time " + (1E-9*(System.nanoTime() - initGreedy)) +",  Cost : "+  current_cost + ", num links: " + current_pe.zSum() + ", SRGs: " + nSRGs);<a name="line.862"></a>
<span class="sourceLineNo">863</span><a name="line.863"></a>
<span class="sourceLineNo">864</span>                while (System.nanoTime() &lt; algorithmEndtime) <a name="line.864"></a>
<span class="sourceLineNo">865</span>                {<a name="line.865"></a>
<span class="sourceLineNo">866</span>                        Collections.shuffle(shuffledNodePairs ,rng);<a name="line.866"></a>
<span class="sourceLineNo">867</span>                        final long initLSIteration = System.nanoTime();<a name="line.867"></a>
<span class="sourceLineNo">868</span><a name="line.868"></a>
<span class="sourceLineNo">869</span>                        boolean improvedSolution = false;<a name="line.869"></a>
<span class="sourceLineNo">870</span>                        for (Pair&lt;Node,Node&gt; nodePair : shuffledNodePairs)<a name="line.870"></a>
<span class="sourceLineNo">871</span>                        {<a name="line.871"></a>
<span class="sourceLineNo">872</span>                                Set&lt;Integer&gt; demandsToChange = new HashSet&lt;Integer&gt; (); <a name="line.872"></a>
<span class="sourceLineNo">873</span>                                for (Demand d : np.getNodePairDemands(nodePair.getFirst(), nodePair.getSecond() , true))<a name="line.873"></a>
<span class="sourceLineNo">874</span>                                        demandsToChange.add(d.getIndex()); <a name="line.874"></a>
<span class="sourceLineNo">875</span>                                DoubleMatrix2D thisNeighbor_xrs = current_xrs.copy(); // do not modify the original one<a name="line.875"></a>
<span class="sourceLineNo">876</span>                                if (jomStep_restoration(demandsToChange , null , thisNeighbor_xrs) == null) throw new RuntimeException ("Returned null");<a name="line.876"></a>
<span class="sourceLineNo">877</span>                                DoubleMatrix1D thisNeighbor_pe = computePe_restoration(thisNeighbor_xrs);<a name="line.877"></a>
<span class="sourceLineNo">878</span>                                final double thisNeighborCost = computeCost_shared (thisNeighbor_xrs.viewColumn(0) , thisNeighbor_pe);<a name="line.878"></a>
<span class="sourceLineNo">879</span>                                if (thisNeighborCost &lt; current_cost) <a name="line.879"></a>
<span class="sourceLineNo">880</span>                                { <a name="line.880"></a>
<span class="sourceLineNo">881</span>                                        current_xrs = thisNeighbor_xrs; current_pe = thisNeighbor_pe; current_cost = thisNeighborCost; improvedSolution = true; <a name="line.881"></a>
<span class="sourceLineNo">882</span>                                        System.out.println("NEW BEST COST: " + current_cost + ", num links: " + current_pe.zSum()); <a name="line.882"></a>
<span class="sourceLineNo">883</span>                                        break; <a name="line.883"></a>
<span class="sourceLineNo">884</span>                                }<a name="line.884"></a>
<span class="sourceLineNo">885</span>                        }                       <a name="line.885"></a>
<span class="sourceLineNo">886</span>                        <a name="line.886"></a>
<span class="sourceLineNo">887</span>                        System.out.println("- Local search TIME: " + ((System.nanoTime()-initLSIteration)*1e-9) + ", current cost: " + current_cost + ", num links: " + current_pe.zSum() + ", IMPROVED: " + improvedSolution);<a name="line.887"></a>
<span class="sourceLineNo">888</span><a name="line.888"></a>
<span class="sourceLineNo">889</span>                        if (!improvedSolution) break; else stat_numLSIterationsReducingCost ++; // end grasp iteration <a name="line.889"></a>
<span class="sourceLineNo">890</span>                }<a name="line.890"></a>
<span class="sourceLineNo">891</span>                <a name="line.891"></a>
<span class="sourceLineNo">892</span>                return current_xrs;<a name="line.892"></a>
<span class="sourceLineNo">893</span>        }<a name="line.893"></a>
<span class="sourceLineNo">894</span>        <a name="line.894"></a>
<span class="sourceLineNo">895</span>        private DoubleMatrix1D computePe_11 (DoubleMatrix1D x_r , DoubleMatrix1D x2_r)<a name="line.895"></a>
<span class="sourceLineNo">896</span>        {<a name="line.896"></a>
<span class="sourceLineNo">897</span>                DoubleMatrix1D p_e = A_er.zMult(x_r, null);<a name="line.897"></a>
<span class="sourceLineNo">898</span>                DoubleMatrix1D backup_occup_e = A_er.zMult(x2_r, null);<a name="line.898"></a>
<span class="sourceLineNo">899</span>                for (int e = 0 ; e &lt; Efm ; e ++) p_e.set(e , p_e.get(e) + backup_occup_e.get(e));<a name="line.899"></a>
<span class="sourceLineNo">900</span>                p_e.assign(DoubleFunctions.div(tcfa_linkCapacity_numCirc.getInt ())).assign(DoubleFunctions.ceil);<a name="line.900"></a>
<span class="sourceLineNo">901</span>                return p_e;<a name="line.901"></a>
<span class="sourceLineNo">902</span>        }<a name="line.902"></a>
<span class="sourceLineNo">903</span>        private DoubleMatrix1D computePe_restoration (DoubleMatrix2D x_rs)<a name="line.903"></a>
<span class="sourceLineNo">904</span>        {<a name="line.904"></a>
<span class="sourceLineNo">905</span>                DoubleMatrix2D p_es = A_er.zMult(x_rs, null); DoubleMatrix1D p_e = DoubleFactory1D.dense.make(Efm); <a name="line.905"></a>
<span class="sourceLineNo">906</span>                for (int e = 0; e &lt; Efm ; e ++) p_e.set(e , p_es.viewRow(e).getMaxLocation() [0]); // the maximum per state s<a name="line.906"></a>
<span class="sourceLineNo">907</span>                p_e.assign(DoubleFunctions.div(tcfa_linkCapacity_numCirc.getInt ())).assign(DoubleFunctions.ceil);<a name="line.907"></a>
<span class="sourceLineNo">908</span>                return p_e;<a name="line.908"></a>
<span class="sourceLineNo">909</span>        }<a name="line.909"></a>
<span class="sourceLineNo">910</span>        <a name="line.910"></a>
<span class="sourceLineNo">911</span>        private double eTime (long init) { return 1E-9*(System.nanoTime() - init); }<a name="line.911"></a>
<span class="sourceLineNo">912</span>        <a name="line.912"></a>
<span class="sourceLineNo">913</span>        private static int [] getIndexes (Collection&lt;? extends NetworkElement&gt; col) { final int [] res = new int [col.size ()]; int cont = 0; for (NetworkElement el : col) res [cont++] = el.getIndex (); return res; }<a name="line.913"></a>
<span class="sourceLineNo">914</span>        <a name="line.914"></a>
<span class="sourceLineNo">915</span>        <a name="line.915"></a>
<span class="sourceLineNo">916</span>}<a name="line.916"></a>




























































</pre>
</div>
</body>
</html>
